<!DOCTYPE html>
<html>
  <head>
    <title>C++-For (2) - Monday Part 2</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
    <!-- when changing the stylesheet file please see also remark below -->
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies aproximately 2/3 of the page width. So only add
  little information, preferrably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open – add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++ FOR]: 00_content.html#agenda

# [C++ FOR] (Monday Afternoon)

-------------------------------------------------------------------------------

1. [Template Basics					](#template_basics)
1. [Exception Basics					](#exception_basics)
1. [Library Basics - Strings				](#string_basics)
1. [Library Basics - I/O-Streams			](#iostream_basics)

-------------------------------------------------------------------------------

Kürzere Pausen werden jeweils nach Bedarf eingelegt.

Die Besprechung der Musterlösung(en) erfolgt zu Beginn des folgenden Vormittags.

---
template: linkinfo
graphic: ParametrizedTypesAndSizes
name: template_basics
header: ## Grundlegendes zu Templates

-------------------------------------------------------------------------------

* [Parametrisierte Typen und …			](#parametrized_types)

* [… Compilezeit-Konstanten …			](#parametrized_constants)

* [… am Beispiel einer `RingBuffer`-Klasse	](#example_ringbuffer)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: ParametrizedTypesAndSizes
section: Parametrizing Type
name: parametrized_types
header: ### Parametrisierte Typen

Ursprünglich sollte mit den C++-Templates vor allem weitgehend identischer Code
reduziert werden, wenn es in verschiedenen Varianten einer Klasse oder (Member)
Funktion nur um andere Datentypen geht.

* Die Funktion oder Klasse ist hierzu mit einer formalen Typ-Parameterliste in
  spitzen Klammern zu versehen.

* Derin werden dem Compiler **symbolische Namen** für die parametrisierten Typen
  angekündigt.._[]

Diese Namen können in der nachfolgenden Implementierung der Klasse oder Funktion
überall dort verwendet werden, wo syntaktisch ein Typ stehen kann bzw. muss.

.F[:
Each name is preceeded by the keyword `class` or `typename`, which may be used
interchangeably with same meaning here. (But note that the two keywords have
different meanings elsewhere.)
]

.N[
Bei der späteren Verwendung der Template – auch Instanziierung genannt – sind
in den spitzen Klammern konkrete Typen einzutragen.
]
  
---
template: withinfo
graphic: ParametrizedTypesAndSizes
section: Parametrizing Size
name: parametrized_constants
header: ### Parametrisierte Compilezeit-Konstanten

Im Rahmen einer Template-Klasse oder -Funktion können nicht nur Typen sondern
auch Compilezeit-Konstanten parametrisiert werden.

Hierzu ist

* die Funktion oder Klasse mit einer formalen Wert-Parameterliste in spitzen
  Klammern zu versehen,

* in welcher dem Compiler **Typen und symbolische Namen** der parametrisierten
  Compilezeit Konstanten angekündigt werden.

Die symbolischen Namen können in der nachfolgenden in der Implementierung der
Klasse oder Funktion überall dort verwendet werden, wo syntaktisch eine
Compilezeit-Konstante des betreffenden Typs stehen kann.

.N[
Bei der späteren Verwendung der Template – auch Instanziierung genannt – sind
in den spitzen Klammern konkrete Compilezeit-Konstanten einzutragen.
]
  
---
template: withinfo
graphic: ParametrizedTypesAndSizes
section: Parametrizing Type and Size
name: example_ringbuffer
header: ### Beispiel `RingBuffer`

Die Erweiterung der zunächst für einen bestimmten Datentyp und eine bestimmte
Größe implementierten `RingBuffer`-Klasse zu einer Template kann mehr oder
weniger "mechanisch" durch "Suchen und Ersetzen" erfolgen:

* Das wird dadurch begünstigt, dass im ursprünglichen Code der Datentyp `double`
  nur dort auftritt, wo in der Template-Variante der parametrisierte Typ steht.

* Die Konstante `11` steht im ursprünglichen Code für die Anzahl der im
  `RingBuffer` maximal ablegbaren Elemente **Plus Eins**.._[]

  * In der Template-Variante erscheint es sinnvoll, als Parameter die Nettogröße
    (also die maximale Anzahl der Elemente) anzugeben, die der `RingBuffer`
    zwischenspeichern soll.

  * Dies ist leicht realisierbar, indem die Konstante `11` jeweils durch `N+1`
    ersetzt wird.

.F[:
So that "empty" and "full" state can be easily discerned without an additional
flag, the buffer never gets completely filled but a single element is always
left unused, if the position into which to "put" is directly behind the position
from which to "get".
]

---
template: linkinfo
graphic: ExceptionBasics
name: exception_basics
header: ## Exception Basics

-------------------------------------------------------------------------------

* [Hierarchien von Exception-Klassen		](#exception_hierarchies)

-------------------------------------------------------------------------------

* [Kontrollfluss mit und ohne Exceptions	](#exception_flowcontrol)

-------------------------------------------------------------------------------

* [Exception Klassen als "Label" verstanden	](#exception_as_label)
* [Gruppieren ähnlicher Exceptions 		](#exception_grouping)
* [Aktivieren eines Behandlungs-Blocks		](#exception_try_block)

-------------------------------------------------------------------------------

* [Unvollständig behandelte Exceptions		](#exception_rethrow)
* [Fangen aller Exceptions			](#exception_catchall)

---
template: withinfo
graphic: ExceptionBasics
section: Exception Class Hierarchies
name: exception_hierarchies
header: ### Hierarchien von Exception-Klassen

Die im Rahmen von Bibliotheksfuntionen ggf. geworfenen Exceptions bilden eine
Klassenhierarchie:

* An deren Spitze steht die Klasse `std::exception`.

* Weitere Klassen sind oft als Basisklassen für eigene Exception-Klassen
  sinnvoll, etwa

  * `std::logic_error` oder

  * `std::runtime_error`.

---
template: withinfo
graphic: ExceptionBasics
section: Execution Path taken for Exception
name: exception_flowcontrol
header: ### Kontrollfluss mit und ohne Exception

Solange keine Exceptions geworfen werden,

* folgt der Kontrollfluss den üblichen Regeln, und

* alle auf `try`-Blöcke folgenden `catch`-Blöcke werden übersprungen.

---
template: withinfo
graphic: ExceptionBasics
section: Exception Classes Viewn as Labels
name: exception_as_label
header: ### Exception Klassen als "Label" verstanden

Sobald eine `throw`-Anweisung ausgeführt wird, stellen die den aktiven
`try`-Blöcken nachfolgenden `catch`-Blöcke eine Art Label dar:

* Verzweigt wird grundsätzlich im Kontrollfluss rückwärts, also in Richtung
  auf die `main`-Funktion.

* Die Auswahl der `catch`-Blöcke erfolgt dabei
  * gemäß der dynamischen Schachtelung der Funktionsaufrufe, und
  * dort ggf. für die einen einzelnen `catch-`Blöcke` von oben nach unten.

* Der erste `catch`-Block, bei dem der Typ des "Arguments" der `catch`-Anweisung
  zum Typ der geworfenen Exception passt, wird gewählt.

---
template: withinfo
graphic: ExceptionBasics
section: Grouping Exceptions
name: exception_grouping
header: ### Gruppieren ähnlicher Exceptions

Bei der Auswahl des `catch`-Blocks werden in Bezug auf den Typ der geworfenen
Exceptions auch mögliche Umwandlungen berücksichtigt:

* Prinzipiell gelten die selben Umwandlungen wie bei der Parameterübergabe im
  Rahmen von Funktionsaufrufen.

* Insbesondere gilt das LSP:

  * abgeleitete Klassen passen zu ihren jeweiligen Basisklassen.

* Dies macht es sinnvoll, ähnliche Exceptions mittels kleiner oder größerer
  Klassenhierarchien zusammenzufassen.

---
template: withinfo
graphic: ExceptionBasics
section: Enabling Handler Blocks
name: exception_try_block
header: ### Aktivieren der Ausnahmebehandlung

Als Sprungziel in Frage kommen die **aktiven** `catch`-Blöcke.

* Das sind alle `catch`-Blöcke,

  * deren vorangehender `try`-Block vom Kontrollfluss erreicht …

  * … und noch nicht wieder verlassen wurde.

.N[
Ein `try`-Block ist nicht mehr aktiv, wenn er explizit verlassen wird durch

* `return`
* `break`
* `continue`

oder die letzte enthaltene Anweisung vollständig ausgeführt wurde.
]

Ab diesem Moment werden auch die nachfolgenden `catch`-Blöcke nicht mehr als
"Sprungziel" für ein `throw` in Betracht gezogen.

---
template: withinfo
graphic: ExceptionBasics
section: Re-throw Exceptions
name: exception_rethrow
header: ### Unvollständig behandelte Exceptions

Catch-Blöcke, welche nur eine teilweise Auflösung der Fehlersituation leisten,
können die gefangene Exception erneut werfen:
```
    try {
        …
        … // code that may throw SomeException
        …
    }
    catch (SomeException &ex) {
        …
        … // partial recovery only
        …
        throw;
    }
}
```

---
template: withinfo
graphic: ExceptionBasics
section: Catch Any Exception
name: exception_catchall
header: ### Fangen aller Exceptions

Es besteht die Möglichkeit, einen `catch`-Block für alle erdenklichen
Exception "passend" zu machen:

* Hierzu sind in den runden Klammern drei Punkte (analog zu variadischen
  Funktionen) anzugeben.

  * Ein solcher Block sollte immer am Ende aller `catch`-Blöcke zu einem
    `try`-Block stehen.

  * Andernfalls gilt er vorrangig zu spezifischeren, nachfolgenden
    `catch`-Blöcken des selben `try`-Blocks.

```
int main() {
    try {
        …
        …
    }
    catch (...) {
        std::cerr << "!! unhandled exception !!\n";
    }
}
```

---
template: linkinfo
graphic: StringBasics
name: string_basics
header: ## Verwendung von Standard-Strings

-------------------------------------------------------------------------------

* [Klassen (Übersicht)			](#stdstring_classes)
* [Kompatibilität zu C			](#stdstring_cstr)
* [Effizienz üblicher Implementierungen	](#stdstring_efficiency)
* [Optionales "Copy On Write"		](#stdstring_cow)

-------------------------------------------------------------------------------

* [Grundlegende Operationen		](#stdstring_basicops)
* [Weitere Operationen im Überblick	](#stdstring_moreops)
* [Umwandlung von/in arithmetische Werte](#stdstring_numconv)
* [Ein- und Ausgabe                     ](#stdstring_io)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: StringBasics
section: Classes
name: stdstring_classes
header: ### Klassen (Übersicht)

Die aus C++98 bekannten `std::string` und `std::wstring` sowie die von C++11
hinzugefügten Klassen `std::u16string` und `std::u32string` sind lediglich
Typdefinitionen:._[]
```
namespace std {
    typedef basic_string<char> string;      // since C++98
    typedef basic_string<wchar_t> wstring;  // since C++98
    typedef basic_string<char16_t> wstring; // since C++11
    typedef basic_string<char32_t> wstring; // since C++11
}
```

Weitere Details sind nachzuschlagen in:

* http://en.cppreference.com/w/string/
* http://www.cplusplus.com/string/

.F[:
The type definitions show only half the truth: other template arguments are a
character traits class and an allocator (memory management policy). Both have
been omitted as they do not change the essential point to make.
]

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_cstr
header: ### Kompatibilität zu C

Die Klasse `std::string` speichert die Zeichen eines Strings in einem
zusammenhängenden._[] Speicherstück, das in der jeweils erforderlichen
Mindestgröße auf dem Heap angelegt wird.

Ein Objekt der `std::string`-Klasse speichert typischerweise drei Zeiger:

* Die Adresse des ersten enthaltenen Zeichens.

* Die Addresse des letzten enthaltenen Zeichens.

* Die Addresse bis zu der Speicher alloziert ist.

.N[
Insbsondere sind die gültigen Zeichen nicht dahingehend eingeschränkt, dass ein
ein Zeichen mit der ganzzahligen Wertigkeit 0 (ein "NUL-Byte") die Zeichenkette
beendet – in einem `std::string` können beliebige auch als eingebetteter Inhalt
auftreten.
]

.F[:
The C++98 standard left it to the library implementors whether to chose
contiguous or non-contiguous storage though that freedom might be removed
in a future version of the standard.
]

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_cstr_use
header: #### `std::string` als `const char *` verwenden

Dort woe ein C-API `const char *` erwartet, muss ein `std::string` entsprechend
umgewandelt übergeben werden:
```
std::string filename;
… // get file name from user (or elsewhere)
// open file for reading, using the C-API
FILE *fp = std::fopen(filename.c_str(), "r");
```

Der obige Code ist korrekt und risikolos, da auf den von `c_str()` gelieferten
Zeiger (bzw. der darüber erreichbare String-Inhalt) nur kurzzeitig innerhalb von
`std::fopen` zugegriffen wird.

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_cstr_risk
header: #### Risiken von `c_str()`

bei der Verwendung von `c_str()` sollte klar sein, dass hierüber Zugang zu dem
für den `std::string`-Inhalt auf dem Heap angelegten Speicherplatz gewährt wird:

.W[
Code wie der nachfolgende ist somit hochgradig riskant: der Zugriff auf `p`
zeigt nach jeder Veränderung des Inhalts von `s` möglicherweise nicht mehr
auf gültigen oder auf mittlerweile für andere Zwecke allozierten
Speicherplatz.._F[]
]

.pull-left[
```
std::string s("see me, ");
const char *p = s.c_str();
s += std::string("feel me,");
…
s.append(" touch me, hear me");
…
```
]

.pull-right[
```
char *
mamamia(std::string arg) {
    …
    return arg.data();    // as
    // of C++11 same as c_str()
}
```
]

.F[:
In the example on the right hand side, storing and then derefencing the
pointer returned will access deallocated heap memory once owned by `arg`
with near to 100% certainty.
]

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_cstr
header: #### `const char *` als `std::string` verwenden

Die Umwandlung eines klassischen C-Strings in ein `std::string`-Objekt ist
durch einen entsprechenden, als Typumwandlung wirkenden (nicht expliziten)
Konstruktor stets unproblematisch.

.I[
Sollen Funktionen sowohl mit (unveränderbaren) `std::string`-Argumenten als auch
mit klassischen String-Literalen im C-Stil aufrufbar sein, besteht die sparsamte
Lösung in der Verwendung des Argumenttyps `const std::string &`.
]

Eine – gemessen am zu schreibenden Code – deutlich aufwändigere Lösung ist es,
Überladungen für

* `const char *`,
* `std::string &` und
* evtl. `std::string &&`

bereitzustellen. Andererseits kann jede Version damit für den übergebenen
Parametertyp optimiert werden.

---
template: withinfo
graphic: StringBasics
section: Efficiency
name: stdstring_efficiency
header: ### Effizienz

[Small String Optimization]: http://john-ahlgren.blogspot.de/2012/03/small-string-optimization-and-move.html

Typische Implementierungen der `std::string`-Klasse nutzen die folgenden
Maßnahmen zur Effizienzsteigerung:

* Allozierung von Überschuss-Speicherplatz am Ende.

* Wenn nötig propotionale Vergrößerung._[] der Allozierung (nicht mit
  konstanten Faktor).

* Insbesondere auf 64-Bit Hardware lohnend: [Small String Optimization]

.F[:
This means that when the current allocation doesn't suffice any more it will be
doubled (or made 1.5 or 1.8 times as large). This gives O(1) performance to
algorithms that fill a very long character string by appending single characters
to the end, while increasing the allocation by a fixed amount would yield
O(N<sup>2</sup>) performance.
]

---
template: withinfo
graphic: StringBasics
section: May or May not Have COW-Implementation
name: stdstring_cow
header: ### Copy On Write

[Copy On Write (COW)]: http://www.gotw.ca/publications/optimizations.htm

Durch diese Optimierung lässt sich insbesondere Code "verbessern", welcher
häufig `std::string`s als Wertargument übergibt, obwohl eine konstante
Referenz eher angemessen wäre.

* Das Kopieren des eigentliche Inhalts eines `std::string` wird dabei
  verzögert.

* Stattdessen wird ein "Merker" gesetzt, dass das Kopieren beim ersten
  schreibenden Zugriff nachgeholt werden muss.

* Bis dahin teilen sich mehrere "Nutzer" den Inhat beim nur lesenden Zugriff.

.N[
[Copy On Write (COW)] Implementierungen, sind mittlerweile weniger häufig,
insbesondere in multi-threaded Ablaufumgebungen, da dort oft die möglichen
Performance-Vorteile durch gelegentlich ersparte Kopien geringer zu Buche
schlagen als der Nachteil, alle Zugriffe auf den String-Inhalt durch geeignete
Mechanismen koordinieren zu müssen.
]

---
template: withinfo
graphic: StringBasics
section: Basic Operations
name: stdstring_basicops

header: ### Grundlegende Operationen

Soweit diese nicht ohnehin intuitiv verständlich sind, wie

* Zuweisung mit `=`,

* Vergleich mit `==`, `!=` usw.

* Verkettung mit `+` sowie

* Elementzugriff mit `[…]`

stellen sie üblicherweise keine hohe Hürde dar.

.N[
Eine Überlegung zum Programmierstil beim Element-Zugriff könnte sein, diesen in
nicht performance-kritischem Code konsequent mit der Member-Funktion `at()`
vorzunehmen, um undefiertes Verhalten bei Bereichsüberschreitungen zuverlässig
zu vermeiden.
]

---
template: withinfo
graphic: StringBasics
section: Advanced Operations
name: stdstring_moreops

header: ### Weitere Operationen im Überblick

Hierfür sei an dieser Stelle auf die – beabsichtigte – Ähnlichkeit zwischen
`std::string` und `std::vector<char>` verwiesen:

* Auch ein `std::string` bietet die übliche Iterator-Schnittstelle.

* Insofern sind neben den speziellen `std::string` Member-Funktionen auch alle
  STL-Algorithmen anwendbar.

Was jeweils zu gut verständlichen Code führt, hängt vom Einzelfall ab:
```
std::string s;
…
// process lines not only containing horizontal white-space:
if (std::getline(std::cin, s)
 && s.find_first_not_of(" \t") == std::string::npos)) …

// or alternatively:
if (std::getline(std::cin, s)
 && std::all_of(s.begin(), s.end(),
                [](char c) { return (c == ' ' || c == '\t'); })) …
```

---
template: withinfo
graphic: StringBasics
section: Numeric Conversions
name: stdstring_numconv

header: ### Umwandlung von/in arithmetische Werte

Die Umwandlung zwischen Zeichenketten und arithmetische Werte in interner
Darstellung (`int`, `unsigned`, `long`, … `double`) gehört zu den häufig
zu lösenden Aufgaben.

Vielfach findet man hier noch sehr umständlichen, unzureichenden oder teils
sogar gefährlichen Code:
```
std::string tmpfilename; // fixed part followed by sequence number
…
const char *cp = tmpfilename.c_str();
while (*cp && !std::isdigit(*cp)) ++cp; // locate number
int num = atoi(cp);                     // get value into some int
std::sprintf(cp, "%d", ++num);          // store back incremented
```

---
template: plain
name: stdstring_str2num
header: #### `std::string` in arithmetischen Wert umwandeln

C++11 hat zu diesem Zweck eine Reihe neuer Funktionen eingeführt:

* Das Namensschema ist `std::sto…` für *String To"

* gefolgt von einem charakteristischen Buchstaben oder einer Kombination von
  Buchstaben:

  * `stoi` für Umwandlung nach `int`
  * `stol` für Umwandlung nach `long`
  * `stoul` für Umwandlung nach `unsigned long`
  * `stoll` für Umwandlung nach `long long`
  * `stoull` für Umwandlung nach `unsigned long long`
  * `stof` für Umwandlung nach `float`
  * `stod` für Umwandlung nach `double`
  * `stold` für Umwandlung nach `long double`

Die Parametrisierung ist ähnlich zu den C-Funktionen `strtol`, `strtoul` und
`strtof`, d.h. über ein weiteres (Zeiger-) Argument kann die Position des
Zeichens ermittelt werden, bei dem die Umwandlung beendet wurde, und ein
drittes Argument legt die Basis des Zahlensystems (2..36) fest.

---
template: plain
name: stdstring_num2str
header: #### Arithmetischen Werte in `std::string` umwandeln

Für die Umwandlung von numerischen Werten in `std::string` führte C++11 die
Funktion `std::to_string` mit zahlreichen Überladungen ein.

Ihre Anwendung ist trivial und (zusammen mit der auf der vorherigen Seite
eingeführten Funktion `std::stoull` aus folgendem Beispiel ersichtlich:
```
std::string tmpfilename; // fixed part followed by sequence number
…
const auto n1 = tmpfilename.find_first_of("0123456789");
assert(n1 != std::string::npos);
const auto n2 = tmpfilename.find_first_not_of("0123456789", n1+1);
std::size_t nx;
const auto num = std::stou(tmpfilename.substr(n1, n2), &nx);
assert(nx == n2-n1);
tmpfilename = tmpfilename.substr(0, n1)
            + std::to_string(num+1)
            + tmpfilename.substr(n2);
```

---
template: withinfo
graphic: StringBasics
section: Input and Output
name: stdstring_io
header: ### Ein- und Ausgabe

Die Ausgabe von Zeichenketten erfolgt üblicherweise mit dem überladenene
Ausgabeoperator:
```
std::string greet{"hello, world"};
…
std::cout << greet;
```

---
template: withinfo
graphic: StringBasics
section: Input and Output
name: stdstring_in_word
header: #### Lesen mit `operator>>`

[White Space]: http://de.wikipedia.org/wiki/Leerraum

Der für `std::string` überladene `operator>>` liest wortweise:
```
std::string word;
while (std::cin >> word) …
```

Als Trennung zwischen den Worten gelten hier beliebig lange Leerraum-Folgen
([White Space]a, üblicherweise (mindestens) die Zeichen:

* Zeilenvorschub (`'\n'`)
* Leerzeichen (`' '`) sowie
* horizontale und vertikale Tabulatoren (`'\t'` und `'\v'`).

.N[
Beim Lesen von `std::string`-s mit `operator>>` können in der Regel keine
Leerzeilen erkannt (und speziell verarbeitet) werden, da alle Zeilenvorschübe
im Rahmen des Überspringens von [White Space] stillschweigend verworfen werden.
]

---
template: withinfo
graphic: StringBasics
section: Input and Output
name: stdstring_in_word
header: #### Lesen mit `std::getline`

Eingabe können auch zeilenweise in einen `std::string` gelesen werden
```
std::string line;
… std::getline(std::cin, line) …
```

oder bis zu einem beliebigen Begrenzer:
```
std::string field;
… std::getline(std::cin, field, ':') …
```

.N[
Sehr flexibel ist das obige Verfahren jedoch nicht, da stets nur **genau ein**
Begrenzerzeichen vorgegeben werden kann.
]

Eine Zeichenauswahl – z.B. Punkt, Komma oder Semikolon – ist nicht möglich.._[]

.F[:
Though a small helper function accepting a delimiter sets shouldn't be that hard
to write …
]

---
template: linkinfo
graphic: IOStreamBasics
name: iostream_basics
header: ## Verwendung von IO-Streams

-------------------------------------------------------------------------------

* [Front-End und … 	](#iostream_frontend)
* [… Back-End 		](#iostream_backend)

-------------------------------------------------------------------------------

* [Zustands-Bits 	](#iostream_statebits)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: iostream_frontend
header: ### Front-End der I/O-Streams

Das Front-End der I/O-Streams besteht aus

* der Basisklasse `std::ios`._[] mit einigen allgemeinen Definitionen

* davon abgeleitet die Klassen `std::istream` und `std::ostream`, welche vor
  allem in Form von Referenzargumenten zur Parametrisierung von I/O-Strömen
  als Funktionsargumente verwendet werden,

* sowie als Klassen, von denen auch Objekte angelegt werden

  * `std::ifstream`, `std::ofstream` und `std::fstream` (File-Streams) und

  * `std::istringstream`, `std::ostringstream`, und `std::stringstream`
     (String-Streams).

.F[:
As with `std::string` the architecture is even more generic as the "classes"
explained above are rather `typedef`s for more generic template classes, each
of which is parametrized in a character type and some more aspects. This fact
need not be made prominently visible if – as it is the case here – the focus
is to explain the relation between the classes participating in the design.
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: io_streams
header: #### Gemeinsame Schnittstelle

Die von einer Applikation verwendbaren Operationen zur Ein- und Ausgabe liegen
teils als Member der Klassen `std::istream` und `std::ostream` vor, teils sind
es globale Funktionen.

.N[
Zur Unterstützung benutzerdefinierter Datentypen können auch weitere globale
Überladungen von `operator>>` und `operator<<` existieren.
]

Für alles weitere wird auf die Standarddokumentation verwiesen, z.B.:

* http://en.cppreference.com/w/cpp/io/basic_ios
* http://en.cppreference.com/w/cpp/io/basic_istream
* http://en.cppreference.com/w/cpp/io/basic_ostream

---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: io_filestreams
header: #### Filestreams

Die Verwendung erfolgt typischerweise abhängig von der gewünschten Richtung des
Datenstroms:

* `std::ifstream` zum Lesen
* `std::ofstream` zum Schreiben

Darüberhinaus gibt es auch bidirektional verwendbare Filestreams:

* `std::fstream`

Für alles weitere wird auf die Standarddokumentation verwiesen, z.B.:

* http://en.cppreference.com/w/cpp/io/basic_fstream
* http://en.cppreference.com/w/cpp/io/basic_ifstream
* http://en.cppreference.com/w/cpp/io/basic_ofstream


---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: io_stringstreams
header: #### Stringstreams

Die Verwendung erfolgt typischerweise abhängig von der gewünschten Richtung des
Datenstroms:

* `std::istringstream` zum Lesen
* `std::ostringstream` zum Schreiben

Darüberhinaus gibt es auch bidirektional verwendbare Stringstreams:

* `std::stringstream`

Für alles weitere wird auf die Standarddokumentation verwiesen, z.B.:

* http://en.cppreference.com/w/cpp/io/basic_stringstream
* http://en.cppreference.com/w/cpp/io/basic_istringstream
* http://en.cppreference.com/w/cpp/io/basic_ostringstream

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Streams Back-End
name: iostream_backend
header: ### Back-End der I/O-Streams

Das Backend der I/O-Streams implementiert vor allem aus einem Mechanimus zur
Datenpufferung.

.N[
Damit kann insbesondere die Übertragung von Daten in Richtung von oder zu
einem permanenten Speicher in Blockgrößen erfolgen kann, welche die lesende
oder schreibende Applikation selbst nicht weiter berücksichtigen muss.
]

Für alles weitere wird auf die Standarddokumentation verwiesen, z.B.:

* http://en.cppreference.com/w/cpp/io/basic_streambuf
* http://en.cppreference.com/w/cpp/io/basic_filebuf
* http://en.cppreference.com/w/cpp/io/basic_stringbuf

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Streams State-Bits
name: iostream_statebits
header: ### Zustands-Bits der I/O-Streams

Jeder Stream besitzt eine Reihe von Zustandsbits.

* So lange keines davon gesetzt ist, befindet sich der Stream im "good"-Zustand.

* Bei im Rahmen der Eingabe eines bestimmten Datentyps unerwarteten – also nicht
  zu verarbeitenden – Zeichen, wird das `std::ios::badbit`-Bit gesetzt.

* Tritt im Rahmen der Eingabe die *End-Of-File*-Bedingung ein, wird das
  `std::ios::eofbit` gesetzt.

* Bei anderen (vom Standard nicht näher spezifierten) Fehlerbedinungen kann auch
  das `std::ios::badbit` gesetzt werden.

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Streams State-Bits
name: iostream_statebits
header: #### Verhalten der I/O-Streams abhängig vom Zustand

Solange eines der genannten Bits gesetzt ist, werden von dem betreffenden Stream
alle Operationen ignoriert, **ausgenommen `clear()` und `close()`**.

Dies ist besonders bei der Verarbeitung von Eingaben wichtig:

* Beim Wechsel des Zustands bleibt die aktuelle Position – also welches Zeichen
  als nächstes im Rahmen einer Eingabe verarbeitet wird – so, wie sie beim
  **Auslösen** des Zustandswechsels war.

* Bei einem Fehler im Eingabeformat, z.B. wenn ein Buchstabe erscheint, wo eine
  Ziffer erwartet wird, ist das nächste Zeichen immer noch der (störende)
  Buchstabe.

* Soll (mindestens) dieses Zeichen übersprungen werden, so muss

  * **Zuerst** der Stream in den "good"-Zustand versetzt werden, und

  * **erst danach** kann eine Operation (wie z.B. `ignore` zum Überspringen
    von Zeichen) ihre Wirkung entfalten.

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Streams State-Bits
name: iostream_statebits
header: #### Exceptions bei Zustandswechsel

Wahlweise kann das Verhalten eines Streams so eingestellt werden, dass

* bei jedem Zustandswechsel und
* allen (versuchten) Operationen außerhalb des *good*-Zustands

eine Exception geworfen wird:
```
// Excerpt from a hypothetical "forever running" TCP-Client
std::ifstream from_server;
… // somehow establish connection through TCP/IP-Socket
from_server.exceptions(std::ios::badbit
                     | std::ios::eofbit
                     | std::ios::failbit);
try {
    for (;;) {
        std::string command_string;
        std::getline(from_server, command_string);
        … // process command_string
    } /*notreached*/
}
catch (std::ios_base::failure &e) {
    … // socket connection closed and/or data transfer failed
}
```

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>


