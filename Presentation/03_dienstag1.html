<!DOCTYPE html>
<html>
  <head>
    <title>C++-For (3) - Dienstag Teil 1</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
    <!-- when changing the stylesheet, please also change EACH 'styling-by:' -->
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies aproximately 2/3 of the page width. So only add
  little information, preferrably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open - add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++ FOR]: 00_inhalt.html#agenda

# [C++ FOR] (Dienstagvormittag)

-------------------------------------------------------------------

1. [Beziehungen zwischen Klassen	](#classes_and_relations)
1. [Unterstützung der Mehrfachvererbung	](#multiple_inheritance)
1. [Überlappende Basisklassen		](#diamond_inheritance)
1. [Beispiel mit Variationen		](#example_relations)
1. [Übung				](#exercise_tue1)

-------------------------------------------------------------------

Kürzere Pausen werden jeweils nach Bedarf eingelegt.

Die Besprechung der Musterlösung(en) erfolgt im direkten Anschluss an die
Mittagspause.

Eine druckbare Gesamtversion dieser Datei (PDF) steht unter dem selben
(Link-) Namen mit Suffix `.pdf` statt `.html` zur Verfügung.

---
template: linkinfo
graphic: UML-ClassesAndRelations
name: classes_and_relations
header: ## Beziehungen zwischen Klassen

---------------------------------------------------------------------

* [Klasse (minimal)			](#class_minimal)
* [Klasse (detailiert)			](#class_detailed)
* [Instanziiertes Objekt		](#class_instantiated)
* [Parametrisierte Klasse		](#class_template)

----------------------------------------------------------------------

* [Assoziation				](#association)
* [Komposition				](#composition)
* [Aggregation				](#aggregation)

----------------------------------------------------------------------

* [(Mehrfach-)](#multi_based) [Vererbung](#inheritance)
* [Interface				](#interfaces)
* [Abstrakte Basisklasse		](#abstract_base)

----------------------------------------------------------------------

* ["Rautenförmige" und ...		](#diamond_shaped_inheritance)
* [... allgemein mehrstufige
   Vererbungs-Hierarchien		](#broader_deeper_inheritance)

----------------------------------------------------------------------

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Some Class
name: class_minimal
header: ### Klasse (minimal)

Die minmale Darstellung einer Klasse in der [UML] besteht aus einem Rechteck,
in welchem der Klassenname steht.

.N[
Klassen und Beziehungen zwischen Klassen sind die wichtigsten Bestandeteile einer
*Objekt-Orientierten-Modellierung*.
]

Häufig wird eine solche etwa

* beginnen mit einem High-Level-Design ([HLD])
* das u.U. eine Reihe von Verfeinerungsschritten durchläuft
* ...
* und schließlich enden mit einer Lösungs-Implementierung.._[]

.F[:
Auch im Kern sehr formale Prozesse wie etwa [RUP] beinhalten dabei die
Möglichkeit eines "Tailoring", indem nur diejenigen Artefakte tatsächlich
erstellt werden, von denen man sich einen konkreten Nutzen verspricht.
]

  [RUP]: http://en.wikipedia.org/wiki/IBM_Rational_Unified_Process

---
template: plain
header: Objektorientierte Vorgehensweise

Die übliche Abfolge der Schritte ist

* zunächst eine Objektorientierte (Problem-) Analyse (OOA) vorzunehmen,
* der ein mehr oder weniger detailliertes Objekt-Orientiertes (Lösungs-) Design (OOD) folgt.

Die beiden Begriffe *OOA* und *OOD* werden mitunter auch zusammengefasst zu [OOAD]
(Objektorientierte Analyse und Design).

  [UML]:  http://de.wikipedia.org/wiki/Unified_Modeling_Language
  [HLD]:  http://www.the-software-experts.de/e_dta-sw-design-high-level.htm
  [OOM]:  http://www.techopedia.com/definition/28584/object-oriented-modeling-oom
  [OOAD]: http://de.wikipedia.org/wiki/Objektorientierte_Analyse_und_Design

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Instantiated Objects
name: class_instantiated
header: #### Klassen vs. Objekte

Hierfür dient in der UML im wesentlichen die selbe Symbolik - der Unterschied besteht
lediglich darin, dass
* bei Objekten der Name unterstrichen ist und
* der Klassenname auch entfallen kann._[]

##### Klassen
Dies kommen einem **Bauplan** gleich und enthalten in der UML-Darstellung alles, was
die Objekten gemeinsam haben, die gemäß diesem Bauplan erstellt werden.

##### Objekte
Diese sind *instanzierte Klassen* und drücken in der UML-Darstellung damit die
**Unterschiede** aus, welche trotz des gemeinsamen Bauplans bestehen.

.F[:
Die tatsächlichen Regeln der grafischen Darstellung sind komplizierter und erlauben
prinzipiell, dass ein dem Namen des Objekts ein Doppelpunkt und dann der Klassenname
folgt, wobei beide Namen optional sind und weggelassen werden können (beispielsweise
wenn sie sich aus dem Kontext ergeben), womit die minimale Beschrftung eines Objekts
aus einem unterstrichenen Doppelpunkt besteht.
]

---
template: plain
header: #### Klassen und Objekte in C++

Als kompilierte Sprache gibt es in C++ einen weiteren, charakteristischen Unterschied
zwischen Klassen und Objekten:

.I[
Klassen sind hier **statisch** in dem Sinne, dass sie
* vollständig zur Compilezeit beschrieben werden, während
* Objekte sich typischerweise zur Laufzeit verändern.
]

---
template: plain
header: #### C++-Klassen als Compilezeit-Konstrukt

Die vollständige Festlegung einer Klasse zur Compilezeit ist ein wesentlicher Unterschied
zu deutlich dynamischeren OOP-Sprachen, wie
etwa

* [Smalltalk] oder
* [Python]

wo **nicht zwingend** Member-Daten und -Funktionen auch noch zur Laufzeit
hinzugefügt oder entfernt werden können.._[]

.F[:
[Java] und [C#][C Sharp] sind in dieser Hinsicht wiederum eher ähnlich zu C++,
besitzen allerdings mehr standardisierte Möglichkeiten zur Introspektion und
können mit Hilfe kleiner Kunstgriffe den Eindruck eines zur Laufzeit dynamisches
Verhalten bieten.
]

  [Smalltalk]: http://www.smalltalk.org/smalltalk/whatissmalltalk.html
  [Python]:    http://www.python.org/
  [Java]:      https://www.java.com/en/download/whatis_java.jsp
  [C Sharp]:   http://www.techopedia.com/definition/26272/c-sharp


---
template: withinfo
graphic: UML-ClassesAndRelations
section: Class With Some Details
name: class_detailed
header: ### Klasse (detailiert)

In stärkerer Detaillierung beschrieben kann einer Klasse im UML-Diagramm folgendes
hinzugefügt werden:

* Ein Abschnitt mit Attributen
* Ein Abschnitt mit Methoden

Beides wird innerhalb des Klassensymbols durch eine waagrechte Linie getrennt und
beides ist optional.

.N[
Pragmatiker weisen gerne darauf hin, dass die UML **keineswegs** die Nutzung aller
ihrer notationellen Möglichkeiten vorschreibt sondern der Detaillierungsgrad eines
Klassendiagramm stets an dessen Zweck bzw. dem Zielpublikum ausgerichtet sein sollte!
]

---
template: plain
header: #### Attribute

Diese enthalten *Datenwerte* und sind im UML-Diagramm daran zu erkennen, dass ihnen
**keine** runden Klammern folgen. Ein nachgestellter Datentyp ist dabei optional.

.I[
In C++ ist hierfür auch die Bezeichnung *Member-Daten* üblich.
]

---
template: plain
header: #### Methoden

Diese enthalten *ausführbare Abläufe* und sind im UML-Diagramm daran zu erkennen, dass
ihnen **runde Klammern folgen**, evtl. auch leere.

.I[
In C++ ist hierfür auch die Bezeichnung *Member-Funktionen* üblich.
]

Innerhalb der Klammern können optional zu übergebende Parameter benannt werden, inklusive
deren Typ (durch Doppelpunkt getrennt), und den Klammern folgen kann (ebenfalls durch
einen Doppelpunkt getrennt) der Rückgabetyp.

---
template: plain
header: #### Zugriffsrechte

Ein weiteres, in der detaillierten Darstellung von UML-Klassen mögliches Notationselement
bezieht sich auf die Zugriffsrechte und kann sowohl Member-Daten wie auch Member-Funktionen
optional vorangestellt werden:

* `+` (öffentlich) - jeder, der Zugriff zu einem Objekt dieser Klasse hat, kann auf das 
Attributs zugreifen oder die Methode ausführen;
* `#` (geschützt) - erreichbar nur für abgeleitete Klassen;
* `-` (privat) - erreichbar nur in den eigenen Member.

---
template: plain
header: #### Klassenattribute und -methode

In der detaillierten Darstellung einer UML-Klasse unterstrichene Bezeichner stellen
sog. Klassen-Member dar und entsprechen in der C++-Programmierung den Zusatz `static`.

##### Klassenattribute
Diese sind **nicht** pro Objekt sondern pro Klasse gespeichert._[]

##### Klassenmethoden
Diese können ausschließlich auf Klassenattribute zugreifen. Sie bieten in C++ zum
einen eine kleine Effinzienzverbesserung, da bei ihrem Aufruf keine Objektadresse 
übergeben werden muss, und sind zum anderen auch ohne Bezug auf ein bestimmtes
Objekt unter Voranstellen des Klassenamens gefolgt vom Scope-Operator (`::`)
aufrufbar.

.F[
Eine typische Anwendung wäre z.B. eine fortlaufende Nummerierung aller jemals erzeugten
Objekte einer bestimmten Klasse, wobei das Klassenattribut die nächste zu vergebende
Nummer enthalten könnte.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Template Class
name: class_template
header: ### Parametrisierte Klasse

Hierbei handelt es sich um die UML-Sichtweise auf das, was in C++ mit dem Mechanismus
der Templates verfügbar ist und auch die Bezeichnung *generische Programmierung* trägt.

.N[
Ursprünglich verdankt diese ihre Entstehung dem Wunsch, Datentypen und
Compilezeit-Konstanten wie etwa die Anzahl der Elemente in einem Array
parametrisieren zu können.
]


---
template: withinfo
graphic: UML-ClassesAndRelations
section: Association
name: association
header: ### Assoziation

Eine Assoziation ist die unspezifischste aller Beziehungen, die zwischen zwei
Klassen bestehen können und besagt mehr oder weniger nur, dass diese beiden
Klassen eine bestimmte Aufgabe **gemeinsam** erledigen.

Die tatsächliche Beziehung kann stärker sein und auch eine der anderen
Beziehungsformen annehmen, insbesondere die der

* [Aggregation](#aggregation) oder
* [Komposition](#composition).

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Association
name: undirected_association
header: #### Ungerichtete Assoziation in C++

Streng genommen bedeutet die allgemeine Assoziation in C++, dass die beiden
Klassen gegenseitig aufeinander verweisen, was z.B. in Form zweier Pointer
geschehen könnte.

.I[
Programmiertechnisch lässt sich nur einer dieser beiden Pointer durch eine Referenz
ersetzen, denn bei zwei Referenzen ist die (wechselseitige) Initialisierung nicht
realisierbar.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Association
name: directed_association
header: #### Gerichtete Assoziation

Durch hinzufügen eines Pfeils an der Assoziationslinie lässt sich zum Ausdruck
bringen, welche Klasse die andere erreichen kann und welche nur erreichbar ist.

.I[
Für die programmiertechnischen Umsetzung kommt damit klar zum Ausdruck, welche
Klasse in der Lage sein muss, die jweils andere - z.B. per Zeiger oder Referenz
- zu erreichen.._[]
]

Ein (bereits existierendes) Objekt erreichbare Klasse kann dann beispielsweise
im Konstruktor bei der Erzeugung eines Objekts der anderen Klasse als Argument
übergeben und zur Initialisierung eines entsprechenden (Daten-) Members verwendet
werden.

.F[:
Die direkte Einbettung der erreichbaren Klasse als Member-Datum entspräche der
jedoch der [Komposition](#composition).
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Composition
name: composition
header: ### Komposition

Die Komposition ist eine stärkere aber häufig auftretende Form der Aggregation,
bei der das Teil in seiner Lebenszeit an die Gesamtheit gebunden ist.

.N[
In der UML-Darstellung wird an die (Assoziations-) Linie zwischen den beiden
beteiligten Klassen auf der Seite der Gesamtheit eine *ausgefüllte* Raute
hinzugefügt.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Aggregation
name: aggregation
header: ### Aggregation

Die Komposition ist eine geringfügig stärkere Form der Assoziation, indem
sie 

* die Klasse auf einer Seite zur *Gesamtheit* (Aggregat)
* die Klasse auf anderen zu *deren Teil* erklärt.

Allerdings können Gesamtheit und Teil unabhängig voneiander existieren.

.N[
In der UML-Darstellung wird an die (Assoziations-) Linie zwischen den beiden
beteiligten Klassen auf der Seite der Gesamtheit eine *nicht-ausgefüllte* Raute
hinzugefügt..[]
]

.F[:
Aus pragmatischer Sicht ist darauf hnizuweisen, dass Aggregation und Assoziation häufig
eng beieinander liegen und mitunter sogar "Ansichtssache" sind, womit sich ein längeres
Nachdenken oder gar eine kontroverse Diskussion darüber, welche Art der Beziehung denn
nun per UML darzustellen ist, nicht lohnt.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Inheritance
name: inheritance
header: ### Vererbung

Hierbei geht es um die Beziehung zwischen einem

* allgemeinen Konzept und
* dessen Spezialisierung.

.N[
In der UML-Darstellung wird an die (Assoziations-) Linie zwischen den beiden
beteiligten Klassen auf der Seite der Basisklasse ein nicht ausgefülltes Dreieck
hinzugefügt..[]
]

Das Speicher-Layout und auch die Lebenszeit-Kopplung entsprechen zwar dem der Komposition,
als wichtige besonderheit gilt jedoch das [LSP].

.I[
Das Liskovsche Substitutions-Prinzip ist sehr eng mit dem Gedanken der Objektorientierung
verknüft und besagt, dass ein Objekt einer abgeleiteten Klasse (Spezialisierung) stets
ein passender Stellvertreter für ein Objekt seiner Basisklasse sein kann.
]

  [LSP]: http://de.wikipedia.org/wiki/Liskovsches_Substitutionsprinzip

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Multiple Inheritance
name: multiple_bases
header: ### Mehrfachvererbung

Diese liegt vor, wenn eine Klasse zwei Basisklassen hat, also zwei allgemeine Konzepte
spezialisiert.

.N[
In der Geschichte der Objektorientierung gab es zahlreiche Diskussionen über Sinn und
Zweck der Mehrfachvererbung und in der Tat verzichtet eine Reihe von OOP-Sprachen mit
großer Verbreitung - etwa Java - völlig darauf.._[]
]

.F[:
Was Java allerdings unterstützt sind Klassen, die mehrere [Interfaces](#interface)
implementieren.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Interface
name: interface
header: ### Interface (Schnittstelle)

Bei einem Interface geht es prinzipiell um eine Art Vertrag zwischen zwei Klassen:

* Es gibt einerseits eine (oder mehrere) Klasse(n), die ein bestimmtes Interface implementieren und
* für (in der Regel mehrere) andere Klassen ist damit klar, wie das "Angebot" an Member-Funktionen aussieht.

.N[
In der UML-Notation steht über dem Namen eines Interfaces das [Stereotype] «interface».
]

  [Stereotype]: http://en.wikipedia.org/wiki/Stereotype_(UML)

---
template: plain
header: #### Anwendung von Interfaces

Generell reduzieren Interfaces die Kopplung, d.h. den Grad zu dem verschiedene
Klassen Details voneinander kennen (müssen).

Zudem bieten sie Flexibilität zur Laufzeit, indem von mehreren verfügbaren Implemetierungen
die für eine Situation passende gewählt werden kann.

Interfaces haben wor allem auch durch die [objektorientierten Entwurfsmustern][OO-DP],
die auch zentrales Thema des [GoF-Buch][GoF] sind, eine große Bekanntheit erlangten.

  [DP]:         http://en.wikipedia.org/wiki/Software_design_pattern
  [GoF]:        http://en.wikipedia.org/wiki/Design_Patterns_(book)

---
template: plain
header: #### Interfaces vs. Klassen

Technisch gesehen sind Interfaces in C++ in einer bestimmten Form eingeschränkte
Klassen:

* Sie besitzen **keine Member-Daten** und
* **ausschließlich rein virtuellen Member-Funktionen**.

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Abstract Base
name: abstract_base
header: ### Abstrakte Basisklasse

Die Bezeichnung "abstrakt" wird für Klassen verwendet, die **mindestens eine rein
virtuelle Member-Funktion** haben.

.N[
In der UML-Darstellung wird der Name einer abstrakten Klasse kursiv geschrieben.
]

Abstrakte Klassen können nur als Basisklassen verwendet werden. Die abgeleitete
Klasse wird dann typischerweise die rein virtuellen Member-Funktionen implementieren.

.W[
Der Versuch, Objekte einer abstrakten Klasse zu erzeugen scheitert in C++ mit einem
Kompilierfehler.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: "Diamond Shaped" Inheritance Graph
name: diamond_shaped_inheritance
header: ### "Rautenförmige" Vererbungsstruktur

Eine solche entsteht, wenn sich bei Mehrfachvererbung auf der mittleren Ebene
Klassen befinden, die wiederum eine gemeinsame Basisklasse besitzen.

Es ist bezüglich der gemeinsamen Basisklasse dann in der UML-Darstellung eine
Unterscheidung zwischen zwei Fällen erforderlichs, welche jeweils die
Daten-Member der (gemeinsamen) Basisklasse betreffen:

* «overlapping» - die Daten-Member sind nur einmal vorhanden
* «disjoint» - die Daten-Member sind doppelt vorhanden

.W[
Im zweiten Fall ist in Bezug auf die ganz oben stehende Basisklasse von der ganz unten
stehenden Klasse aus gesehen das LSP außer Kraft gesetzt, da keine Eindeutigkeit mehr
gegeben ist.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Broad(er) and Deep(er) Inheritance Graph
name: broader_deeper_inheritance
header: Mehrstufige Vererbung allgemein gesehen

Im allgemeinen gehen Vererbungs-Hierarchien auch
* *mehr in die Breite*, d.h. eine Basisklasse wird oft viele (direkt) abgeleitete
Klassen haben, sowie
* *mehr in die Tiefe*, d.h. es gibt mehrere Stufen (also sieht man die direkt abgeleiteten
Klassen als "Kinder", wird es also auch "Enkel", "Ur-Enkel" usw. geben.

.I[
Ausgenommen rautenförmigen Hierarchien mit gemeinsamen «disjoint» Basisklassen gilt das LSP
automatisch über alle Stufen einer in die Tiefe gehenden Vererbungshierarchie.
]

---
template: linkinfo
graphic: MultipleInheritance
name: multiple_inheritance
header: ## Mehrfachvererbung und virtuelle Basisklassen

---------------------------------------------------------------------

* [Prinzip der Mehrfachvererbung	](#mi_principle)
* [Virtuelle Basisklassen		](#virtual_bases)

----------------------------------------------------------------------

* [Überlappende Basisklassen		](#overlapping_bases)

----------------------------------------------------------------------

---
template: withinfo
graphic: MultipleInheritance
section: Multiple Inheritance
name: mi_principle
header: ### Prinzip der Mehrfachvererbung

Bei der Mehrfachvererbung kann im Speicherlayout nur noch eine der Basisklassen
eine gemeinsame Anfangsadresse mit der abgeleiteten Klasse haben.

.N[
Dies stellt keine große technische Herausforderung dar sondern bedeutet lediglich
eine minimale Komplikation bei der Umsetzung des LSP, wo im Fall der Weiterreichung
der abgeeitete Klasse ggf. ein Offset zum `this`-Zeiger hinzugerechnet werden muss.
]

---
template: withinfo
graphic: MultipleInheritance
section: Virtual Base Class
name: virtual_bases
header: ### Virtuelle Basisklassen

Virtuelle Basisklassen bilden in C++ den Hintergrund der Lösung dessen, was die UML
bei rautenförmigen Vererbungshierarchien im Fall von «overlapping»»-Klassen an der
Spitze verlangt.

.N[
Den Overhead für diese Lösung haben die Klassen auf der mittleren Ebene zu tragen,
indem sie nicht nur den Datenteil ihrer (virtuellen) Basisklasse enthalten sondern
einen zusätzlichen Zeiger, über den **alle Bezugnahmen auf den Basisklassenteil**
erfolgen.
]

---
template: withinfo
graphic: MultipleInheritance
section: Overlapping Common Base Class
name: overlapping_bases
header: ### Überlappende Basisklassen

Im konkreten Fall einer rautenförmigen Hierarchie wird nun

* die Daten-Member der Basisklasse nur ein einziges Mal in der "Most Derived Class"
vorhanden sein, und
* die Zeiger in den Klassen der mittleren Ebene werden **beide** genau auf diesen
Daten-Member verweisen.

Da alle Bezugnahmen darauf - wie gerade beschrieben - über diese Zeiger laufen, werden
die Klassen der mittleren Ebene also mit **ein und demselben** Basisklassen-Objekt
arbeiten.

---
template: linkinfo
graphic: DiamondShapedInheritance
name: diamond_shapes
header: ## Rautenförmige Ableitungshierarchien

------------------------------------------------------------------------

* [UML-Darstellung «overlapping» ...		](#overlapping_uml)
* [... versus «disjoint»			](#disjoint_uml)

------------------------------------------------------------------------

* [Abbildung auf Speicher «overlapping» ...	](#overlapping_memory)
* [... versus «disjoint»			](#disjoint_memory)

------------------------------------------------------------------------

* [Konstruktor / Destruktor «overlapping» ...	](#overlapping_ctordtor)
* [... versus «disjoint»			](#disjoint_ctordtor)

------------------------------------------------------------------------

---
template: withinfo
graphic: DiamondShapedInheritance
section: UML Class Graph («overlapping»)
name: overlapping_uml
header: ### UML-Darstellung «overlapping»

Die zusammengefasste Darstellung des Falls «overlaping» in Bezug auf

* die UML-Darstellung,
* das Speicherlayouts und
* die Typumwandlungen im Rahmen des LSP

erlaubt den drekten Vergleich zum Fall «disjoint».

---
template: withinfo
graphic: DiamondShapedInheritance
section: UML Class Graph («disjoint»)
name: disjoint_uml
header: ### UML-Darstellung «disjoint»

Die zusammengefasste Darstellung des Falls «disjoint» in Bezug auf

* die UML-Darstellung,
* das Speicherlayouts und
* die Typumwandlungen im Rahmen des LSP

erlaubt den drekten Vergleich zum Fall «overlapping».

---
template: withinfo
graphic: DiamondShapedInheritance
section: Class to Memory Mapping («overlapping»)
name: overlapping_implementation
header: ### Abbildung auf Speicher «overlapping»

Die zusammengefasste Darstellung des Falls «overlapping» in Bezug auf

* den Quelltext,
* den konstruktor sowie
* den Destruktor-Ablauf

erlaubt den drekten Vergleich zum Fall «disjoint».

---
template: withinfo
graphic: DiamondShapedInheritance
section: Class to Memory Mapping («overlapping»)
name: disjoint_implementation
header: ### Abbildung auf Speicher «disjoint»

Die zusammengefasste Darstellung des Falls «disjoint» in Bezug auf

* den Quelltext,
* den konstruktor sowie
* den Destruktor-Ablauf

erlaubt den drekten Vergleich zum Fall «overlapping».

---
template: linkinfo
graphic: Example-ClassDesign
name: example_relations
header: ## Beispiele zu Klassenbeziehungen

-------------------------------------------------------------------------------

* [Eine anpassbare Komponente ...		](#an_adaptable_component)
* [... und deren Nutzung 			](#using_existing_component)

-------------------------------------------------------------------------------

* [Rautenförmige (Mehrfach-) Vererbung		](#with_multiple_inheritance)

-------------------------------------------------------------------------------

* [Drei Interfaces				](#with_three_interface)

-------------------------------------------------------------------------------

* [Flexible Erweiterbarkeit durch "Mix-Ins"	](#with_extensibilty)

-------------------------------------------------------------------------------

* [Orientiert am GoF "Observer" Muster		](#with_elaboration)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: Example-ClassDesign
section: Reusable Component
name: with_existing_component
header: ### Eine (anpassbare) Komponente

Anpassbare Komponenten entstehen normalerweise entweder

* durch Planung, wenn zukünftige Variabilität (korrekt) vorhergesehen wurde, oder
* durch Erfahrung, zu einer bereits bestehende Funktionalität eine (im ersten Entwurf) noch nicht eingeplante) neue Variante benötigt wird.

---
template: withinfo
graphic: Example-ClassDesign
section: Reusable Adapted Component
name: with_existing_component
header: ### Nutzung der (angepassten) Komponente

Die Nutzung einer (angepassten) Komponente reduziert den Aufwand an immer wieder
neu zu schreibendem Code.

---
template: withinfo
graphic: Example-ClassDesign
section: Diamond-Shapend Inheritance
name: with_multiple_inheritance
header: ### Rautenförmige (Mehrfach-) Vererbung

Über den "Preis", der für die dann oft notwendigen , virtuellen Basisklassen zu zahlen
ist, lassen sich ggf. flexible Kombinationsmöglichkeiten mit einem guten Grad an
Wiederverwendung erreichen.

---
template: withinfo
graphic: Example-ClassDesign
section: Three Interfaces
name: with_three_interface
header: ### Drei Interfaces

Die Nutzung von Interfaces kann die Komplexität der Gesamt-Architektur aus der
"Sicht einzelner Klienten" etwas vereinfachen.

---
template: withinfo
graphic: Example-ClassDesign
section: Improved Reuse with Mixin Classes
name: with_extensibilty
header: ### Inkrementale Erweiterbarkeit durch Mix-Ins

Über Mixin-Klassen lässt sich ggf. flexible Kombinierbarkeit schaffen auch ohne
das virtuelle Basisklassen notwendig werden.

---
template: withinfo
graphic: Example-ClassDesign
section: Close to GoF "Observer" Pattern
name: with_elaboration
header: ### Orientiert am GoF "Observer" Muster

Das "Flaggschiff" unter allen hier verglichenen Entwürfen.

Es vereint hohe Flexibilität und geringe Kopplung ... erfordert allerdings auch
etwas tiefere Beschäftigung damit, um es endgültig zu verstehen.

---
template: plain
name: exercise_tue1
header: ## Übung

Ziel der Aufgabe:

Analyse und Bewertungen diverser Varianten eines Beispiels, in dem eine Reihe
unterschiedlicher Klassenbeziehungen verwendet werden.

.N[
Weitere Details werden vom Dozenten anhand des Aufgabenblatts sowie der
vorbereiteten Eclipse-Projekte erläutert.
]

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>


