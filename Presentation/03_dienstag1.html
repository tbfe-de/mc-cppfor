<!DOCTYPE html>
<html>
  <head>
    <title>C++-For (3) - Dienstag Teil 1</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
    <!-- when changing the stylesheet, please also change EACH 'styling-by:' -->
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies aproximately 2/3 of the page width. So only add
  little information, preferrably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open - add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++ FOR]: 00_inhalt.html#agenda

# [C++ FOR] (Dienstagvormittag)

-------------------------------------------------------------------

1. [Beziehungen zwischen Klassen	](#classes_and_relations)
1. [Unterstützung der Mehrfachvererbung	](#multiple_inheritance)
1. [Überlappende Basisklassen		](#diamond_inheritance)
1. [Beispiele zu Klassenbeziehungen	](#example_relations)
1. [Übung				](#exercise_tue1)

-------------------------------------------------------------------

Kürzere Pausen werden jeweils nach Bedarf eingelegt.

Die Besprechung der Musterlösung(en) erfolgt im direkten Anschluss an die
Mittagspause.

---
template: linkinfo
graphic: UML-ClassesAndRelations
name: classes_and_relations
header: ## Beziehungen zwischen Klassen

---------------------------------------------------------------------

* [Klasse (minimal)			](#class_minimal)
* [Klasse (detailiert)			](#class_detailed)
* [Instanziiertes Objekt		](#class_instantiated)
* [Parametrisierte Klasse		](#class_template)

----------------------------------------------------------------------

* [Assoziation				](#association)
* [Komposition				](#composition)
* [Aggregation				](#aggregation)

----------------------------------------------------------------------

* [(Mehrfach-)](#multi_based) [Vererbung](#inheritance)
* [Interface				](#interfaces)
* [Abstrakte Basisklasse		](#abstract_base)

----------------------------------------------------------------------

* ["Rautenförmige" und ...		](#diamond_shaped_inheritance)
* [... allgemein mehrstufige
   Vererbungs-Hierarchien		](#broader_deeper_inheritance)

----------------------------------------------------------------------

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Some Class
name: class_minimal
header: ### Klasse (minimal)

[UML]: http://de.wikipedia.org/wiki/Unified_Modeling_Language
[RUP]: http://en.wikipedia.org/wiki/IBM_Rational_Unified_Process
[OOM]: http://www.techopedia.com/definition/28584/object-oriented-modeling-oom

Die minmale Darstellung einer Klasse in der [UML] besteht aus einem Rechteck,
in welchem der Klassenname steht.

.N[
Klassen und Beziehungen zwischen Klassen sind die wichtigsten Bestandeteile
einer *Objekt-Orientierten-Modellierung* ([OOM]).
]

Häufig wird eine solche etwa

* beginnen mit einem High-Level-Design (HLD),

* das eine Reihe von Verfeinerungsschritten durchläuft,

* ...

* und schließlich enden mit einer Lösungs-Implementierung.._[]

.F[:
Auch im Kern sehr formale Prozesse wie etwa [RUP] beinhalten dabei die
Möglichkeit eines "Tailoring", indem nur diejenigen Artefakte tatsächlich
erstellt werden, von denen man sich einen konkreten Nutzen verspricht.
]

---
template: plain
header: #### Objektorientierte Vorgehensweise

[OOAD]: http://de.wikipedia.org/wiki/Objektorientierte_Analyse_und_Design

Die übliche Abfolge der Schritte ist

* zunächst eine Objektorientierte (Problem-) Analyse (OOA) vorzunehmen,

* der ein mehr oder weniger detailliertes Objekt-Orientiertes (Lösungs-) Design
  (OOD) folgt,

* welches schließlich – vorzugsweise den Mitteln der Objekt-Orientierten
  Programmierung (OOP) implementiert wird.

Die beiden Begriffe *OOA* und *OOD* werden mitunter auch zusammengefasst zu
*[OOAD]* (Objektorientierte Analyse und Design), oder unter Hinzuziehung der
Programmierung zu *OOADP*.

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Instantiated Objects
name: class_instantiated
header: #### Klassen vs. Objekte

Hierfür benutzt die UML im Wesentlichen die selbe Symbolik – der Unterschied
besteht lediglich darin, dass

* bei Objekten der Name unterstrichen ist und
* der Klassenname auch entfallen kann.._[]

##### Klassen
Diese kommen einem *Bauplan* gleich und beschreiben in der UML-Darstellung alle
*Gemeinsamkeiten* der Objekte, die gemäß diesem Bauplan erstellt werden.

##### Objekte
Diese sind *instanzierte Klassen* und beinhalten in der UML-Darstellung die
*Unterschiede* aus, welche trotz des gemeinsamen Bauplans bestehen.

.F[:
Die tatsächlichen Regeln der grafischen Darstellung sind komplizierter und
erlauben prinzipiell, dass ein dem Namen des Objekts ein Doppelpunkt und dann
der Klassenname folgt, wobei beide Namen optional sind und weggelassen werden
können (beispielsweise wenn sie sich aus dem Kontext ergeben).
]

---
template: plain
header: #### Klassen und Objekte in C++

In kompilierten Sprachem, d.h. wenn die Unterstützung der Objektorientierten
Programmierung, quasi einen Interpreter für ein Objekt-System zur Laufzeit
anzubieten, gibt es in der Regel einen weiteren, charakteristischen Unterschied
zwischen Klassen und Objekten:

.I[
Klassen sind in C++ **statisch** in dem Sinne, dass sie

* vollständig zur Compilezeit beschrieben werden, während
* Objekte sich typischerweise zur Laufzeit verändern.
]

---
template: plain
header: #### C++-Klassen als Compilezeit-Konstrukt

[ITcl]:      http://incrtcl.sourceforge.net/itcl/
[Smalltalk]: http://www.smalltalk.org/smalltalk/whatissmalltalk.html
[Python]:    http://www.python.org/
[Java]:      https://www.java.com/en/download/whatis_java.jsp
[C Sharp]:   http://www.techopedia.com/definition/26272/c-sharp

Die vollständige Festlegung einer Klasse zur Compilezeit ist ein wesentlicher
Unterschied zu deutlich dynamischeren OOP-Sprachen, wie
etwa

* [Smalltalk]

* [Python] oder

* [ITcl]

deren Klassen und Objekte - auch und gerade hinsichtlich ihrer Member-Daten und
-Funktionen zur Laufzeit völlig dynamisch erzeugt werden können, und somit z.B.
auch datenabhängig erstellt werden können.._[]

.F[:
[Java] und C# [C Sharp] sind in dieser Hinsicht wiederum eher ähnlich zu C++,
besitzen allerdings mehr standardisierte Möglichkeiten zur Introspektion und
können mit Hilfe kleiner Kunstgriffe in großen Teilen den Eindruck eines zur
Laufzeit dynamischen Verhaltens bieten.
]


---
template: withinfo
graphic: UML-ClassesAndRelations
section: Class With Some Details
name: class_detailed
header: ### Klasse (detailiert)

In stärkerer Detaillierung beschrieben kann einer Klasse im UML-Diagramm
folgendes hinzugefügt werden:

* Ein Abschnitt mit Attributen

* Ein Abschnitt mit Methoden

Beides wird innerhalb des Klassensymbols durch eine waagrechte Linie getrennt und
beides ist optional.

.N[
Pragmatiker weisen gerne darauf hin, dass die UML **keineswegs** die Nutzung
aller ihrer notationellen Möglichkeiten vorschreibt sondern der
Detaillierungsgrad eines Klassendiagramm stets an dessen Zweck bzw. dem
Zielpublikum entsprechend ausgerichtet sein sollte.
]

---
template: plain
header: #### Attribute

Diese enthalten *Datenwerte* und sind im UML-Diagramm daran zu erkennen, dass
ihnen **keine** runden Klammern folgen. Ein nachgestellter, durch einen
Doppelpunkt abgetrennter Datentyp ist dabei optional.

.I[
In C++ ist hierfür eher die Bezeichnung *Member-Daten* üblich.
]

---
template: plain
header: #### Methoden

Diese enthalten *ausführbare Abläufe* und sind im UML-Diagramm daran zu
erkennen, dass ihnen **runde Klammern folgen**, ggf. auch leere.

.I[
In C++ ist hierfür eher die Bezeichnung *Member-Funktionen* üblich.
]

Innerhalb der Klammern können optional zu übergebende Parameter benannt werden,
inklusive deren Typ (nachgestellt und durch Doppelpunkt getrennt), und der
geklammerten Parameterliste kann (ebenfalls durch einen Doppelpunkt getrennt)
ein Rückgabetyp folgen.

---
template: plain
header: #### Zugriffsschutz

Ein weiteres, in der detaillierten Darstellung von UML-Klassen mögliches
Notationselement bezieht sich auf den Zugriffsschutz und kann sowohl
Member-Daten wie auch Member-Funktionen optional vorangestellt werden:

* `+` (öffentlich) – `public` in C++

  * jeder, der Zugriff zu einem Objekt dieser Klasse hat, kann auf diese
    Member-Daten zugreifen bzw. diese Member-Funktionen ausführen.

* `#` (geschützt) – `protected` in C++

  * erreichbar nur für die Member-Funktionen der eigenen und davon abgeleiteter
    Klassen.

* `-` (privat) – `private:` in C++

   * erreichbar nur für die Member-Funktionen der eigenen Klasse.

---
template: plain
header: #### C++ Zugriffschutz: `class` vs. `struct`

Eine Besonderheit gilt in C++ für den Default des Zugriffschutzes:

* In einer `struct` ist dieser `public`,
* in einer `class` dagegen `private`.

Abgesehen von diesem Unterschied sind die Schlüsselworte `struct` und `class`
bei der Definition einer Klasse austauschbar.

.pull-left[
```
class MyClass {
// starts private
    …
public:
    …
};

struct MyStruct {
// starts public
    …
private:
    …
};
```
]

.pull-right[
```
struct MyClass {
private:
    …
public:
    …
};

class MyStruct {
public:
    …
private:
    …
};
```
]

---
template: plain
header: #### Klassen-Attribute und -Methoden

In der detaillierten Darstellung einer UML-Klasse unterstrichene Bezeichner
stellen sog. Klassen-Attribute oder -Methoden dar und entsprechen in der
C++-Programmierung den Zusatz `static`.

##### Klassenattribute

Diese sind **nicht** pro Objekt sondern pro Klasse gespeichert.._[]

.F[:
Eine typische Anwendung wäre z.B. eine fortlaufende Nummerierung aller jemals
erzeugten Objekte einer Klasse, wobei ein Klassenattribut die nächste zu
vergebende Nummer enthält.
]

##### Klassenmethoden

Diese können ausschließlich auf Klassenattribute zugreifen. In C++

* bieten sie zum einen eine kleine Effinzienzverbesserung, da bei ihrem Aufruf
  keine Objektadresse übergeben werden muss, und

* sind zum anderen auch ohne ein vorhandenes Objekt durch Voranstellen des
  Klassenamens gefolgt vom Scope-Operator (`::`) aufrufbar.

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Template Class
name: class_template
header: ### Parametrisierte Klasse

[Generic Programming]: http://en.wikipedia.org/wiki/Generic_programming

Hierbei handelt es sich um die UML-Sichtweise auf das, was in C++ mit dem
Mechanismus der Templates verfügbar ist und auch die Bezeichnung *Generische
Programmierung* ([Generic Programming]) trägt.

.N[
Ursprünglich entsprang der Template-Mechanismus in C++ dem Wunsch, Datentypen
und Compilezeit-Konstanten – etwa Typ und Anzahl der Elemente in einem Array –
parametrisieren zu können, wenn dieses Member einer Klasse ist.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Association
name: association
header: ### Assoziation

Eine Assoziation ist die unspezifischste aller Beziehungen, die zwischen zwei
Klassen bestehen können, und besagt mehr oder weniger nur, dass diese beiden
Klassen eine bestimmte Aufgabe **gemeinsam** erledigen.

Die tatsächliche Beziehung kann stärker sein und auch eine der anderen
Beziehungsformen annehmen, insbesondere die der

* [Aggregation](#aggregation) oder

* [Komposition](#composition).

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Association
name: undirected_association
header: ### Ungerichtete Assoziation in C++

Streng genommen bedeutet die allgemeine Assoziation in C++, dass die beiden
Klassen gegenseitig aufeinander verweisen, was z.B. in Form zweier Pointer
realisiert sein könnte.

.I[
Programmiertechnisch lässt sich nur einer dieser beiden Pointer durch eine
Referenz ersetzen: bei zwei Referenzen ist die (wechselseitige) Initialisierung
nicht realisierbar.
]

#### Beispiel-Code zur ungerichteten Assoziation
.pull-left[
```
class Parent {
    class Child *c;
    …
    Parent() : c(nullptr) {}
    void setChild(Child *c_) {
        c = c_;
    }
};
…
Parent first;
```
]

.pull-right[
```
class Child {
    class Parent &p;
    …
    Child(Parent &p_)
        : p(p_) {
        p.setChild(this);
    }
};
…
Child second(first);
```
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Association
name: directed_association
header: ### Gerichtete Assoziation

Durch Hinzufügen eines Pfeils an der Assoziationslinie kann die "eingeschränkte
Navigierbarkeit" zum Ausdruck gebracht werden.

.I[
Für die programmiertechnische Umsetzung wird damit klar, welche Klasse die
jeweils andere – z.B. per Zeiger oder Referenz – erreichen können muss.._[]
]

#### Beispiel-Code zur gerichteten Assoziation
.pull-left[
```
class Parent {
    // CANNOT call its child
    // directly (but the child
    // could hand over this on
    // a call to the parent)
    …
};
…
Parent first;
```
]

.pull-right[
```
class Child {
    class Parent &p;
    …
    Child(Parent &p_)
        : p(p_)
    {}
};
…
Child second(first);
```
]

.F[:
Die direkte Einbettung der erreichbaren Klasse als Daten-Member entspräche
jedoch der [Komposition](#composition).
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Composition
name: composition
header: ### Komposition

Die Komposition ist eine stärkere, häufig Form der Aggregation, bei der das
Teil in seiner Lebenszeit an die Gesamtheit gebunden ist.

.N[
In der UML-Darstellung wird an die (Assoziations-) Linie zwischen den beiden
beteiligten Klassen auf der Seite der Gesamtheit eine *ausgefüllte* Raute
hinzugefügt.
]

#### Beispiel-Code zur Komposition
.pull-left[
```
class Car {
    class Motor someMotor;
    …
    Car( … )
        : someMotor( … )
    {}
};
…
Car someCar; // creates also
             // the (builtin)
             // motor
```
]

.pull-right[
```
class Motor {
    // will usually be created
    // as part of a car and
    // also scrapped with it
    …
};
```
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Aggregation
name: aggregation
header: ### Aggregation

Die Aggregation ist eine nur geringfügig stärkere Form der Assoziation, indem
sie 

* die Klasse auf einer Seite zur *Gesamtheit* (Aggregat)

* die Klasse auf anderen zu *deren Teil* erklärt.

Gesamtheit und Teil können dabei unabhängig voneinander existieren.

.N[
In der UML-Darstellung wird an die (Assoziations-) Linie zwischen den beiden
beteiligten Klassen auf der Seite der Gesamtheit eine *nicht-ausgefüllte* Raute
hinzugefügt.._[]
]

.F[:
Aus pragmatischer Sicht ist darauf hinzuweisen, dass Aggregation und Assoziation
häufig eng beieinander liegen und mitunter sogar "Ansichtssache" sind, womit
sich ein längeres Nachdenken oder gar eine kontroverse Diskussion darüber nicht
lohnt, welche Art von Beziehung per UML darzustellen ist.
]

---
template: plain
name: aggregation_example
header: #### Beispiel-Code zur Aggregation

.pull-left[
```
class Car {
    class Motor *m;
    …
    Car(Motor *m_ = nullptr)
        : m(m_)
    {}
    void setEngine(Motor *m_) {
        assert(m && !m_
           || !m && m_);
        m = m_;
    }
};

```
]

.pull-right[
```
class Motor {
    …
};
…
Motor firstMotors;
Motor otherMotor;
Motor unusedMotor;
```
]

Einige Autos (mit und ohne Motor):
```
Car soldCar(&firstMotor);        // a car with and ...
Car usedForCrashTest;            // ... without an engine
…
soldCar.setEngine(nullptr);      // remove old engine ...
soldCar.setEngine(otherMotor);   // ... for replacement
```


.F[:
Prefering pointers over references here is an arbitrary decision, but it looks
like an appropriate design if a car – durings its lifetime – may get an exchange
engine.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Inheritance
name: inheritance
header: ### Vererbung

[LSP]: http://en.wikipedia.org/wiki/Liskov_substitution_principle

Hierbei geht es um die Beziehung zwischen einem

* allgemeinen Konzept und

* dessen Spezialisierung.

.N[
In der UML-Darstellung wird an die (Assoziations-) Linie zwischen den beiden
beteiligten Klassen auf der Seite der Basisklasse ein nicht ausgefülltes Dreieck
hinzugefügt.
]

Speicher-Layout und Lebenszeit-Kopplung entsprechen zwar der Komposition, als
wichtige Besonderheit gilt jedoch das [LSP].

.I[
Das von Barbara Liskov formulierte Ersetzungs-Prinzip verlangt, dass ein Objekt
einer abgeleiteten Klasse (Spezialisierung) stets ein geeigneter Stellvertreter
für ein Objekt seiner Basisklasse sein sollte.._[]
]

.F[:
Any conventional compiler which only checks the existance of member functions
and their correct call with respect to argument and return types can guarantee
the LSP only to a very limited degree!
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Multiple Inheritance
name: multiple_bases
header: ### Mehrfachvererbung

Diese liegt vor, wenn eine Klasse zwei Basisklassen hat, also zwei allgemeine
Konzepte spezialisiert.

.N[
In der Geschichte der Objektorientierung gab es zahlreiche Diskussionen über
Sinn und Zweck der Mehrfachvererbung und eine Reihe bekannter OOP-Sprachen –
etwa Java – verzichtet auf Mehrfachvererbung.._[]
]

.F[:
Java unterstützt allerdings Klassen, die mehrere [Interfaces](#interface)
implementieren.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Interface
name: interface
header: ### Interface (Schnittstelle)

[Stereotype]: http://en.wikipedia.org/wiki/Stereotype_(UML)

Bei einem Interface geht es prinzipiell um eine Art Vertrag zwischen zwei
Klassen:

* Es gibt einerseits eine (oder mehrere) Klasse(n), die ein bestimmtes Interface
  implementieren und

* für (in der Regel mehrere) andere Klassen ist damit klar, wie deren Angebot an
  Member-Funktionen aussieht.

.N[
In der UML-Notation steht über dem Namen eines Interfaces das [Stereotype]
`«interface»`.
]

---
template: plain
header: #### Anwendung von Interfaces

[OO-DP]: http://en.wikipedia.org/wiki/Software_design_pattern
[GoF]:   http://en.wikipedia.org/wiki/Design_Patterns_(book)

Generell reduzieren Interfaces die Kopplung, d.h. den Grad zu dem verschiedene
Klassen Details voneinander kennen (müssen).

Zudem bieten sie Flexibilität zur Laufzeit, indem aus mehreren verfügbaren
Implemetierungen u.U. die für eine Situation am passende gewählt werden kann.

.N[
Interfaces haben vor allem durch *Objektorientierten Entwurfsmuster ([OO-DP])*
eine gewisse Bekanntheit erlangt und spielen auch im *[GoF]-Buch* eine wichtige
Rolle.
]

---
template: plain
header: #### Interfaces vs. Klassen

Technisch gesehen sind Interfaces in C++ in einer bestimmten Form eingeschränkte
Klassen:

* Sie besitzen **keine Member-Daten** und

* **ausschließlich rein virtuellen Member-Funktionen**.

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Abstract Base
name: abstract_base
header: ### Abstrakte Basisklasse

Die Bezeichnung *abstrakt* wird für Klassen verwendet, die mindestens eine
**rein virtuelle** Member-Funktion haben.

.N[
In der UML-Darstellung wird der Name einer abstrakten Klasse kursiv geschrieben.
]

Abstrakte Klassen können nur als Basisklassen verwendet werden. Die abgeleitete
Klasse wird dann typischerweise die rein virtuelle(n) Member-Funktion(en)
implementieren.

.W[
Der Versuch, Objekte einer abstrakten Klasse zu erzeugen scheitert in C++ mit
einem Kompilierfehler.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: "Diamond Shaped" Inheritance Graph
name: diamond_inheritance
header: ### "Rautenförmige" Vererbungsstruktur

Eine solche entsteht, wenn sich bei Mehrfachvererbung auf der mittleren Ebene
Klassen befinden, die wiederum eine gemeinsame Basisklasse besitzen.

Es ist bezüglich der gemeinsamen Basisklasse dann in der UML-Darstellung eine
Unterscheidung zwischen zwei Fällen erforderlich, welche die Daten-Member der
(gemeinsamen) Basisklasse betreffen:

* `«overlapping»` – die Daten-Member sind nur einmal vorhanden;

* `«disjoint»` – die Daten-Member sind doppelt vorhanden.

.W[
Im zweiten Fall ist in Bezug auf die ganz oben stehende Basisklasse von der ganz
unten stehenden Klasse aus gesehen das LSP außer Kraft gesetzt, da es nicht mehr
eindeutig ist.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Broad(er) and Deep(er) Inheritance Graph
name: broader_deeper_inheritance
header: ### Mehrstufige Vererbung allgemein gesehen

Im Allgemeinen gehen Vererbungs-Hierarchien

* sowohl *in die Breite*, d.h. eine Basisklasse wird oft viele (direkt)
  abgeleitete Klassen haben,

* wie auch *in die Tiefe*, d.h. es gibt mehrere Stufen (sieht man die direkt
  abgeleiteten Klassen als "Kinder", gibt es somit auch "Enkel", "Ur-Enkel"
  usw.).

.I[
Rautenförmige Hierarchien mit gemeinsamen `«disjoint»` Basisklassen ausgenommen,
gilt das LSP über alle Stufen einer in die Tiefe gehenden Vererbungshierarchie.
]

---
template: linkinfo
graphic: MultipleInheritance
name: multiple_inheritance
header: ## Mehrfachvererbung und virtuelle Basisklassen

---------------------------------------------------------------------

* [Prinzip der Mehrfachvererbung	](#mi_principle)
* [Virtuelle Basisklassen		](#virtual_bases)

----------------------------------------------------------------------

* [Überlappende Basisklassen		](#overlapping_bases)

----------------------------------------------------------------------

---
template: withinfo
graphic: MultipleInheritance
section: Multiple Inheritance
name: mi_principle
header: ### Prinzip der Mehrfachvererbung

Bei der Mehrfachvererbung kann im Speicherlayout nur noch eine der Basisklassen
eine gemeinsame Anfangsadresse mit der abgeleiteten Klasse haben.

.N[
Dies stellt keine große technische Herausforderung dar sondern bedeutet
lediglich eine minimale Komplikation bei der Umsetzung des LSP, wo im Fall der
Weiterreichung der abgeleiteten Klasse ggf. ein Offset zum `this`-Zeiger
addiert werden muss.
]

---
template: withinfo
graphic: MultipleInheritance
section: Virtual Base Class
name: virtual_bases
header: ### Virtuelle Basisklassen

Virtuelle Basisklassen bilden in C++ den Hintergrund der Lösung dessen, was die
UML bei rautenförmigen Vererbungshierarchien im Fall von `«overlapping»`-Klassen
an der Spitze verlangt.

.N[
Eine mögliche Implementierung von Mehrfachvererbung bürdet den Overhead den
Klassen auf der mittleren Ebene auf, indem diese nicht nur den Datenteil ihrer
(virtuellen) Basisklasse enthalten, sondern einen zusätzlichen Zeiger, über den
**alle Bezugnahmen auf den Basisklassenteil** erfolgen.
]

---
template: withinfo
graphic: MultipleInheritance
section: Overlapping Common Base Class
name: overlapping_bases
header: ### Überlappende Basisklassen

Im konkreten Fall einer rautenförmigen Hierarchie werden

* die Daten-Member der Basisklasse nur ein einziges Mal in der *Most Derived
  Class* vorhanden sein, und

* die Zeiger in den Klassen der mittleren Ebene werden jeweils auf dieses
  Daten-Member verweisen.

Da alle Bezugnahmen darauf – wie gerade beschrieben – über diese Zeiger laufen,
werden die Klassen der mittleren Ebene **ein und dasselbe** Basisklassen-Objekt
ansprechen.

---
template: linkinfo
graphic: DiamondShapedInheritance
name: diamond_shapes
header: ## Rautenförmige Ableitungshierarchien

------------------------------------------------------------------------

* [UML-Darstellung `«overlapping»` ...		](#overlapping_uml)
* [... versus `«disjoint»`			](#disjoint_uml)

------------------------------------------------------------------------

* [Abbildung auf Speicher `«overlapping»` ...	](#overlapping_memory)
* [... versus `«disjoint»`			](#disjoint_memory)

------------------------------------------------------------------------

* [Konstruktor / Destruktor `«overlapping»` ...	](#overlapping_ctordtor)
* [... versus `«disjoint»`			](#disjoint_ctordtor)

------------------------------------------------------------------------

---
template: withinfo
graphic: DiamondShapedInheritance
section: UML Class Graph («overlapping»)
name: overlapping_uml
header: ### UML-Darstellung «overlapping»

Die zusammengefasste Darstellung des Falls `«overlapping»` in Bezug auf

* die UML-Darstellung,

* das Speicherlayouts und

* die Typumwandlungen im Rahmen des LSP

erlaubt den direkten Vergleich zum Fall `«disjoint»`.

---
template: withinfo
graphic: DiamondShapedInheritance
section: UML Class Graph («disjoint»)
name: disjoint_uml
header: ### UML-Darstellung «disjoint»

Die zusammengefasste Darstellung des Falls `«disjoint»` in Bezug auf

* die UML-Darstellung,

* das Speicherlayouts und

* die Typumwandlungen im Rahmen des LSP

erlaubt den direkten Vergleich zum Fall `«overlapping»`.

---
template: withinfo
graphic: DiamondShapedInheritance
section: Class to Memory Mapping («overlapping»)
name: overlapping_implementation
header: ### Abbildung auf Speicher `«overlapping»`

Die zusammengefasste Darstellung des Falls `«overlapping»` in Bezug auf

* den Quelltext,

* den Konstruktor-._[] sowie

* den Destruktor-Ablauf

erlaubt den drekten Vergleich zum Fall `«disjoint»`.

.F[:
Siehe auch [Aufgabe von Dienstagvormittag (Teil 1)](../Examples/03_tuesday1_x1).
]

---
template: withinfo
graphic: DiamondShapedInheritance
section: Class to Memory Mapping («overlapping»)
name: disjoint_implementation
header: ### Abbildung auf Speicher `«disjoint»`

Die zusammengefasste Darstellung des Falls `«disjoint»` in Bezug auf

* den Quelltext,

* den Konstruktor- sowie

* den Destruktor-Ablauf

erlaubt den direkten Vergleich zum Fall `«overlapping»`.

---
template: linkinfo
graphic: Example-ClassDesign
name: example_relations
header: ## Beispiele zu Klassenbeziehungen

-------------------------------------------------------------------------------

* [Eine anpassbare Komponente ...		](#an_adaptable_component)
* [... und deren Nutzung 			](#using_existing_component)

-------------------------------------------------------------------------------

* [Rautenförmige (Mehrfach-) Vererbung		](#with_multiple_inheritance)

-------------------------------------------------------------------------------

* [Drei Interfaces				](#with_three_interface)

-------------------------------------------------------------------------------

* [Flexible Erweiterbarkeit durch "Mix-Ins"	](#with_extensibilty)

-------------------------------------------------------------------------------

* [Orientiert am GoF *Observer Muster*		](#with_elaboration)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: Example-ClassDesign
section: Reusable Component
name: with_existing_component
header: ### Eine (anpassbare) Komponente

Anpassbare Komponenten entstehen normalerweise entweder

* durch Planung, wenn zukünftige Variabilität (korrekt) vorhergesehen wurde,
  oder

* durch Erfahrung, wenn zu einer bereits bestehende Funktionalität eine – im
  ersten Entwurf noch nicht eingeplante – neue Variante benötigt wird.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt ist die Template-Version der
`RingBuffer`-Klasse eine solche anpassbare Komponente.
]

.F[:
Sieha auch
[Aufgabe Dienstagvormittag (Teil 2)](../Examples/03_tuesday1_x2) und
[Examples/ClassDesigns/ReusableComponent](../Examples/ClassDesigns/ReusableComponent)
]

---
template: withinfo
graphic: Example-ClassDesign
section: Reusable Adapted Component
name: with_existing_component
header: ### Nutzung der (angepassten) Komponente

Die Nutzung einer (angepassten) Komponente reduziert den Aufwand an immer wieder
neu zu schreibendem Code.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt wird

* die Template-Version der `RingBuffer`-Klasse ggf.
* mit unterschiedlichen Instanziierungs-Argumenten

verwendet.
]

Die Alternative dazu wäre *Copy&Paste-Programmierung*, also ein klarer Verstoß
gegen das *DRY-Pinciple*.

.F[:
[Examples/ClassDesigns/AdaptedComponent](../Examples/ClassDesigns/AdaptedComponent)
]

---
template: withinfo
graphic: Example-ClassDesign
section: Diamond-Shapend Inheritance
name: with_multiple_inheritance
header: ### Rautenförmige (Mehrfach-) Vererbung

Besteht die Bereitschaft den Preis für die dann oft notwendigen, virtuellen
Basisklassen zu zahlen, lassen sich ggf. flexible Kombinationsmöglichkeiten
mit einem guten Grad an Wiederverwendung durch Mehrfachverarbung erreichen.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt werden aus den Klassen `Average`
und `Extrema` mittels Mehrfachvererbung zur Klasse `Statistic` kombiniert,
womit diese beide Fähigkeiten vereint:

* den Mittelwert aller Daten zu ermitteln, und
* das Minimum und Maximum aller Daten zu ermitteln.
]

.F[:
[Examples/ClassDesigns/DiamondShaped](../Examples/ClassDesigns/DiamondShaped)
]

---
template: withinfo
graphic: Example-ClassDesign
section: Three Interfaces
name: with_three_interface
header: ### Drei Interfaces

Die Nutzung von Interfaces kann die Komplexität der Gesamt-Architektur aus der
"Sicht einzelner Klienten" etwas vereinfachen.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt werden

* zu einer gemeinsamen Klasse `Statistic`
* drei Interfaces definiert,

so dass

* hinsichtlich der *Nutzer* dieser Klasse jeweils klar ist,
* auf welches Sub-Set der Gesamt-Funktionalität sie angewiesen sind.
]

.F[:
[Examples/ClassDesigns/ThreeInterfaces](../Examples/ClassDesigns/ThreeInterfaces)
]

---
template: withinfo
graphic: Example-ClassDesign
section: Improved Reuse with Mixin Classes
name: with_extensibilty
header: ### Inkrementale Erweiterbarkeit durch Mix-Ins

Über Mixin-Klassen lässt sich ggf. flexible Kombinierbarkeit schaffen auch ohne
das virtuelle Basisklassen notwendig werden.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt werden

* die Klassen `Average`, `Extrema` und `Statistic` flexibel zusammengesetzt
  durch
* unterschiedliche Kombinationen der Basisklasse `Value`
* mit den beiden Mixins `AverageMixin` und `ExtremaMixin`.
]

.F[:
Leicht vereinfacht (ohne `RingBuffer`-Komponente) in
[Aufgabe von Dienstagvormittag (Teil 3, Variante 1)](../Examples/03_tuesday1_x3)
]

---
template: withinfo
graphic: Example-ClassDesign
section: Close to GoF "Observer" Pattern
name: with_elaboration
header: ### Orientiert am GoF *Observer Muster*

[Observer Pattern]: http://en.wikipedia.org/wiki/Observer_pattern

Das "Flaggschiff" unter allen hier verglichenen Entwürfen.

Es vereint hohe Flexibilität und geringe Kopplung ... hat allerdings auch die
komplexeste Implementierung.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt werden in Anlehnung an das
[Observer Pattern]

* die Klassen `Average`, `Extrema` und `Statistic` flexibel zusammengesetzt
  durch
* unterschiedliche Kombinationen der Basisklasse `Value`
* mit den beiden Mixins `AverageMixin` und `ExtremaMixin`,

wobei Abhänggkeiten gering gehalten werden

* über das `INotifyUpdate`-Interface und
* ein flexibles Registrierungsprotokoll.
]

.F[:
Leicht vereinfacht (ohne `RingBuffer`-Komponente) in
[Aufgabe von Dienstagvormittag (Teil 3, Variante 2)](../Examples/03_tuesday1_x3)
]

---
template: plain
name: exercise_tue1
header: ## Übung

Ziel der Aufgabe:

Analyse und Bewertungen diverser Varianten eines Beispiels, in dem eine Reihe
unterschiedlicher Klassenbeziehungen verwendet werden.

.N[
Weitere Details werden vom Dozenten anhand des Aufgabenblatts sowie der
vorbereiteten Eclipse-Projekte erläutert.
]

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>


