<!DOCTYPE html>
<html>
  <head>
    <title>C++-For (4) – Dienstag Teil 2</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
    <!-- when changing the stylesheet, please also change EACH 'styling-by:' -->
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies aproximately 2/3 of the page width. So only add
  little information, preferrably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open – add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++ FOR]: 00_content.html#agenda

# [C++ FOR] (Tuesday Afternoon)

-------------------------------------------------------------------------------

1. [Iterator-Kategorien		 		](#iterator_categories)
1. [Konventionen der Iterator-Schnittstelle	](#iterator_conventions)
1. [Iteratoren und Algorithmen			](#iterators_in_algorithms)
1. [Übung					](#exercise_tue2)

-------------------------------------------------------------------------------

Kürzere Pausen werden jeweils nach Bedarf eingelegt.

Die Besprechung der Musterlösung(en) erfolgt im direkten Anschluss an die
Mittagspause.

---
template: linkinfo
graphic: STL-IteratorCategories
name: iterator_categories
header: ## Iteratoren-Kategorien

------------------------------------------------------------------------

* [Unidirektional-Iteratoren		](#unidirectional_iterators)

------------------------------------------------------------------------

* [Bidirektional-Iteratoren		](#bidirectional_iterators)

------------------------------------------------------------------------

* [Iteratoren mit wahlfreiem Zugriff	](#random_access_iterators)

------------------------------------------------------------------------

---
template: withinfo
graphic: STL-IteratorCategories
section: Unidirectional Iterators
name: unidirectional_iterators
header: ### Unidirektional-Iteratoren

Iteratoren, welche der Kategorie der Unidirektional-Iteratoren angehören, können
sich – ihrem Namen entsprechend – nur in eine Richtung bewegen, nämlich vom
Anfang eines Containers zu dessen Ende hin.

Um pure Unidirektional-Iteratoren handelt es sich bei

* `std::forward_list<T>::iterator`

die `const_`-Variante eingeschlossen.


---
template: withinfo
graphic: STL-IteratorCategories
section: Bidirectional Iterators
name: bidirectional_iterators
header: ### Bidirektional-Iteratoren

Iteratoren, die der Kategorie der Bidirektional-Iteratoren angehören, können
sich – ihrem Namen entsprechend – in zwei Richtung bewegen, nämlich vom Anfang
eines Containers zu dessen Ende hin und umgekehrt.

Um Bidirektional-Iteratoren handelt es sich bei

* `std::list<T>::iterator`
* sowie den Iteratoren der assoziativen Container,

die jeweiligen `const_`, `reverse_` und `const_reverse_`-Varianten
eingeschlossen.

---
template: withinfo
graphic: STL-IteratorCategories
section: Random Access Iterators
name: random_access_iterators
header: ### Iteratoren mit wahlfreiem Zugriff

Iteratoren, die der Kategorie der Random-Access-Iteratoren angehören, können –
ihrem Namen entsprechend – innerhalb des zugehörigen Containers effizient
wahlfrei zugreifen.

Neben der Addition und Subtraktion von Ganzzahlen (womit der Iterator über
größere Distanzen weitergschaltet wird) kann über Differenzbildung auch die
Anzahl der Elemente bestimmt werden, die sich zwischen zwei Iteratorpositionen
befinden.

Um Random-Access-Iteratoren handelt es sich bei

* `std::array<T, N>::iterator`,
* `std::vector<T>::iterator` und
* `std::deque<T>::iterator`

die jeweiligen `const_`, `reverse_` und `const_reverse_`-Varianten
eingeschlossen.

---
template: plain
header: ### Grenzprüfung bei Random-Access-Iteratoren

Hier ist zu beachten, dass die Minimal-Anforderungen des C++-Standards so
gefasst sind, dass eine hoch-effiziente Implementierung möglich ist, auch
wenn dies auf Kosten der Sicherheit geht.

.W[
Wenn Operationen, an denen Iteratoren mit wahlfreiem Zugriff beteiligt sind,
eine (neue) Iterator-Position außerhalb des Containers liefern, ist das Ergebnis
undefiniert.
]

Gültige Positionen sind dabei auch die möglichen Endstellungen (am
Container-Ende für normale Iteratoren bzw. an Container-Anfang für
Reverse-Iteratoren).

.W[
Für ein definiertes Ergebnis bei der Differenzbildung müssen die beteiligten
Iteratoren gültige Positionen (inklusive der Endpositionen) im selben Container
haben.
]

Sichergestellt ist aber, dass zwei Iteratoren, die in verschiedene Container
zeigen, niemals als "gleich" angesehen werden.

---
template: linkinfo
graphic: STL-IteratorUsages
name: iterator_conventions
header: ## Iterator-Konventionen

----------------------------------------------------------------------------

* [Iteratoren verbinden …	](#iterators_as_glue)
* [… Container mit …		](#container_axis)
* [… Algorithmen		](#algorithm_axis)

----------------------------------------------------------------------------

* [Input-Iteratoren		](#input_iterators)
* [Output-Iteratoren		](#output_iterators)

----------------------------------------------------------------------------

* [Erfolgreiche und …		](#success_from_searching)
* [… gescheiterte Suche		](#failure_from_searching)

----------------------------------------------------------------------------

* [Füllstands- und …		](#state_from_filling)
* [… Löschenanzeige		](#removing_logically_only)

----------------------------------------------------------------------------

---
template: withinfo
graphic: STL-IteratorUsages
section: Iterators as "Glue"
name: iterators_as_glue
header: ### Iteratoren als verbindendes Element

Mit Iteratoren als Bindeglied zwischen Containern und Algorithmen sind bei

* ca. 40 Algorithmen (-Familien) und

* 12 Containern im ISO-Standard

keine 480 (= 12 × 40) Implementierungen notwendig.._[]

.F[:
Unter Berücksichtigung der Tatsache, dass nicht alle Algorithmen für alle
Container sinnvoll sind, wird die Zahl der erforderlichen Implementierungen
um die hundert sein.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Container Dimension
name: cont_algo_axis
header: ### Container- und Algorithmen-Achse

In C++98 wurden drei sequenzielle und vier assoiative Container standardisiert.

Mit C++11 sind es nun insgesamt vier sequenzielle und acht assoziative Container.

(C++14 hat keine weiteren Container hinzugefügt.)

---
template: withinfo
graphic: STL-IteratorUsages
section: Algorithm-Dimension
name: algorithm_axis
header: ### Algorithmen-Achse

Hier gibt es – je nach zählweise – im Rahmen des ISO&ANSI-Standards gut drei
Dutzend Einträge.

.N[
Viele Algorithmen kommen in "Familien" wie etwa:

* Grundlegende Variante
* Variante endend mit `_if` für flexible Bedingungsprüfung
* Variante endend mit `_copy` für Ergebnisablage in neuem Container
* Soweit sinnvoll die Kombination von Obigem
]


---
template: withinfo
graphic: STL-IteratorUsages
section: Input Iterators
name: input_iterators
header: ### Input-Iterator-Kategorie

Input-Iteratoren sind *abwechselnd*

* für den *Lese-Zugriff* zu dereferenzieren (`*`) 

* und *weiterzuschalten* (`++`).

.W[
Bei Nichtbeachtung dieser Anwendungsvorschrift betrifft das Fehlverhalten oft
nicht alle Arten von Containern, so dass Verstöße nur bei ausreichenden Tests
auffallen.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Output Iterators
name: output_iterators
header: ### Output-Iterator-Kategorie

Output-Iteratoren sind *abwechselnd*

* für den *Schreib-Zugriff* zu dereferenzieren (`*`)

* und *weiterzuschalten* (`++`).

.W[
Bei Nichtbeachtung dieser Anwendungsvorschrift betrifft das Fehlverhalten oft
nicht alle Arten von Containern, so dass Verstöße nur bei ausreichenden Tests
auffallen.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Return Success from Search
name: success_from_searching
header: ### Erfolgreiche Suche

Beim Suchen (und verwandten Container-Operationen) wird der Erfolg dadurch
angezeigt, dass der als Rückgabewert gelieferte Iterator

* auf eine gültige Position

im zur Bearbeitung übergebenen Daten-Bereich zeigt.

.W[
Beim Suchen in einem leeren Container wird stets die Endposition geliefert.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Return Failure from Search
name: failure_from_searching
header: ### Fehlgeschlagene Suche

Beim Suchen wird der Misserfolg damit angezeigt, dass der als Rückgabewert
gelieferte Iterator

* immer auf die Endposition

des zur Bearbeitung übergebenen Bereichs zeigt.

---
template: withinfo
graphic: STL-IteratorUsages
section: Return State from Filling
name: state_from_filling
header: ### Zustandsanzeige nach Füllen

Beim Füllen eines Containers ist es üblich, dass Algorithmen

* den (neuen) Füllstand des Containers

durch einen entsprechenden Iterator als Rückgabewert anzeigen.

---
template: withinfo
graphic: STL-IteratorUsages
name: removing_logically_only
section: Return "New End" when "Removing" Elements
header: ### Löschanzeige durch neues (logisches) Ende

Da die Algorithmen für eine große Zahl von Containern funktionieren sollen,
finden gibt es einige aus pragmatischen Sicht sinnvolle aber dennoch
"merkwürdige"._[] Besonderheiten.

.F[:
… des Merkens würdige …
]

Eine davon betrifft die Frage, wie mit aus einem Container gelöschten ELementen
grundsätzlich zu verfahen ist, wenn der "löschende" Algorithmus den Container
nicht physisch verkleinern kann.

Beim "logischen Löschen" von Elementen aus Containern

* werden die enthaltenen Elemente lediglich anders angeordnet, und

* ein Iterator, welcher das "neue Ende" bezeichnet, wird als Rückgabewert
  geliefert.

.N[
In den späteren Code-Fragmenten dieses Kapitels folgen konkrete Beispiele.
]

---
template: plain
name: iterators_in_algorithms
header: ## Iteratoren und Algorithmen

Die konsequente Verwendung von Iteratoren bei der Implementierung aller
STL-Algorithmen verschafft eine besondere Flexibilität.

Iteratoren sind in der Regel einfache (Helfer-) Klassen, welche gemäß dem
Container, für den sie jeweils zuständig sind, eine vollkommen unerschiedliche
Implementierung besitzen können.

.N[
Damit können die Daten, die ein STL-Algorithmus bearbeitet, aus ganz
unterschiedlichen Quellen stammen und ebenso die gelieferten Ergebnisse an
ganz unterschiedlichen Zielen abgelegt werden.
]

---
template: plain
header: ### Beispiel: Implementierung des `copy`-Algorithmus

Zum besseren Verständnis, wie mittels Iteratoren die Algorithmen eine besondere
Flexibilität erzielt wird, ist ein Blick auf eine mögliche Implementierung des
`copy`-Algorithmus hilfreich:.._[]
```
template<typename T1, typename T2>
T2 my_copy(T1 from, T1 upto, T2 dest) {
    while (from != upto)
       	*dest++ = *from++;
    return dest;
}
```

.F[:
Damit dieser Algorithmus ggf. per *Copy&Paste* in ein Programm übernommen und
ausprobiert werden kann, wurde er vorsorglich `my_copy` genannt, so dass auch
bei `using namespace std;` ein Konflikt mit `std::copy` ausgeschlossen ist.
]

---
template: plain
header: #### Kopieren der Elemente eines `std::set` in einen `std::vector`

Die gerade gezeigte Funktion kann problemlos zwischen zwei unterschiedlichen
Containern kopieren:
```
std::vector<int> v;
std::set<int> s;
…
v.resize(s.size());
std::copy(s.begin(), s.end(), v.begin());
```
Da über einen normalen Iterator – wie von `v.begin()` geliefert – nur bereits
vorhandene Elemente überschrieben aber keine neuen Elemente angefügt werden
können, ist es wichtig, den Vector vor dem Kopieren auf die notwendige (Mindest-)
Größe zu bringen.

---
template: plain
header: #### Anhängen an Vektoren

##### Hilfsklasse: `back_insert_iterator`

Ohne den aufnehmenden Vektor zuvor auf eine passende Größe zu bringen, lässt
sich eine sichere Variante des Kopierens erreichen, indem man die neuen Elemente
stets mit `push_back` anfügt:._[]
```
std::copy(s.begin(), s.end(),
          std::back_insert_iterator<std::vector<int>>(v)
);
```
.F[:
Das Umbrechen längerer Zeilen bei der Argumentübergabe erscheint sinnvoll, um
die Argumente nach ihrer Bedeutung zu gruppieren. Die dabei verwendete
asymmetrische Klammernsetzung ist sicher Geschmackssache, entspricht aber dem
oft auch bei geschweiften (Block-) Klammern angewandten Stil.
]

---
template: plain
header: ##### Hilfsfunktion: `back_inserter`

Die – redundant erscheinende – Angabe von `int` als Datentyp des Containers `v`
ist technisch der Tatsache geschuldet, dass ein (temporäres) Objekt der
Template-Klasse `std::back_insert_iterator` erzeugt werden muss und der
Konstrukor aus dem Argumenttyp nicht auf den Instanziierungstyp schließen kann.

Eine Hilfsfunktion._[] vermeidet diese Redundanz:
```
std::copy(s.begin(), s.end(), std::back_inserter(v));
```

.F[:
Diese Funktion ist zwar Bestandteil der Standardbibliothek, muss also nicht
selbst implementiert werden, ihre Implementierung ist aber insofern interessant,
als die zugrundeliegende Technik in ähnlich gelagerten Fällen zur Vermeidung
redundanter Typangaben eingesetzt werden kann:
```
   template<typename T>
inline std::back_inserter_iterator<T> std::back_inserter(T &c) {
    return std::back_insert_iterator<T>(c);
}
```
]

---
template: plain
header: #### Am Anfang oder Ende sequenzieller Container einfügen

Selbstverständlich funktionert der `std::back_inserter_iterator` bzw. die
Hilfsfunktion `std::back_inserter` auch für die Klassen

* `std::list` und
* `std::deque`

und es existiert auch ein `std::front_insert_iterator` sowie eine Hilfsfunktion
`std::front_inserter` welche mit den Klassen

* `std::list`,
* `std::deque` und
* `std::forward_list`

verwendbar ist.._[]

.F[:
Allgemeiner ausgedrückt ist die Anforderung beim `std::back_insert_iterator`,
dass für den zur Instanziierung verwendeten Container eine Member-Function
`push_back` existiert, und beim `std::front_insert_iterator` entsprechend, dass
`push_front` existiert.
]

---
template: plain
header: #### In assoziative Container einfügen

##### Hilfsklasse: `insert_iterator`

Hiermit können z.B. alle Elemente einer Liste wie folgt in ein `std::set`
übertragen werden (wobei Duplikate natürlich nicht übernommen werden._[]):

```
std::list<MyClass> li;
…
std::set<MyClass> s;
std::copy(li.begin(), li.end(),
          std::insert_iterator<std::set<MyClass>>(s)
);
```

.F[:
Es sei denn, es handelt sich um ein `std::multiset`.
]

---
template: plain
header: ##### Hilfsfunktion: `inserter`

Auch hier gibt es eine Hilfsfunktion zur Vermeidung der (eigentlich redundanten)
Angabe des Container-Typs:
```
std::set<MyClass> s;
std::copy(li.begin(), li.end(),
          std::inserter<std::set<MyClass>>(s, s.begin())
);
```

Etwas ungewöhnlich ist hier das zusätzliche Argument. Dessen Zweck ist es, einen
Optimierungshinweis zu geben, den der Insert-Iterator ggf. verwendet, um die
Suche nach der Einfügeposition abzukürzen. Üblicherweise wird – wenn kein
wirklicher Hinweis gegeben werden kann – der Beginn-Iterator des jeweiligen Sets
verwendet.._[]

.F[:
Da es sich nur um einen Hinweis handelt, ist die Angabe unkritisch, auch wenn
man einen falschen Hinweis gibt (oder keinen passenden Hinweise angibt, obwohl
einer existiert). Dann bleibt lediglich eine Optimierungs-Chance ungenutzt …
]

---
template: plain
header: #### Stream-Iteratoren

So wie ein Back- oder Front-Insert-Iterator letzten Endes (bei der
derefenzierten Zuweisung) eine `push_back`- bzw. `push_front`-Operation für
den betroffenen Container ausführt, lassen sich auch andere Operationen in den
(überladenen) Operatoren spezieller Iteratoren unterbringen.

##### In Stream schreiben mit `std::ostream_iterator`:

Das folgende Beispiel kopiert den Inhalt einer `std::forward_list` auf die
Standard-Ausgabe und fügt nach jedem Wert ein Semikolon ein:
```
std::forward_list<long> fli;
…
std::copy(fli.begin(), fli.end(),
          std::ostream_iterator<long>(std::cout, ";")
);
```

---
template: plain
header: ##### Aus Stream lesen mit `std::istream_iterator`:

Das folgende Beispiel._[] kopiert Worte von der Standardeingabe bis EOF in eine
`std::forward_list`:
```
std::forward_list<std::string> fli;
copy(std::istream_iterator<std::string>(std::cin),
     std::istream_iterator<std::string>(),
     std::front_inserter(fli)
);
```
.F[:
Zumeist ist es zwar ausreichend, das obige Beispiel mehr oder weniger
"kochrezeptartig" und ggf. sinngemäß verändert anzuwenden, dennoch taucht häufig
die Frage auf, wie es denn "hinter den Kulissen" funktioniert. Daher als Hinweis
das folgende:  
Offensichtlich gibt es zwei Konstruktoren, von denen einer ein
`std::istream`-Objekt als Argument erhält. Ein auf diese Weise erzeugter
Input-Stream-Iterator liefert im Vergleich mit einem per Default-Konstrukor
erzeugten Gegenstück zunächst `false`.  
Die Operationen `*` und `++` werden auf eine Eingabe mit `operator>>`
abgebildet, wobei die eingelesene Variable genau Typ hat, der zur
Instanziierung der Template verwendet wurde. Sobald der Eingabestrom den
"good"-Zustand verlässt, liefert der damit verbundene Istream-Iterator beim
erneuten Vergleich mit dem per Default-Konstruktor erstellten `true`.
]

---
template: plain
header: #### Zeiger als Iteratoren

Da die für Iteratoren implementierten Operationen syntaktisch wie semantisch
denen für Zeiger entsprechen, können auch klassische Arrays bearbeitet werden.

##### Kopieren AUS klassischem Array

Mit einem klassischen Array
```
double data[100]; std::size_t ndata{0};
```

und der Annahme, dass nach dessen Befüllen die ersten `ndata` Einträge
tatsächlich gültige Werte enthalten:
```
std::copy(&data[0], &data[ndata], … );
```

Oder:
```
std::copy(data, data + ndata, … );
```

---
template: plain
header: ##### Kopieren IN klassisches Array

Mit einem klassischen Array als Ziel der Kopie:
```
const auto endp = copy( … , … , &data[0]);
```

Umrechnung des Füllstatus-Iterators in Anzahl gültiger Elemente:
```
ndata = endp - data; // oder: ... endp - &data[0]
```

Hier findet allerdings keinerlei Überlaufkontrolle statt!

.W[
Enthält der ausgelesene Container mehr Elemente als `data` aufnehmen kann,
könnten **dahinter** (= an größeren Adressen im Speicher) liegende Variablen
überschrieben werden.
]

---
template: plain
header: #### Kopieren zwischen unterschiedlichen Container-Typen

Beim Kopieren zwischen ganz unterschiedlichen Containern erfolgen auch
ggf. notwendige Anpassungen des Elementtyps:
```
using namespace std;
vector<double> v;

// from standard input float-s appended to vector ...
copy(istream_iterator<float>(cin), istream_iterator<float>(),
     back_inserter(v));

// ... to classic array (widening to double) ...
double data[100]; const auto N = sizeof data / sizeof data[0];

// ... (protecting against overflow) ...
if (v.size() < N) v.resize(N);

// ... (remembering filling state) ...
const auto endp = copy(v.begin(), v.end(), data);

// ... to set (truncating to integer) ...
set<int> s; copy(data, endp, inserter(s, s.begin()));

// ... to stdout with semicolon and space after each value
copy(s.begin(), s.end(), ostream_iterator<int>(cout, "; "));
```

---
template: plain
header: #### Kopieren zwischen gleichartigen Container-Typen

[PODs]: http://www.cplusplus.com/reference/type_traits/is_pod/

Obwohl mit dem `std::copy`-Algorithmus *1:1-Kopien* gleichartiger Container
problemlos möglich sind, wird hier eine Zuweisung eher sinnvoll sein, also:
```
std::vector<MyClass> v1, v2;
…
v2 = v1;
```
Und nicht (evtl. nach einem `v2.clear()`):
```
std::copy(v1.begin(), v1.end(), std::back_inserter(v2));
```
.N[
Insbesondere kann der spezifisch für eine Container-Klasse definierte
Zuweisungs-Operator spezielle Eigenschaften der jeweiligen Abspeicherungsart
berücksichtigen.._[]
]

.F[:
Im Gegensatz zum generischen Kopieren werden dabei oft [PODs] (plain old data
types) als Elementtyp erkannt und dann eine unterschiedliche Spezialisierung
verwendet, welche die Operation in ein `std::memmove` oder `std::memcpy`
überführt.
]

---
template: plain
header: ### Einige typische Algorithmen in Beispielen

Die folgenden Programmfragmente gehen jeweils aus von einem STL-Container
```
std::vector<int> v;
```
der mit einigen Datenwerten gefüllt wurde.

#### Zählen der Elemente mit dem Wert 542
```
auto n = std::count(v.begin(), v.end(), 542);
```

---
template: plain
header: #### Suchen des ersten Elements mit dem Wert 542
```
const auto f = std::find(v.begin(), v.end(), 542);
if (f != v.end()) {
    // erstes (passendes) Element gefunden
    …
}
else {
    // kein passendes Element vorhanden
    …
}
```

---
template: plain
header: #### Löschen aller Elemente mit dem Wert 542

```
const auto end = std::remove(v.begin(), v.end(), 542);
```

Die Variable `end` enthält nun einen Iterator, der das neue (logische) Ende des
(von der Anzahl der Elemente gesehen größeren) Containers bezeichnet.
```
// nicht mehr zum Inhalt zu zaehlende  Elemente loeschen
v.erase(end, v.end());
```

.I[
Code wie der gerade gezeigte ist vor allem in generischen Templates zweckmäßig,
bei denen die Klasse von `v` völlig offen gehalten werden soll.._[]
]

.F[:
Wird ein bestimmter, typischer und auch häufiger Anwendungsfall von solchen
Templates deutlich sub-optimal behandelt, kann immer noch eine entsprechende
Spezialisierung erfolgen.
]

---
template: plain
header: ## Callbacks aus Algorithmen

Prinzipiell sind Algorithmen zwar Code aus einer Bibliothek, nicht selten enthält dieser
aber "Rückrufe" an die Applikation.

Dafür existieren drei Möglichkeiten:

* Klassische (C-) Funktionen und Übergabe als Funktionszeiger:
  * hierbei wird nur Name der Funktion angegeben;
  * die anschließenden runden Klammern entfallen.

* Objekte mit überladener `operator()` Member-Funktion – sogenannte Funktoren:
  * oft wird eine Objekt-Instanz direkt bei der Argumentübergabe erzeugt;
  * in diesem Fall enthalten nachfolgenden runde Klammern
    * die Argumentliste Konstruktors oder
    * bleiben leer (= Default Konstruktur)

* C++11 Lambdas

---
template: plain
header: ### Callback-Beispiel mit Funktor

Ein typisches Beispiel für die Notwendigkeit eines Call-Backs besteht im Fall
des Algorithmus `std::for_each`, wobei einer Schleife über alle Elemente eines
Containers übergeben wird, was mit jedem Element zu tun ist, z.B. ausgeben.

Zunächst ein Funktor, der dies leistet:
```
struct PrintWords {
    void operator()(const std::string &e) {
        cout << ": " << e << "\n";
    }
};
```

.N[
Bei der Verwendung folgen dem Klassennamen des Funktors runde Klammern.
]

Dies gilt zumindest dann, wenn – wie oft üblich – ein (temporäres) Objekt der
Funktor-Klasse als Argument an `std::for_each` übergeben wird:
```
std::for_each(v.begin(), v.end(), PrintWords());
```

---
template: plain
header: #### Vergleich mit Funktion

Mit einer Funktion sieht das Beispiel so aus:
```
void print_words(const std::string &e) {
    cout << ": " << e << "\n";
};
```
.N[
Hier entfallen die Klammern, da der Name der Funktion weitergegeben wird.
]

```
std::for_each(v.begin(), v.end(), print_words);
```

---
template: plain
header: #### Lokale Daten in Funktoren

Einer der Vorteile von Funktoren ist, dass sich im Funktor lokale Variable
sauber kapseln lassen.

Hierzu ein leicht modifiziertes Beispiel, bei dem der Funktor die Argumente
durchnummeriert:
```
struct PrintWordsEnumerated {
    void operator()(const std::string &s) {
        std::cout << ++n << ": " << s << "\n";
    }
    PrintWordsEnumerated() : n(0) {}
private:
    int n;
};
```

---
template: plain
header: #### Parameterübergabe an Funktor

Über zusätzliche Member-Daten, die im Konstruktor des Funktors initialisiert
werden, lassen sich auch Argumente aus der Aufruf-Umgebung weiterreichen:
```
struct PrintWordsEnumerated {
    void operator()(const std::string &e) {
        os << ++n << ": " << e << "\n";
    }
    PrintWordsEnumerated(std::ostream &os_) : n(0), os(os_) {}
private:
    int n;
    std::ostream &os;
};
```

Diese sind dann bei der Verwendung zu versorgen:
```
std::for_each(v.begin(), v.end(),
              PrintWordsEnumerated(std::cout));
```

---
template: plain
header: #### Parameter aus Aufrufumgebung

Die mit der Übergabe von Parametern geschaffene Flexibilität ist spätestens
dann wichtig, wenn es sich um Informationen handelt, die in der Aufruf-Umgebung
in lokalen Variablen oder Argumenten vorliegen:
```
void foo(std::ostream &output) {
    …
    std::for_each(v.begin(), v.end(),
                  PrintWordsEnumerated(output));
    …
}
```

.I[
Dies ist nur noch mit Funktoren (und Lambdas) sauber abzubilden, mit einer
Funktion scheidet diese Technik aus.
]

---
template: plain
header: #### Datentypen in Funktoren

Diese richten sich nach der gewünschten Zugriffsart:

|Zugriffsart       |Daten-Member      |Konstruktor-Argument          |
|------------------|------------------|------------------------------|
|über Kopie        |(konstanter) Wert |Wert oder (konstante) Referenz|
|direkt, nur lesend|konstante Referenz|(konstante) Referenz          |
|auch schreibend   |Referenz          |Referenz                      |

Referenzen für Datenmember dürfen keinesfalls mit Wertübergabe im Konstrutor
kombiniert werden:
```
class SomeFunctor {
    …
    T data1;
    const T &data2;
public:
    …
    SomeFunctor(const T& d1, T d2)
        : data1(d1)  // OK
        , data2(d2)  // SERIOUS PROBLEM HERE !!
    {}
};
```

---
template: plain
header: ### Callback-Beispiel mit Lambda

Die in C++ neu eingeführte Lambdas haben gegenüber Funktoren den Vorteil, dass
der ausgeführte Code direkt als Parameter des aufgerufenen Algorithmus zu sehen
ist und nicht an einer mehr oder weniger weit davon entfernten Stelle steht.._[]

##### Grundlegendes Beispiel mit Lambda

Im einfachsten Fall greift das Lambda nur auf das vom Aufrufer übergebene
Argument und evtl. globale Variable bzw. Objekte zu:
```
std::for_each(v.begin(), v.end(),
              [](const std::string &s) {
                      std::cout << s << '\n';
              }
);
```

.F[:
Mit modernen IDEs, welche die Implementierung einer Funktion oder Klasse als
Pop-Up zeigen, sobald man kurze Zeit den Mauszeiger darüber ruhen lässt, spielt
dieser Nachteil aber nur eine geringe Rolle.
]

---
template: plain
header: #### Lambda mit Capture List

Zum Zugriff in den Sichtbarkeitsbereich des umgebenden Blocks muss die
*Capture-List* verwendet werden:
```
void foo(std::ostream &output) {
…
std::for_each(v.begin(), v.end(),
              [&output](const std::string &s) {
                  output << s << '\n';
              }
);
```

Darin werden die übergebenen Bezeichner aufgelistet, ggf. mit vorangestelltem
`&`-Zeichen, wenn Referenz-Übergabe erfolgen soll.

---
template: plain
header: #### Lambda mit "privaten Daten"

Ein Funktor kann der problemlos private Daten besitzen, welche ausschließlich
dem überladenen Funktionsaufruf zur Verfügung stehen.

Die Möglichkeiten zur Kapselung sind in dieser Hinsicht für ein Lambda etwas
eingeschränkt: lokale Daten können nicht wirklich privat sein sondern sind
auch in der Aufrufumgebung sichtbar:
```
void foo(std::ostream &output) {
    …
    int line_nr = 0;
    std::for_each(v.begin(), v.end(),
                  [&line_nr, &output](const std::string &s) {
                      output << ++line_nr << s << '\n';
                  }
    );
    …
}
```
Obiges zeichnet zugleich den allgemeinen Weg vor, wie ein Lambda auf seine
Aufrufumgebung nicht nur lesend sondern auch modifizierend einwirken kann.

---
template: plain
header: ### Prädikate für Algorithmen

Viele STL-Algorithmen haben eine Variante, in der man ein Auswahlkriterium
(Prädikat) flexibel angeben kann. Es handelt sich dabei typischerweise um die
Algorithmus-Variante, die mit `_if` endet.

Als Beispiel zur Verdeutlichung des Prinzips kann wieder die Implemenierung
eines Algorithmus zum Kopieren von einem Container in einen anderen dienen,
diesmal beschränkt auf ausgewählte Elemente:._[]
```
template<typename T1, typename T2, typename T3>
T2 my_copy_if(T1 from, T1 upto, T2 dest, T3 pred) {
    while (from != upto) {
        const auto tmp = *from++;
        if (pred(tmp))
            *dest++ = tmp;
    }
    return dest;
}
```

.F[:
In die STL wurde der Algorithmus `std::copy_if` erst mit C++11 aufgenommen.
Allerdings erfüllt das seit C++98 vorhandene `std::remove_copy_if` denselben
Zweck, wenn man das Prädikat invertiert angibt.
]

---
template: plain
header: ### Möglichkeiten zur Übergabe von Prädikaten

Da es sich um eine Template handelt, gilt für das Prädikat `pred` lediglich,
dass als aktuelles Argument etwas "Aufrufbares" (callable) anzugeben ist.

.N[
Damit kommen

* Funktionszeiger,
* Funktoren und
* Lambdas

in Frage, sofern diese als Rückgabewert ein `bool` liefern.._[]
]

.F[:
Oder präziser: einen Typ, der ggf. in `bool` umgewandelt wird.
]

Die folgenden Beispiele arbeiten jeweils mit einen Container, der
Ganzzahlen enthält:

* In diesem werden alle Werte gezählt, welche kleiner als 42 sind.

---
template: plain
header: #### Prädikat mit Funktionszeiger übergeben

Zunächst muss die Funktion definiert werden:
```
bool lt42(int n) { return n < 42; }
```
Dann kann sie als Prädikat dienen:
```
… std::count_if( … , … , lt42);
```
.W[
Viele Compiler generieren hier grundsätzlich einen Funktionsaufruf, womit diese
Variante zur Laufzeit recht ineffizient sein kann.._[]
]

.F[:
Die GNU-Compiler erzeugen seit einigen Jahren zumindest auf den höheren
Optimierungsstufen aber deutlich besseren Code, indem sie bei sichtbarer
Funktionsdefinition in Fällen wie dem Obigen eine Inline-Umsetzung vornehmen,
selbst wenn die Funktion `lt42` nicht mit `inline` markiert wurde.
]

---
template: plain
header: #### Prädikat mit Funktor übergeben

Zunächst muss die Funktor-Klasse definiert werden:
```
struct Lt42 {
    bool operator()(int n) const { return n < 42; }
};
```
Dann wird sie als Prädikat zu einem temporären Objekt instanziiert:
```
… std::count_if( … , … , Lt42());
```
.N[
Ist der Funktionsaufruf-Operator explizit oder wie oben implizit `inline`,._[]
wird der erzeugte Code schneller (und oft sogar kleiner) sein als bei Übergabe
eines Prädikats mittels Funktionszeiger.
]

.F[:
In Bezu auf den GCC (g++) sei aber daran erinnert, dass bei ausgeschalteter
Optimierung (`-O0`) grundsätzlich *keine* Funktion als `inline`-Funktion
umgesetzt wird.
]

---
template: plain
header: #### Prädikat mit C++11-Lambda übergeben

Hier ist das Prädikat unmittelbar bei der Übergabe zu sehen:
```
… std::count_if( … , … , [](int n) { return n < 42; });
```

#### Alternative mit Standard-Bibliotheksfunktion

Diese mit C++98 eingeführte Möglichkeit wirkt sehr unleserlich und wird evtl.
auch aus diesem Grund nur selten benutzt:
```
… std::count_if( … , … , std::bind2nd(std::less<int>(), 42));
```

---
template: plain
header: ### Callback mit Zeiger auf spezifische Funktion

Dies ist die aus der C-Programmierung bekannte Technik.

Das Beispiel gibt alle Elemente mit einem Wert ungleich 524 aus:
```
bool notEq524(int n) { return n != 524; }

void foo(const std::vector<int> &v) {
    …
    std::copy_if(v.begin(), v.end(),
       	         std::ostream_iterator<int>(cout, " "),
                 notEq524
    );
    …
}
```

---
template: plain
header: ### Callback mit spezifischem Funktor

Dies ist eine für C++-typische Technik.

Das Beispiel gibt alle Elemente mit einem Wert ungleich 524 aus:
```
struct NotEq524 {
    bool operator()(int n) const { return n != 524; }
};
void foo(const std::vector<int> &v) {
    …
    copy_if(v.begin(), v.end(),
            std::ostream_iterator<int>(std::cout, " "),
            NotEq524()
    );
    …
}
```

---
template: plain
header: #### Funktoren mit Member-Daten

Der im folgenden verwendete Funktor kann in allen Vergleichen benutzt werden,
welche auf die Prüfung hinauslaufen, ob eine Ganzzahl **ungleich zu einem
gegebenen Wert** ist:
```
class NotEq {
    const int cmp;
public:
    NotEq(int c) : cmp(c) {}
    bool operator()(int n) const { return n != cmp; }
};
…
void foo(const std::vector &v) {
    …
    std::copy_if(v.begin(), v.end(),
                 std::ostream_iterator<int>(std::cout, " "),
                 NotEq(524)
    );
    …
}
```

---
template: plain
header: #### Übergabe lokaler Variablen

Um auf lokale Variablen oder Parameter._[] einer aufrufenden Funktion zugreifen
zu können, muss ein Funktor entsprechende Daten-Member besitzen, und sein
Konstruktor muss diese initialisieren:
```
void foo(const std::vector &v, int hide) {
    …
    std::copy_if(v.begin(), v.end(),
                 std::ostream_iterator<int>(cout, " "),
                 NotEq(hide)
    );
    …
}
```
.F[:
Die Parameter einer Funktion entsprechen nahezu ihren lokalen Variablen.
Es kommt lediglich die (garantierte) Initialisierung mit vom Aufrufer
angegebenden Werten hinzu.
]


---
template: plain
header: ### Callback mit C++11-Lambda

#### Ohne Nutzung der Capture-List

```
void foo(const std::vector &v) {
    …
    std::copy_if(v.begin(), v.end(),
                 std::ostream_iterator<int>(std::cout, " "),
                 [](int n) { n != 524; }
    );
    …
}
```

---
template: plain
header: #### Mit Nutzung der Capture-List

```
void foo(const std::vector &v, int hide) {
    …
    std::copy_if(v.begin(), v.end(),
    	         std::ostream_iterator<int>(std::cout, " "),
                 [hide](int n) { n != hide; }
    );
    …
}
```

---
template: plain
header: ### Generische Algorithmen vs. spezifische Member-Funktionen

Bei löschenden Algorithmen wird manchmal vergessen, dass der Container damit
nicht tatsächlich verkleinert wird. Vielmehr werden nur Elemente umkopiert oder
getauscht und als Ergebnis wird ein Iterator zurückgegeben, der das neue
logische Ende markiert.

.N[
Ist die Klasse des Containers genau festgelegt, steht alternativ zu einem
generischen Algorithmus mitunter eine spezifische Member-Funktion zur
Verfügung. Deren Verwendung ist dann in aller Regel effizienter.
]

Mit `std::list<std::string> li` beispielsweise statt
```
auto end = std::remove(li.begin(), li.end(), 542);
li.erase(end, li.end());
```

besser folgendes:
```
	li.remove(542);
```

---
template: plain
name: exercise_tue2
header: ## Übung

Ziel der Aufgabe:

Entwicklung eines STL-Algorithmus, der Daten aus einem Eingabestrom ohne
Duplikate in einen Ausgabstrom kopiert, unabhängig davon, wo diese
auftauchen (und damit anders als `std::unique`, welches lediglich direkt
aufeinanderfolgende Duplikate verwirft).

.N[
Weitere Details werden vom Dozenten anhand des Aufgabenblatts sowie der
vorbereiteten Eclipse-Projekte erläutert.
]

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>


