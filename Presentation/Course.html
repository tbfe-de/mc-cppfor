<!DOCTYPE html>
<html>
  <head>
    <title>C++-For - General</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <!-- when changing the stylesheet file please see also remark below -->
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Academy GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies aproximately 2/3 of the page width. So only add
  little information, preferrably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open – add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Academy GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->

---
template: blank
name: frontmatter

.title[
[C++-FOR](#agenda)
]

.subtitle[
Fortgeschrittene Verwendung von C++
gemäß den ISO/ANSI-Standards
]
.author.pull-left[
Durchführung:
Dipl.-Ing. Martin Weitzel
Technische Beratung für EDV
http://tbfe.de
]
.client.pull-right[
Im Auftrag von:
MicroConsult Academy GmbH
Training & Consulting
http://www.microconsult.com
]

---
template: plain
class: agenda
name: agenda
header: ## Agenda
-----------------------------------------------------------------
* [Some Foundation Knowledge (optional Refreshments)(#part1)
* [More C++-Basics (Templates, Exceptions, Library)](#part2)
* [Containers and Iterator Basics](#part3)
* [Iterators and STL Algorithms](#part4)
* [C++ from Top – Classes and Class Relations](#part5)
* [C++ from Bottom – How the Hardware is Used](#part6)
* [From Parametrized Types to Meta-Programming](#part7)
* [More on Exceptions and Resource-Management](#part8)
* [Writing "Good C++ Software" - The Big Picture](#part9)
-----------------------------------------------------------------

Setting of priorities is negotiable and including additional topics may be
considered if there is a common demand.

---
template: plain
name: online_reference
header: ## On this Training

Following some general information in this training:._[]

* [Prevailing C++-Implementations	](#prevailing_implementations)
* [Structure of the Training Document	](#training_document)
* [Online-Version			](#online_version)
* [Info-Graphics			](#info_graphics)
* [Training in English Language		](#english_language)
* [Private Annotations			](#private_annotations)

.F[:
The Online Version contains many "clickable" Links. These are distinguished only
unobtrusively so that they not disturb the flow of reading. When viewing this
document in a browser, the links reveal themselves more explicitly when hovering
with the mouse cursor.
]

---
template: plain
name: prevailing_implementations
header: ### Prevailing C++-Implementations

Most recent compilers implement C++11._[] to a moderate or even complete degree.

.N.center[
Therefore the C++11 Standard has been the guideline for what is contained and
how is it represented in that Training.
]

Occasionally

* Parts of C++98 and C++03, that are out-of-date and deprecated are accordingly
  marked, and

* important additions of C++14 or C++1y are mentioned as **future** extensions.

.F[:
Exactly spelled that standard is: ISO/ICE-14882:2011(E). The official document
may be bought from the ISO Institute, but the copyright for personal copy makes
it illegal to distribute it, so it cannot be contained here.
]

---

template: plain
name: training_document
header: ### Training Documents

In consideration of the extent of the ISO-Standard(s) for C++._[] this
presentation by far cannot cover that topic exhaustively – even at a strongly
reduced scope.

.F[:
The official document for the C++11 standard (ISO/IEC 14882:2011(E)) has more
that 1300 pages!
]

The documentation for this training consists of

* [Presentation Pages](#presentation_pages)
  (including [Footnotes](#presentation_footnotes)),
* [Example Code](#code_examples) (in various forms) and
* external Links to [Extended Information](#external_links).

These elements have a different purpose.

.N.center[
Especially with respect to Standard Library Classes and Functions you have to
use additional [Online References](#online_references).
]

A presentation alone can never be sufficient in this respect and does not strive
to.

---
template: plain
name: online_references
header: #### Online References

[C++98]: http://en.wikipedia.org/wiki/C++98#Standardization
[C++03]: http://en.wikipedia.org/wiki/C%2B%2B03
[C++11]: https://isocpp.org/wiki/faq/cpp11
[C++14]: https://isocpp.org/wiki/faq/cpp14
[C++1z]: https://isocpp.org/std/status

If you use an IDE with an integrated help feature showing reference information
for standard classes and functions, go and use it!

But also be aware that integrated help feature for a specific environment might
not make a clean separation between

* Language and Library Features according to some C++ standard, and

* Extensions specific for some Implementation.

Independent Online References as now available in the Internet do not have that
problem, e.g.

* http://www.cplusplus.com/reference/
* http://en.cppreference.com/w/cpp/

.I[
Information presented there documents C++ according to ths ISO/ANSI Standard,
clearly marking changes of the 2011 ([C++11]), 2014 ([C++14]) and (expected for)
2017 ([C++1z]) releases.
]

---
template: plain
name: presentation_pages
header: #### Presentation Pages

The main purpose of the presentation is

* to serve as a guiding thread through the topics covered,

* demonstrating typical use with code fragments,

* warn about errors, misuse, and pitfalls,

* if necessary or useful adding "behind the scenes" information.

.N.center[
**At any time**, your questions are welcome!._[]

Also, if you are about to pose a question, please do not feel limited by the
content of the current presentation page.
]

.F[:
The option to ask question is one of the major advantanges to visit a training
compared to reading a book – so use it!
]

---
template: plain
name: presentation_footnotes
header: #### Footnotes

While writing the presentation pages there were often minor aspects

* that should not get completely lost,

* but were not necessary for a first, basic understanding.

.N.center[
Such aspects went into the footnotes at the bottom of the presentation pages.
]

In the "live presentation" (running on the beamer in front of you) footnotes are
only shown optionally._[] (by hovering the mouse cursor), the printed version
shows footnotes printed as the other text.

.F[:
The reason is that footnotes should not distract your attention from the main
part of the presentation.
]

---
template: plain
name: code_examples
header: #### Example Code

Concrete C++ Examples are presented as

* [Code Fragments](#code_fragments) within the pages of this presentation,

* and also as complete, [Compilable Source Code](#compilable_code), sorted
  by topic in sub-directories linked to by this presentation.

Please consider the latter as part of the training documents, though it is not
printed to reduce the amount of pages.

.I[
You receive private copies of the example source code on an external medium,
to which you also may add your private annotations in a text-editor..[]
]

That way you can also add your private annotations directly into the source
files.

.F[:
There is usually a printer in the class room you may use to make a printout
if you prefer to add annotations on paper.
]

---
template: plain
name: code_fragments
header: ##### Code Fragments

By there very nature such are limited to a few lines, often omitting details
irrelevant to make the point.._[]

```
#include <cstdlib>
…
void application(char *prog, int argc, const char *args[]) {
    … // whatever the application needs to do
}
…
int main(int argc, char *argv[]) {
    try {
        … // prepare running the actual application code
        application(argv[0], argc-1, argv+1);
        return EXIT_SUCCESS; // everything is OK at this point ...
    }
    catch (...) {
        … // maybe log unxepected error
        return EXIT_FAILURE; // ... but here we have had problem!!
    }
}
```

.F[:
As such fragments are not run through a compiler, occasionally slight careless
mistakes might have slipped in. (Can you spot such a mistake in the code above?)
]

---
template: plain
name: online_version
header: ### Online-Version

You may download this presentation and future versions from the Internet.

.W[
The content has been composed with reasonable attention but any liability
for potentially contained errors or inaccuracies is declined.
]

The author still appreciates hints and suggestions for improvements.

------------------------------------------------------------------------------

[Creative Commons]: http://creativecommons.org

**This work is distributed under a [Creative Commons]-License.**

.I[
[**(CC) BY-SA 4.0**:
Attribution-ShareAlike 4.0 International
](http://creativecommons.org/licenses/by-sa/4.0/de/)
]

---
template: plain
name: html_presentation
header: #### HTML Presentation

[`remark`]: http://remarkjs.com

This presentation is based on the *HTML4-Präsentations-Tool* [`remark`].

#### Viewing

[JavaScript]:        http://de.wikipedia.org/wiki/JavaScript
[Modern CSS]:        http://www.w3.org/Style/CSS
[CSS-Knowledge]:     http://www.w3schools.com/css

For viewing it you may use any modern browser that

* has [JavaScript] enabled and
* is aware of [Modern CSS].._[]
* Cookies need not be enabled.

.F[:
Visual presentation is controlled by a style sheet. Given you have some
[CSS-Knowledge] the "look" may be altered without touching the content via
[styling.css](http:CSS/styling.css).
]

---
template: plain
header: #### Creating A PDF

[Google Chrome Browser]: https://www.google.de/intl/de/chrome/browser/

A printable version is most easily created with the [Google Chrome Browser].

* Just use *Print To File* and maybe

* some post-processing with a PDF-Tool of your choice (e.g. to combine several
  presentation pages on a single printed page)

.N.center[
Currently PDFs may only produced from the normal view, it does not work correctly from
[Presentation Mode](#electronic_annotations).
]

---
template: plain
name: automatic_translation
header: #### Automatic Translation

Modern Browsers now offer the option to automatically translate page content.

.N.center[
Though the quality varies between "usable" and
"funny to strange", you might want to give it a try.
]

You may want to give it a try by choosing to translate this page ...

---
template: plain
name: private_annotations
header: ### Private Annotations

Of course you may want to extend this document with your own annotations while
taking this course.

#### Annotations to Print Version

The bottom half of all printed pages has been deliberately left empty so that
you can use the space freely for annotations.

Of course, if you download a more recent version of this presentation it may be
less usable without your annotations, so you may want to consider the next page.

.N.center[
If you are happy with paper print-outs you may well stop reading here.._[]
]

The explanations given on the next page are for those who prefer to keep
this document – **including private annotations** – in a fully electronic form
which can be put on a memory stick or stored on a cloud-server.

.F[:
Please understand that **in no way** it is necessary to read and follow the
instructions given on the next page to benefit from this training. These
instructions only deal with how to get an **added value** from an electronic
document form.
]

---
template: plain
name: electronic_annotations
header: #### Annotations to HTML Version

As the core content of the HTML files is written in [markdown format] it is
quite readable by itself and you have the option to handle it with purely
electronic means.

This especially includes **private annotations** you may want to add in the
next days or at any time later, by and by.

1. Save the HTML files of the presentation locally.
2. Add annotations with a text editor of your choice.

When viewing the document in a browser you may include (or exclude) displaying
your annotations by changing to *presenter's mode* (and back).

.N.center[
Simply hit the `p`-key – feel free to try it out right now.._[]
]

Note that you can adjust the font size of annotations by clicking on the small
boxes labeled `+` and `-` at the top of the displayed page.

.F[:
The notes section of this slide is used to explain the document structure.
Future versions of this presentation may or may not use other notes section for
their own purpose too, but it should always be possible to merge an updated
version you have downloaded and your private annotations in the notes sections
with a decent [diff-tool].
]

  [markdown format]: http://de.wikipedia.org/wiki/Markdown
  [diff-tool]:       http://de.wikipedia.org/wiki/Diff

???
The content structure of the HTML file is as follows:
````````````````````````````````````````````````````
        (some lines of HTML header)
        (defining page templates etc.)
        <textarea>
        …
        … first slide …
        …
        ---
        … second slide …
        ---
        …
        … (etc.)
        …
        ---
        …
        … last slide …
        …
        &lt;/textarea>
        (some lines of HTML trailer)
````````````````````````````````````````````````````

Lines consisting of **exactly three minus signs** (nothing else!) are page
separators.

Annotations are shown in *Presenter's View* only and must be separated from
the slide content with a line consisting of **exactly three question marks**.
```
        …
        ---
        …
        … presentation slide content …
        …
        ???
        …
        … annotations added by you …
        …
        ---
        …
```

BTW: The easiest way to include small code examples, what might be a typical
use case for private annotations, is to just indent them by four spaces –
surrounding code fragments with lines of three or more back-ticks, a markdown
extension known as [Fenced Code Blocks], is the other option.

    #include <iostream>
    int main() {
        std::cout << "hello, world\n";
    }

[Fenced Code Blocks]: https://help.github.com/articles/github-flavored-markdown#fenced-code-blocks

As we are at it go: when you have this page loaded in a text editor, with the line
above – **not displayed** when you view this in the browser – and the paragraph
before the code example you have a nice way how to embed links without making
the text flow unreadable or inconvenient to edit.

<!-- The reference in square brackets needs to be unique only within a single slide
     and the line connecting the reference with the external link may be placed
     anywhere in the page … and HTML comments are another way to annotate,
     not even visible in the Presenter's View.
-->

LAST HINT: When loaded in a text editor you will find this final page close to the
end (or can locate it easily by searching for LAST HINT); if you start from here
instead from the top it may be be easier to discover the document structure, as at
the beginning there are first a number of layout template pages not visible in the
browser.

---
layout: false
template: blank
name: part1

# [C++ FOR](#agenda) (Part 1)

Some Foundation Knowledge (optional Refreshments)

---------------------------------------------------------------------------

1. [Refreshing some selected C++ Basics](#cpp_basics)
1. [Built-in and Standard Types](#standard_types)
1. [Pointers and references](#ptr_and_ref_types)
1. [Variable and Object Initialisation](#var_and_object_init)
1. [Constructors and Destructors](#ctors_and_dtors)
1. [Static Polymorphism](#static_polymorphism)
1. [Type Compatibility and Conversions](#type_conversions)

---------------------------------------------------------------------------

Together with the following chapter this constitutes roughly what is planned to
cover on Monday. Depending on the depth of coverage all these topics may even
require more time than one day. This is especially the case if both is desired,
refreshing traditional C++ knowledge **and** learning about what is new in
C++11 and beyond.


---
template: plain
name: cpp_basics
header: ## Refreshing some C++ Basics

--------------------------------------------------------------------------

* [Separate Compilation			](#separate_compilation)
* [Definition/Reference Model		](#definition_reference)
* [Compile Time Write Protection	](#const_protection)

--------------------------------------------------------------------------

Some topics covered here were not part of C++98 but introduced with C++11.

.I[
If you have good knowledge of C++98 it may still make sense to give the
following pages a cursory look and examine features introduced with C++11.
]

---
template: plain
name: separate_compilation
header: ### Separate Compilation

#### Basics of Separate Compilation

[Build-System]: http://en.wikipedia.org/wiki/Build_automation
[Unix `make`]:  http://en.wikipedia.org/wiki/Make_(software)
[Bell Labs]:    http://en.wikipedia.org/wiki/Bell_Labs
[GNU make]:     http://en.wikipedia.org/wiki/GNU_build_system
[CMake]:        http://en.wikipedia.org/wiki/CMake

[Translation Unit]: http://en.cppreference.com/w/cpp/language/translation_phases
[Header-Files]: http://www.cplusplus.com/forum/articles/10627/

Any C++-Program consists of one or more [Compilation Unit]s.

* Typically such are stored in an implementation file with the suffix `.cpp`.

* Information that needs to be available in more than one *Implementation File*
  usually goes in a *Header File* with the suffix `.h` (or sometimes `.hpp`).

.I[
Even if the number of translation units is small, the dependencies between
implementation files and header files is hard to resolve. Therefore using a
[Build System] is state of the art.._[]
]

.F[:
Build systems like the ones use today still often have their roots in the build
system developed 1976 at [Bell Labs] by Stuart Feldman, at least with respect to
their core syntax in which dependencies are specified in a `Makefile` (like is
done in [Gnu make] or [CMake].
]

---
template: plain
header: #### Dependencies between Header Files

Frequently also a header files depends on some included header file, e.g.

* if a header file **makes use** of a data type (class) or function,

* which is **declared** (with or without its definition) in a different header.

.N[
If this is the case the dependent header usually includes the other header.
]
.pull-left[
```
// header file: Base.h
class Base {
    …
};
```
]
.pull-right[
```
// header file: Derived.h
#include "Base.h"
class Derived : public Base {
    …
};
```
]

---
template: plain
header: #### Include Guards

[Include-Guard]: http://gcc.gnu.org/onlinedocs/cppinternals/Guard-Macros.html
[One Definition Rule (ODR)]: http://en.cppreference.com/w/cpp/language/definition

That way a single header might be included several times into the same
translation unit and because **multiple processing**._[] needs to be avoided
[Include Guards] are used.

.pull-left[
```
// header file: Base.h
#ifndef BASE_H
#define BASE_H
class Base {
    …
};
#endif
```
]
.pull-right[
```
// header file: Derived.h
#ifndef DERIVED_H
#define DERIVED_H
#include "Base.h"
class Derived : public Base {
    …
};
#endif
```
]

.F[:
The main reason why Include Guards are necessary is the
[One Definition Rule (ODR)] which limits the repeated introduction
of identifiers to some special cases (like completely identical
`typedefs` or function declarations with identical prototypes).
]

---
template: plain
header: #### Namespaces

As the next example shows, the name of a class alone as include guard (maybe
translated to uppercase) might create a problem:

.pull-left[
```
#ifndef SOMECLASS_H
#define SOMECLASS_H
namespace Mine {
    class SomeClass {
        …
    };
}
#endif
```
]

.pull-right[
```
#ifndef SOMECLASS_H
#define SOMECLASS_H
namespace Other {
    class SomeClass {
        …
    };
}
#endif
```
]

If now both files are includes, the first shadows the content of the second …
though it may cause the developer a hard time to detect that.

.W[
Include Guards names after classes should – somehow – also carry the namespace
name in their own name, e.g. `MINE_SOMECLASS_H` und `OTHER_SOMECLASS_H`.._[]
]

.F[:
It may also be questioned if the include guard is translated to upper case. To
avoid macro collisions some other convention like "only macros used for include
guards may end in `_H` is sufficient.
]

---
template: plain
header: #### Cyclic Dependencies

Another hard problem might be the error message which is created despite of (or
because of?) include guards used in this example:

.pull-left[
```
// file: someclass.h
#ifndef SOMECLASS_H
#define SOMECLASS_H
#include "OtherClass.h"
…
class SomeClass {
    …
    OtherClass *link;
};
#endif
```
]

.pull-right[
```
// file: otherclass.h
#ifndef OTHERCLASS_H
#define OTHERCLASS_H
#include "SomeClass.h"
…
class OtherClass {
    …
    SomeClass *link;
};
#endif
```
]

.F[:
This examples exist as compilable code in:
[Examples/Cyclic/Broken](../Examples/Cyclic/Broken) and
[Examples/Cyclic/Fixed](../Examples/Cyclic/Fixed) (corrected).
]

---
template: plain
name: definition_reference
header: ### Definition Reference Model

For each variable used in a program there must be **exactly one** definition
(with – potentially many – declarations associated with the definition by the
linker).

* When referred from a different translation unit an `extern`-declaration
  must be visible.
* The actual definition **may** include the word `extern`, even if it is
  combined with an initialisation.
* It even **needs to**._[] if there is also a `const` qualifier and no other
  `extern` declaration of that variable visible.

.W[
Using `const` for globals **reduces** visibility to the current translation
unit.
]

---
template: plain
name: const_protection
header: ### Write Protection by the Compiler (`const`)

A `const`-qualified identifier may not change its value throughout its life
time. Initialisation is mandatory if `external` is not also present.

```
const int x = 42;              // initialisation present
extern const unsigned VERSION; // reference only
```

The following will not compile:

```
++x;
```
Or also:
```
if (VERSION = 3014u) {
    // special case for version 3.14
    …
}
```

.F[:
Depending on the type and storage class of the variable and the hardware a
`const`-qualified variable may also be stored physically write-protected.
]

---
template: plain
name: standard_types
header: ## Built-in and Standard Types

--------------------------------------------------------------------------

* [Basic Integral Types			](#integral_types)
* [Integral Type Standard Aliases	](#int_type_std_aliases)
* [Floating Point Types			](#floating_point_types)
* [`void`, `bool`, and `enum`		](#void_bool_enum)
* [Querying Type Properties		](#type_properties)

--------------------------------------------------------------------------

---
template: plain
name: integral_types
header: ### Basic Integral Types

Built-in to C++ – i.e. available as reserved word without including any
header file – are the following integral standard types:

* `char` / `signed char` / `unsigned char` / `wchar_t` / `char16_t` / `char32_t`
* `short` (same as `signed short`) / `unsigned short`
* `int` (same as `signed int`) / `unsigned int`
* `long` (same as `signed long`) / `unsigned long`
* `long long` (same as `signed long long`) / `unsigned long long`

.N[
Each of the above type names constitutes a type on its own.
]

Overloading may be based on these types – i.e. they are distinguishable – even
if one has identical properties (signed-ness, limits, …) as another one.

.I[
For more information on basic integral types (incl. character types) see
subsections *[Character Types]* and *[Properties]* in:
http://en.cppreference.com/w/cpp/language/types
]
[Character Types]: http://en.cppreference.com/w/cpp/language/types#Character_types
[Properties]: http://en.cppreference.com/w/cpp/language/types#Properties

.F[:
E.g. by definition `char` has the same properties as either `signed char` or
`unsigned char` (implementation defined). Also type `int` often has the same
properties as either `short` or `long`.
]

---
template: plain
name: int_type_std_aliases
header: ### Integral Type Standard Aliases

Header file [`<cstdint>`] centralises type definitions (aliases) of frequently
required integral types with a specific number of bits.

[`<cstdint>`]: http://en.cppreference.com/w/cpp/header/cstdint

#### Standard Aliases for Exact Width

These use name patterns like `int8_t`, `uint8_t`, `int16_t`, `uint16_t` …
`uint64_t` and these will only be defined if there is hardware support for
**exactly** that number of bits.

#### Standard Aliases for Minimal Size

These use name patterns like `int_least8_t` … `uint_least64_t` and guarantee the
**smallest** integral type with at least that number of bits.

#### Standard Aliases for Fast Access

These use name patterns like `int_fast8_t` … `uint_fast64_t` and guarantee the
**fastest** integral type with at least that number of bits.

---
template: plain
name: int_type_std_aliases
header: ### Floating Point Types

The three different type names `float`, `double` and `long double` are available
for floating point.

* Often – especially if there is specific hardware support on the target platform
  – these will be mapped to the ISO754 types with 32, 64, and 80 bits.

* But the standard imposes no such requirement.

* In fact, a conforming implementation might even map all three types to the same
  hardware representation with only minimal requirements to range and accuracy.

.I[
For more information on floating point types see subsections
*[Floating Point Types]* and table *[Range of Values]* in:
http://en.cppreference.com/w/cpp/language/types
]

[Floating Point Types]: http://en.cppreference.com/w/cpp/language/types#Floating_point_types
[Range of Values]: http://en.cppreference.com/w/cpp/language/types#Range_of_values

---
template: plain
name: void_bool_enum
header: ### `void`, `bool`, and `enum`

These types serve different purposes which will be outlined in more detail on
the following pages.

* [`void`](#details_on_void)
  Denotes a type **with no valid values** and is used as result type of
  functions that return no results (i.e. classic subroutines).._[]

* [`bool`](#details_on_bool)
  Denotes a type with the only two values `true` and `false`.

* [`enum`](#details_on_classic_enum)
  Denotes a type with a given set of values and was;

* [`enum class`](#details_on_enum_class)
  Denotes a variant of `enum`-s with some more features, introduced with C++11.

.F[:
Note that `void *` has a different purpose, which is to define pointers with an
unspecified type, i.e. "just addresses". It is often used for a certain form of
"generic libraries", where mostly memory addresses are handed around, while
information about the types really stored at these locations is buried in the
program logic. An improved solution is [Boost.Any], which encapsulates the type
information with the pointer, making these sort of generic programming better
readable (and a bit more secure).
]

[Boost.Any]: http://www.boost.org/doc/libs/release/doc/html/any.html

---
template: plain
name: details_on_void
header: #### Not Existing Values: `void`

The typical use of `void` is as return type of functions returning nothing (via
their call name). Technically it is an [incomplete type], which means

* it cannot be part of (most sorts of) expressions,
* nor as type of function parameters,
* nor to define variables or class member data,
* …

What is acceptable is to call a function returning `void` as part of the
`return` statement of some other function:
```
void f() { … };
void g() { return f(); }
void h() { return g(); }
```

.F[:
One realistic use case for this is in templated code, where `h` forwards to
`g`, which may in turn forward to `f`, and it is expected all these functions
have the same return type. Then this alleviates the need to have specialisation
if the functions are generalised on their return type and this might be `void`:

```
   // a set of type generic functions forwarding from one to the other
template<typename T> T f() { … }
template<typename T> T g() { … ; return f(); }
template<typename T> T f() { … ; return g(); }
```
]

---
template: plain
name: details_on_bool
header: #### Truth Values: `bool`

Because of the traditional type conversions applied to variables and expressions of
type `bool`, it mixes seamlessly with all arithmetic types.

When using an expression in a context expecting a `bool`:

* any pointer other that `nullptr` converts to `true`;
* any arithmetic value other than zero converts to `true`;
* only zero and `nullptr` convert to `false`.

When using an expression of type `bool` in an arithmetic expression:

* the value `false` converts to `0` and
* the value `true` converts to `1` (in the specific type).

Note that type `bool` is usually represented **internally** as type larger than
only one bit, as otherwise memory access would be inefficient.

[`std::vector<bool>`]: http://en.cppreference.com/w/cpp/container/vector_bool
[`std::bitset`]: http://en.cppreference.com/w/cpp/utility/bitset

---
template: plain
header: #### Packed 0/1 Values

For dense "packing" of many 0/1-values, a classic array of `bool` is not
space efficient:
```
bool bits[100000000];  // 100 million 0/1 values
```

In this case an `std::bitset` offers a trade-off that may be worth to
consider:._[]
```
std::bitset<100000000> bits; // less space, more access time
```

.F[:
For packed bit collections of a size which can only be determined at compile
time, `std::vector<bool>` – a specialisation of `std::vector` – may be used.
As this has its own set of potential problems, a detailed discussion will be
postponed until later.
]

---
template: plain
name: details_on_classic_enum
header: #### Classic Enumerations

Classic enums (as C++ inherited from C) have the following shortcomings:

* The names of the values declared by the `enum` type (aka. enum labels)
  are **imported into the enclosing namespace**,_[]

  * thus introducing the risking inadvertent name clashes, which is
  * usually reduced by scoping `enum`-s in the body of some `class`

* The **underlying type cannot be controlled** …
  * … at least not easily and …
  * … not in an implementation-dependant way.

* There **cannot be a forward declaration**,
  * e.g. in case the enum label values are not used but only its type as
    argument to a function
  * eventually resulting in (needless) recompilations when enum labels
    are added or changed in value.

.F[:
Sometimes this specific property may not be a problem but an advantage.
]

---
template: plain
name: details_on_enum_class
header: #### C++11 Scoped Enumerations

With `enum class` C++11 resolved the problems of classic `enum`-s:._[]
```
enum class Color : unsigned short { Red, Green, Blue };
```

* The names of the labels are scoped:
  `Color::Red`, `Color::Green`, `Color::Blue`.

* The type can be easily controlled:
  `unsigned short` in this case (if not specified default is `int`).

* Forward declarations are possible:
  `enum class Color : unsigned short;`

.I[
For more information see subsection *[Scoped enumerations]* in
http://en.cppreference.com/w/cpp/language/enum
]
[Scoped enumerations]: http://en.cppreference.com/w/cpp/language/enum#Scoped_enumerations

.F[:
Compared to enum classes in Java, C++ `enum class` is still poor on features!
]

---
template: plain
name: type_properties
header: ### Querying Type Properties

Header file [`<limits>`] defines specialisations of class
`std::numeric_limits`._[] for all arithmetic types (integral and floating) and
also `bool`, providing tests for many properties of these type.._[]

One typical use is to find the range of values representable in some type:
```
std::numeric_limits<short>::min()         // lowest short value
std::numeric_limits<short>::max()         // highest short value

std::numeric_limits<int>::min()           // same for int
std::numeric_limits<int>::max()           // etc.

std::numeric_limits<unsigned long>::min() // same for
…                                         // unsigned long etc.
```

.I[
For more information see:
http://en.cppreference.com/w/cpp/types/numeric_limits
]

.F[:
Besides `std::numeric_limits` this header also defines the classes
`std::float_round_style` and `std::float_denorm_style` specifying rounding and
de-normalisation modes of floating point types.
]

[`<limits>`]: http://en.cppreference.com/w/cpp/header/limits

---
template: plain
name: ptr_and_ref_types
header: ## Pointers and References

--------------------------------------------------------------------------

* [General and `const`-qualified Pointers	](#const_pointers)
* [Classic References (Lvalue References)	](#classic_references)
* [Comparison of Pointers and Reference		](#pointer_vs_reference)
* [Rvalue References (introduces with C++11)	](#rvalue_reference)

--------------------------------------------------------------------------

---
template: plain
name: const_pointers
header: ### General and `const`-qualified Pointers

```
int *p1;       // pointer and pointed-to memory are modifiable
p1 = …;        // OK
*p1 = …;       // OK (assuming p1 points to valid memory now)
```
For a pointer `const` my refer to **the pointer itself** …
```
int *const p3 = …; // must be initialized (with address of an int)
p3 = …;            // ERROR (would modify pointer itself)
*p3 = …;           // OK (modifies pointed-to memory location)
++*p3;             // OK (increments pointed-to memory location)
++p3;              // ERROR (would increment pointer itself!)
```
… or the memory location **reachable via the pointer**:._[]
```
const int *p2; // same as: int const *p2;
p2 = …;        // pointer is still modifiable, but ...
*p2 = …;       // ... ERROR at compile-time!
```

.F[:
Of course, both kinds of `const`-qualification may be combined if it makes sense
for a given purpose, e.g. `const int *const p4 = …;` (or – switching positions
of the qualification and the type to which it is applied:
`int const *const p4 = …;`).
]

---
template: plain
name: classic_references
header: ### Classic References (Lvalue References)

The classic example is a function swapping the contents of two variables:

.pull-left[
```
void swap(int *p, int *q) {
    const int t = *p;
    *p = *q;
    *q = t;
}
…
int a, b;
…
if (a > b) swap(&a, &b);
…
```
]

.pull-right[
```
void swap(int &r, int &s) {
    const int t = r;
    r = s;
    s = t;
}
…
int a, b;
…
if (a > b) swap(a, b);
…
```
]

On the left pointers are used and addresses are handed over explicitly, on the
right arguments are defined as references, causing implicit dereferencing inside
`swap` and handing over addresses at the call site..[]

.F[:
So the difference is mostly notational (simplified source code with references),
while generated machine instructions are typically the same, though there is no
strict rule enforcing this. E.g. depending on compile time debug options
different safety checks could be generated for pointers and references.
]

---
template: plain
name: reference_initialisation
header: #### Initialising References

By concept references always denote existing memory locations,._[] therefore
they need to be initialised.

.N[
After its definition and initialisation a reference cannot be modified so that
it subsequently refers to a different memory location.
]

From that point of view references are like constant pointers, which may **not**
be modified themselves, though referenced memory can be read **and** written.

```
int v1, v2;  // some variables ...
int &r = v1; // rerefence is intialized
```

The following is **not** a compile-time error – only `r` now is an alias for
`v2` and writing to `r` actually modifies `v2`.
```
r = v2;  // copies current content of v2 to v1 (referenced by r)
```

.F[:
Not considering some artistic ways of initialisation to deliberately subvert
this property of a reference (like `T &r = *reinterpret_cast<T*>(0);`), an
invalid reference might be created by accident when a dereferenced pointer is
used to initialise a reference without prior checking: `T *p = 0; … T &r = *p`;
]

---
template: plain
name: const_reference
header: #### Constant References

A `const` qualifier for a reference always effects memory access via the
reference.

.N[
References which are `const`-qualified only allow reading memory, even if the
referenced memory (or variable) is writable.
]

In the following example the variable `v` may be modified directly and via `r1`,
but is read-only when accessed via `r2`:._[]

```
T v;
T &r1 = v;       // r1 now refers to content of v
const T &r2 = v; // r2 also refers to content of v
…
r1 = …; // OK (actually changes v)
r2 = …; // ERROR (at compile time)
```

.F[:
It should be obvious that in the light of references a value-tracking compiler
must be careful not to optimise-out *read* memory access with no intervening
*write*: the content of some location might still have been modified through a
different access path.
]

---
template: plain
name: const_correctness
header: #### Achieving the Const-Correctness

The C++ compiler catches constructs that may subvert const-correctness.

.pull-left[

```
const T cv = …;
const T &cr = cv; // OK
T &r = cv;        // ERROR
```
]

.pull-right[

```
const T cv = …;
const T *cp = &cv; // OK
T *p = &cv;        // ERROR
```
]

Aside from the notational there is **no substantial difference** between
pointers and references in the two examples above.._[]

.W[
If the above initialisation would compile, the non-modifiable variable `cv`
might be modified via a non-`const` reference (`r`) or a pointer to non-`const`
memory (`p`).
]

.F[:
GCC usually emits the same machine code for references and pointers, as long as
both are used correctly and semantically equivalent. (To try some examples
easily you may want to go to the following site: http://gcc.godbolt.org)
]

---
template: plain
name: const_ref_args
header: #### Reference Arguments

As reference initialisation occurs when handing arguments to functions, all the
peculiarities and special cases discussed so far will be mostly likely observed
there.

A typical lapse is to forget to add `const` to read-only reference arguments:
```
void foo(double &arg) {
    …
    … // all access to arg is non-modifying
    …
}
```

.pull-left[
Not callable with literal constant or `const`-qualified variable:
```
foo(0.0); // ERROR
double const PI = 3.14;
foo(PI);  // ERROR
```
]

.pull-right[
No temporaries are silently created:._[]
```
int x = 42;
foo(x);    // ERROR
foo(2*PI); // ERROR
```
]

.F[:
The reason is to avoid surprising effects that would occur especially if a
temporary were created for type coercion, and modifications were then applied to
the temporary only but not to the variable actually used as argument (though it
was "obviously" handed over by reference).
]

---
template: plain
name: pointer_vs_reference
header: ### Comparing Pointers to References

References may be viewed in two ways:

* **Either** an alternative syntax for pointers, which

  * during initialisation expects an lvalue of which the address is taken
    (i.e. "`&`" is automatically and invisibly applied);

  * on each **use** implies the dereferencing operation on each use
    (i.e. "`*`" is automatically and invisibly applied).

* **Or** an alias name for an existing memory location with a matching type.

.N[
Taking inot account the invisibly applied operations to references, then there
are usually the same machine instructions generated for references as are for
pointers – the difference is in the syntax for initialisation and access.._[]
]

.F[:
Hint: When compiling with `g++` or `clang++` you may want to use the command
line option "`-S`" (upper case) and have look at the assembler code stored in a
file with suffix "`.s`" (lower case).
]

---
template: plain
name: rvalue_reference
header: ### Rvalue Referenes

[Rvalue References]: http://en.cppreference.com/w/cpp/language/reference

[Copy Constructor and Assignment]: #copy_ctor_assign
[Move Constructor and Assignment]: #move_ctor_assign

C++11 introduced [Rvalue References]. They may only be initialised by
expressions, i.e. memory locations introduced to hold temporaries with no other
access path.

Following are the most important rules:
```
T &r = …;          // … must be modifiable T in memory
const T &cr = …;   // … must be modifiable T in memory OR
                   //        non-modifiable T in memory OR
                   //        temporary T in memory (expression)
T &&rr = …;        // … must be temporary T in memory (expression)
```

.N[
The main use for rvalue references are to overload functions differently for
arguments denoting **either** existing **or** temporary objects, and again the
main use for this is to implement [Copy Constructor and Assignment] differently
from [Move Constructor and Assignment].
]

.F[:
As a function argument an rvalue reference is in most any case **not**
`const`-qualified, as the temporary reachable over it needs to be modified
(within the limits that the destructor needs still to work correctly).
In contrary a classical reference typically **will** be `const` qualified if
introduced for improved performance of read-only accesses.
]

---
template: plain
name: var_and_object_init
header: ## Variable and Object Initialisation

--------------------------------------------------------------------------

* [Classic Initialisation Syntax	](#classic_initialisation)
* [C++11 Brace Initialisation		](#cpp11_brace_init)
* [C++11 Direct Member Initialisation	](#cpp11_member_init)
* [C++11 Compile Time Initialisation	](#cpp11_constexpr)

--------------------------------------------------------------------------

---
template: plain
name: classic_initialisation
header: ### Classic Initialisation Syntax

Until C++11 there were three different styles for initialisations:

* [Assignment-like Syntax](#assignment_like_init)
* [Constructor Call Syntax](#ctor_call_init)
* [C (inherited) Syntax for Aggregates](#aggregate_init)

There are also clearly defined rules what happens in case of:

* [Uninitialised Variables](#uninitialised_variables)
* [Uninitialised Objects](#uninitialised_objects)

---
template: plain
name: assignment_like_init
header: #### Assignment-like Initialisation

The assignment-like uses an equals sign to separate the name of the variable (or
object) initialised from the initialising expression.

```
int x = 42;
double pi = 3.14152;
std::string greet = "hello, world";
```

.N[
The difference to assignment is the type name on the left.._[]
]

.F[:
Since C++11 the type name can also be replaced with `auto`, which means that the
variable will have the type of the initialising expression, with reference (`&`),
`const` or `volatile` qualifiers stripped away.
]

---
template: plain
name: ctor_call_init
header: #### Constructor Call Syntax

Here the initialisation looks like calling a constructor, by following the
object with a comma-separated list of argument values, enclosed in parentheses:

```
std::string greet("hello");
std::string line(80, '-');
```

An exception from this rule is initialising with the default constructor.
In this case there are no parentheses following.
```
std::string empty;  // initialised with default (no content)
```

If (empty) parenthesis were used, this would be seen (like in C) as an `extern`
declaration of a function returning an `std::string`:._[]
```
std::string foo(); // NOT a default-initialised std::string !!
```

.F[:
If later that name were used with an `std::string` member function like
`foo.empty()` the compiler will typically complain that it is expecting a
function call operation.
]

---
template: plain
name: aggregate_init
header: #### C (inherited) Syntax for Aggregates

Here after the equals signed follow several comma separated values, enclosed in
braces. This can be used as well for arrays._[]
```
int primes[] = {2, 3, 5, 7, 11};
```

as for structures
```
struct Point { float x, y; };
…
Point origin = {0.0, 0.0};
```

or combinations:
```
Point polygon[] = {
    { 7.23, 12.1 },
    { 1, 3.5  },
    …
};
```

.F[:
If the size is omitted it will be determined from the number of initialising
values.
]

---
template: plain
name: uninitialised_variables
header: #### Uninitialised Variables (of Basic Types)

Variables of basic types must not be initialised. Their initial value depends on
the location of their definition:

Variables at a fixed address assigned at compile time, i.e.

* global variables,
* block-local `static` variables, and
* `static` class members

assume an initial value of

* `false` for booleans,
* `nullptr` for pointers, and
* zero (according to its type).

.W[
Variables on the stack and on the heap have undefined initial values, maybe even
"impossible" values for the given type on the given hardware.._[]
]

.F[:
The content is usually just the "bits and bytes" previously stored at that
memory location. On some hardware not all bit patterns are valid content for
floating point variables or pointers.
]

---
template: plain
name: uninitialised_objects
header: #### Uninitialised Objects

Strictly speaking, "uninitialised objects" do not exist, as any object is (at
least) initialised by the default constructor._[] of its class, but:

* If the default constructor is **automatically supplied** by the compiler, any
  data member of a built-in type receives the same initialisation as if it were
  not explicitly initialised.

* Same if a default constructor is **defined by the class itself** but forgoes
  to initialise some data members.

.N[
The rules described so far apply recursively, i.e. what happens exactly depends
on the type of the member: For basic types the rules from the previous page
apply, for (nested) objects the rules on this page.
]

.F[:
The term default constructor might be a bit misleading in some cases, because
it is easily confused with *"(a) constructor supplied by default"*. The latter
**may or may not** be the case for the default constructor, but the technical
meaning is this: *"the constructor that can be called without arguments"*.
]

---
template: plain
name: cpp11_brace_init
header: ### C++11 Brace Initialisation

Since C++11 braces are accepted in all initialising contexts shown so far (and
some more). The equals sign is made optional.._[]

.pull-left[
```
int x{42};
double pi{3.14152};
std::string greet{"hello"};
std::string line{80, '-'};
std::string empty{};
int primes[]{2, 3, 5, 7, 11};
Point origin{0.0, 0.0};
Point polygon[] {
    { 7.23, 12.1 },
    { 1, 3.5  },
    …
};
```
]
.pull-right[
```
int x = {42};
double pi = {3.14152};
std::string greet = {"hello"};
std::string line = {80, '-'};
std::string empty = {};
int primes[] = {2, 3, 5, 7, 11};
Point origin = {0.0, 0.0};
Point polygon[] = {
    { 7.23, 12.1 },
    { 1, 3.5  },
    …
};
```
]

.F[:
As no "C heritage" has to be taken into account the default constructor has an
explicitly empty argument list, and initialising values that cannot be
represented in the target type cause the compilation to fail, not just a
warning.
]

---
template: plain
name: cpp11_member_init
header: ### C++11 Direct Member Initialisation

Class members can now be initialised directly (with their definition).

* The values specified are considered to be the default if there is
  **no member initialisation** via

  * the member initialisation list of the constructor used to initialise an
    object, or
  * as direct assignment in the construct block.

* Supported initialisation syntax is

  * classic assignment style,
  * brace initialisation, but
  * **not constructor style with round parenthesis!**

.pull-left[
```
class Point {
    float x = 0.0;
    float y = 0.0;
    …
};
```
]
.pull-right[
```
class Point {
    float x{0.0};
    float y{0.0};
    …
};
```
]

---
template: plain
name: cpp11_constexpr
header: ### C++11: Compile-Time Initialisation (`constexpr`)

C++11 added the new keyword `constexpr` which may be applied to

* [data definitions](#constexpr_data) and
* [function definitions](#constexpr_data)

---
template: plain
name: constexpr_data
header: #### Compile-Time Initialised Data

By using `constexpr` with a data definition it is guaranteed that the variable
can be initialised at compile time.

* The compiler checks for the initialiser whether its value can be determined,
  because it is

  * a literal constant,
  * an expressions, or
  * result of `constexpr` functions

* allowing to use such values in any context that requires compile time
  constants, most importantly

  * array dimensions
  * value template arguments
  * or as part of expressions or function call arguments when initialising
    some other `constexpr` data item.

.N[
Compile time initialised data may also be stored in special ways, like in
statically read-only or dynamically write-protected memory.
]

---

template: plain
name: constexpr_functions
header: #### Compile-Time Callable Functions

By using `constexpr` with a function definition such function may (also) be
called at compile time.

* In C++11 this was rather restricted:._[]

  * `constexpr` were limited to a single return statement
  * though recursive calls were allowed, and
  * recursion could be stopped with a conditional expression.

* In C++14 this is much relaxed, but there are still limitations, e.g.:._[]

  * **no** `asm`, `goto`, or `try`-`catch`,
  * variables only of literal types and with initialisation,
  * no `static` or `thread_local` storage duration.

.N[
If a call to a `constexpr` function cannot be evaluated at compile time, a run
time version is made available and accordingly called where the value it returns
is needed.
]

.F[:
For more information see:
http://en.cppreference.com/w/cpp/language/constexpr
]

---
template: plain
name: ctors_and_dtors
header: ## Constructors and Destructors

--------------------------------------------------------------------------

* [General Purpose				](#ctor_dtor_generally)
* [(No) Memory Allocation in Constructors	](#ctor_no_memory_alloc)
* [Memory of Variable Size at Run-Time		](#runtime_sized_memory)
* [Compile Time vs. Run Time Sizing		](#ct_vs_rt_sizing)
* [(No) Memory De-Allocation in Destructors	](#dtor_no_memory_dealloc)
* [Precautions in Memory Allocating Classes	](#prc_memalloc_classes)
* [Exceptions in Constructors and Destructors	](#ctor_dtor_exceptions)
* [Re-Using Constructors			](#ctor_reuse)

--------------------------------------------------------------------------

---
template: plain
name: ctor_dtor_generally
header: ### General Purpose of Constructors and Destructors

Constructors and Destructors are one of the key additions of C++ over C.

Together they guarantee that

* initialisation will take place when an object comes into existence, and

* will be reliably reverted when an object ceases to exist.._[]

This is – of course – only true for objects with a scope-bound lifetime. In case
of local `static` object

* the initialisation will take place only once (when the scope is entered the
  first time, and

* reverted after the main program has ended.

.F[:
This easily extends to general resource allocation and deallocation, as is
purposefully applied in the [RAII-pattern].
]

[RAII-pattern]: http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization

---
template: plain
name: ctor_no_memory_alloc
header: ### (No) Memory Allocation in Constructors

A common misconception is that it is the constructor's responsibility to allocate
memory for objects of its class:

.pull-left[
Classic C++ initialisation:
```
class Point {
    float x;
    float y;
public:
    Point(float x_, float y_)
        : x(x_), y(y_)
    {}
};
```
]
.pull-right[
C++11 brace initialisation:
```
class Point {
    float x;
    float y;
public:
    Point(float x_, float y_)
        : x{x_}, y{y_}
    {}
};
```
]

In this case there is already memory allocated when the constructor is called to
initialise objects.
```
Point origin(0.0, 0.0);	  // classic initialisation
Point other{3.1, 7.12};   // C++11 brace initialisation
Point zzz = {1.7, 0.0};   // as before, with equals sign
```

---
template: plain
name: runtime_sized_memory
header: ### Memory of Variable Size at Run-Time

The reason for the misconception is that **some** classes (like `NamedPoint` below)
will get space allocated for two `float`-s and one pointer, but the space pointed
to by `name` is on the heap:
```
class NamedPoint {
    float x, y;
    char *name;
public:
    NamedPoint(const char * name_, float x_, float y_)
        : x{x_}, y{y_}
        , name{new char[std::strlen(name_)+1]} {
        std::strcpy(name, name_);
    }
};
```

.W[
**Therefore class `NamedPoint` needs a destructor – and probably a copy
constructor and assignment too.**._[]
]

.F[:
Otherwise a resource leak or dangling pointers will almost certainly result as
soon as objects of this class get created or assigned by copying from existing
objects.
]

---
template: plain
name: ct_vs_rt_sizing
header: ### Compile Time vs. Run Time Sizing

The necessity to do memory allocation as part of the constructor – with the
ultimate consequence to implemented more operations – does not arise if the
space requirements are variable but fixed at compile time.._[]

.pull-left[
```
class FString {
    const std::size_t N;
    char *data;
public:
    FString(std::size_t n)
        : N{n}
        , data{new char[N+1]} {
        data[0] = '\0';
    }
    ~FString() {
        delete[] data;
    }
};
…
FString fstr(20);
```
]

.pull-right[
```
template<std::size_t N>
class FString {
    char data[N+1];
public:
    FString() {
        data[0] = '\0';
    }
};
…
FString<20> fstr;
```
* Above: sized at **compile time**.
* Left: sized at **run time**.
]

.F[:
The design of a class for "fixed length" character strings taken as example is
is only partially fleshed out here – in practice some more member functions
would make sense.
]

---
template: plain
name: dtor_no_memory_dealloc
header: ### (No) Memory De-Allocation in Destructors

Classes that do no (further) memory allocation in their constructor code also
need no deallocation in their destructor – which may of course still be
necessary for other reasons.

Continuing with the above examples, only `NamedPoint` has the necessity for a
destructor:
.pull-left[
```
class Point {
    …
    // no destructor required
    // to "de-allocate" memory
    ~Point() {
        // … but maybe for
        // other reasons
    }
    …
};
```
]

.pull-right[
```
class NamedPoint {
    …
    ~NamedPoint() {
        delete[] name;
        // … maybe more to do
    }
    …
};
```
]

But: supplying a destructor which does nothing is neither necessary nor can it
be considered "good style" since it may not be optimised-out and slow down the
program each time an object ends it life.

---
template: plain
name: prc_memalloc_classes
header: ### Precautions in Memory Allocating Classes

Just copying the `data` pointer as the default constructor and assignment
operator would do is surely the wrong thing, so these should at least be
blocked,._[] which is particularly easy since C++11.

```
class NamedPoint {
    …
    NamedPoint(const NamedPoint &) =delete;
    NamedPoint& operator=(const NamedPoint &) =delete;
    …
};
```

.F[:
Still better were to implememt the operations so that the `name` member gets
properly cloned:

```
   … // inside the class above
    NamedPoint(const NamedPoint &init)
        : x{init.x}, y{init.y}
        , name{std::strcpy(new char[std::strlen(init.name)+1], name)}
    {}
    NamedPoint& operator=(const NamedPoint &rhs) {
        if (this != &rhs) {
            x = rhs.x; y = rhs.y;
            delete[] name;
            name = std::strcpy(new char[std::strlen(rhs.name)+1], name);
        }
        return *this;
    }
```
]

---
template: plain
header: #### Alternative Design with "Self-Contained" Helper Class

A still better design would put allocation and deallocation in a helper class
which is self-contained with respect to memory management._[]
```
class FString {
    const std::size_t N;
    char *data;
public:
    FString(std::size_t n) : N{n}, data{new char[N+1]} {
        data[0] = '\0';
    }
    FString(const FString &init) : data{new char[init.N+1]} {
        std::strcpy(data, init.data);
    }
    ~FString() { delete[] data; }
    FString& operator=(const FString &rhs) {
        std::strncpy(data, rhs.data, N)[N] = '\0';
    }
    operator const char*() const { return data; }
};
```

.F[:
Whether that way class `FString` is fleshed-out here is actually desirable for a
generically usable "fixed length string class" is disputable, but it was chosen
that way to mimic the prior approach (without helper) as much as possible.
]

---
template: plain
header: #### Simplifying Clients with Self-Contained Members

Now class `NamedPoint` can be implemented without worrying about memory
allocation and de-allocation:
```
class NamedPoint {
    float x, y;
    FString name;
public:
    Point(const char *name_, float x_, float y_)
        : x(x_), y(y_), name(std::strlen(name_)  {
        name = name_;
    }
    Point(const Point&) =default;            // if not =delete
    Point& operator=(const Point&) =default; // if not =delete
    …
};
```

The above also demonstrates the new syntax of C++11 to explicitly request the
default copy constructor and assignment._[], which means the operations are
recursively forwarded to all of the members.

.F[:
For backward compatibility, generating default versions of copy constructor and
assignment will still happen in C++11 without the above.
]

---
template: plain
name: ctor_dtor_exceptions
header: ### Exceptions in Constructors and Destructors

Generally constructors and destructors

* may "fail" (in doing what they are expected to do) and

* (in general) **one** option is to inform clients about the
  problem by throwing an exception.

.N[
The topic is covered in more detail later, with exceptions, so the following
pages only try to alert the reader for the problems caused by throwing from
constructors and destructors.
]

---
template: plain
header: #### Throwing from Constructors

When a constructor cannot establish the object state expected by the client
(that created the object and caused the constructor to initialise it), the
preferred way is to throw an exception.

Often this is the easiest way

* for the constructor code (that may just throw) …
* … and the client, that may catch the problem at an adequate location.

The only thing to remember here is that destructors are not enabled before
the constructor ends normally,._[] hence partially created objects may required
to

* wrap the constructor code into a `try`-block and
* handle exceptions in a local `catch`-block,
* finally re-throwing them (if the object is not left in a usable state).

.F[:
This makes another good argument to use "self-contained" members, because then
the compiler does the appropriate clean-up, as for all fully constructed member
objects the destructor will be called when the construction of the containing
object fails with an exception.
]

---
template: plain
header: #### Throwing from Destructors

As – contrary to the constructor – the destructor usually just "cleans-up" and
may not so easily run into resource limitations, there is much lesser reason for
problems during destruction.

But the main problem is:

* Destructors are sometimes run during stack-unwinding after an exception has
  occurred.
* When a destructor then would throw (again), it is difficult to decide which
  exception should take priority.

Hence, when a destructor is run during stack-unwinding when handling an
exception an some destructor it `throw`-s (again) the program is terminated.._[]

.W[
Therefore the general rule is never to let an exception escape from a
destructor.
]

.F[:
A specific terminate handler for that case can be installed, but it may not
(portably) return to its caller and continue.
]

---
template: plain
name: ctor_reuse
header: ### Re-Using Constructors

C++11 has introduced two features to re-use code from existing
constructors:

* [Constructor Delegation](#ctor_delegation) and

* [Constructor Inheritance](#ctor_inheritance)

The former e.g. allows to have some few *"work-horse"* constructors that are
called from a number of *"convenience constructors"*.

The latter extends the possibility to *"import"* members from base classes
with a `using`-directive into a derived class to constructors.._[]

.F[:
It is not quite clear whether this was not allowed in C++98, maybe it was just
an oversight …
]

---
template: plain
name: ctor_delegation
header: #### Constructor Delegation

With this feature – new in C++11 – a constructor of a class can be implemented
in terms of (calls to) some other constructor:

* It works by calling the delegated-to constructor as part of the
  member-initialisation list of the delegating constructor.

* The delegating constructor must not have anything else besides the
  delegated-to constructor in its member initialisation list.

* Constructor delegation may be changed but must not be recursive.._[]

.F[:
According to the C++11 standard a program with recursive constructor delegation
is ill-formed and hence should not compile. But at least some older compilers
seem not to detect this but produce a core dump when run.
]

---
template: plain
header: ##### Constructor Delegation Example

In the example following the `FString` constructor taking a `const char *`
argument reuses the `FString` constructor taking an `std::size_t` argument
for memory allocation:
```
class FString {
    const std::size_t N;
    const char *data;
public:
    FString(std::size_t n) : N{n}, data{new char[N+1]} {
        data[0] = '\0';
    }
    FString(const char *init) : FString(std::strlen(init)) {
	std::strcpy(data, init);
    }
    ~FString() {
        delete[] data;
    }
    …
};
```

---
template: plain
header: ##### Constructor Delegation and Exceptions

There is a small but useful change with respect to the rules when a destructor
is enabled:

* This happens when the innermost (leaf-) constructor has reached its normal
  end.

* Therefore a constructor delegated-to should put the object

  * in a usable state – i.e. where all its invariants are established.

  * or at least provide a means by which the destructor can decide what has to
    be cleaned-up and what is not yet initialised at all.

.W[
It should be noted that it is (somewhat) against the spirit of C++-constructors
to leave objects in a "half-baked" state …._[]
]

.F[:
In general, if an object has constructors which are only used to delegate to and
which do **not** establish all the invariants a user may expect, these
constructors should probably not be `public` but `private` (or `protected` at
most and properly documented with respect to the remaining initialisations.
]

---
template: plain
name: ctor_inheritance
header: #### Constructor Inheritance

If the base class constructors also work for the derived class, in C++11 it may
be made visible in C++11 with a `using` directive:._[]
```
class Point {
protected:
    float x, y;
public:
    Point() : x(0.0), y(0.0) {}
    Point(float x_, float y_) : x(x_), y(y_) {}
    …
};
…
class MovablePoint : public Point {
public:
    using Point;
    void move(float dist_x, float dist_y) {
        x += dist_x;
        y += dist_y;
};
```

.F[:
Typically a derived class adds its own data members and therefore requires
extended initialisation, so it needs its own set of constructors.
]

---
template: plain
name: static_polymorphism
header: ## Static Polymorphism

--------------------------------------------------------------------------

* [Overloading Functions		](#overloading_functions)
* [Overloading Operators		](#overloading_operators)
* [Argument Default Values		](#default_arguments)
* [Overloading and Overriding		](#overloading_vs_overriding)

--------------------------------------------------------------------------

Argument default values were included here as their applicability overlaps
with function overloading, though – viewed from the hardware perspective –
for non-`inline` functions they are implemented quite differently.

---
template: plain
name: overloading_functions
header: ### Overloading Functions

Several functions may exist with the same name as long as they can be
distinguished by number and type of arguments._[]

```
void foo(const char *);         /*1*/
double foo(const int &, char);  /*2*/
double foo(double, double);     /*3*/
```
.N[
Which function will be called (or that the call is ambiguous) will be decided
from the arguments actually used.
]
```
int x; double y;
…
foo("hello, world");   /*calls 1*/
foo(42, 'z');          /*calls 2*/
foo(y, y/2);           /*calls 3*/
foo(x, y);             /*calls ?*/
```

.F[:
If one argument list is from left to right an exact subset of another one, the
overall effect is similar to default values for arguments. But with overloading
there are as many separate entry points as there are functions, while with
default arguments there is just one entry point and missing argument values are
automatically supplied.
]

---
template: plain
header: #### Overloading based on `const` and non-`const` Parameters

A `const` qualification in so far is part of the parameter type as it makes a
difference:
.pull-left[
**Continuing** the example from the previous page:
```
char data[100];
…
foo(data); /*1*/
```
]

.pull-right[
**Extending** this example:
```
void foo(char *); /*4*/
extern const char greet[];
…
foo(data);  /*4*/
foo(greet); /*1*/
```
]

If only one function (either the one with or the one without `const`) exists,
the effect is as follows:

* With **only** the function taking a `const char *` it will be used in **both**
  cases.._[]
* **Without** the function for a `const char *` the call with a non-modifiable
  argument (as `foo("hi")` in the example) **will fail to compile**.

.F[:
Clearly it is no problem to hand a modifiable memory location via pointer or
reference over to a function that promises **not** to change it, but **not vice
versa**!
]

---
template: plain
name: overloading_operators
header: ### Overloading Operators

[Boost.Operators]: http://www.boost.org/doc/libs/release/libs/utility/operators.htm

Operators may be overloaded by defining functions with a name that starts with
`operator`:

* The overload must take at least one operand of class type.._[]

* Most operators can be overloaded with either free functions or with member
  functions, i.e. either the left of the right hand operand needs to be of a
  class type.

* Some operators may only be overloaded with member functions; then the left
  hand operand must be of a class type.

* To consistently overload whole operator groups [Boost.Operators] may come in
  handy.

See also:

* http://en.cppreference.com/w/cpp/language/operators
* http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm

.F[:
Therefore the meaning of operators for built-in-types cannot be modified. If you
want to come close to the behaviour of a given built-in types but change or
remove some predefine operations you will typically have to **add** a new class
and implement all the operations it should support.
]

---
template: plain
header: #### Overloading Operators with Free Functions

In principle this needs to happen as follows:
```
MyClass operator+(const MyClass &lhs, const MyClass &rhs) {
    … // do whatever must be done
    return …;
}
```

The return type can be freely chosen - as long as the `return` statement is of
compatible type.

More exactly, the expression after `return` must

* either have the exact return type (`MyClass` in the example)
* or be convertible to that type.._[]

.F[:
See also [here](#brace_init_shorthand) for an interesting short-hand notation
possible with C++11 brace initialisers.
]

---
template: plain
header: #### Operator Overloading with Member Functions

In principle this needs to happen as follows:
```
MyClass &MyClass::operator+=(const MyClass &rhs) {
    … // do whatever must be done
    return *this;
}
```

Again the return type may be freely chosen.

.N[
According to what happens for built-in types, usually the object itself will be
returned
]

Typically that object is returned by reference (otherwise it weren't the object
but only a copy).with the modifications done by the operations

As technically a reference is just an address, this is

* performant (e.g. may use a register) and
* nearly free of any overhead if not used.._[]

.F[:
Also, for an optimizing compiler there is a fair chance to remove any remaining overhead …
]

---
template: plain
name: copy_ctor_assign
header: #### Overloading Copy Constructor and Assignment

[Rule Of Three]: http://en.cppreference.com/w/cpp/language/rule_of_three

For certain classes the following operations need to be overloaded, as the
compiler-generated default does the wrong thing:
```
class MyClass {
    T *some_ptr;
    …
public:
    …
    // avoid compiler defaults:
    MyClass(const MyClass& rhs);
    MyClass& operator=(const MyClass& rhs);
}
```

.N[
The classic indication are pointers as member data, referring to memory managed
by the instance.
]

.F[:
In C++ books this is often referred to as [Rule of Three] – the third member
function for which the default is not appropriate is the destructor, of course.
]

---
template: plain
name: move_ctor_assign
header: #### Overloading Move-Constructor and Assignment

[Rule Of Five]: http://en.cppreference.com/w/cpp/language/rule_of_three

[Rvalue References]: #rvalue_ref

C++ [Rvalue References] most often used to provide different implementations
for object construction and assignment.._[], depending on whether the right hand
operand denotes

* an object instance that will continue to exist after the operation, or
* temporary memory which will be destroyed afterwards (as is the case for an
  expression or function call).

```
class MyClass {
public:
    …
    // copy versions (rhs lives on in memory)
    MyClass(const MyClass& rhs);
    MyClass& operator=(const MyClass& rhs);
    // move versions (rhs destroyed soon after)
    MyClass(MyClass&& rhs);
    MyClass& operator=(MyClass&& rhs);
}
```

.F[:
Turning the classic C++ *Rule of Three* into the [Rule of Five] in C++11.
]

---
template: plain
name: move_ctor_assign
header: #### Implementing Move Construction and Assignment

After declaring move construction and assignment, they need to be implemented.

If copy construction looks as follows …
```
MyClass::MyClass(const MyClass &rhs)
    : …, some_ptr(new T(*rhs.some_ptr)), …    // cloning resource
{ … }
```

… this could be an adequate move construction:
```
MyClass::MyClass(MyClass &&rhs)
    : …, some_ptr(rhs.some_ptr), …    // taking over resource
{ …; rhs.some_ptr = nullptr; … }      // INVALIDATING it for rhs!
```

.N[
Assignment operations are similar but need to free `some_ptr` first..[]
]

.F[:
The general difference between constructor and assignment is that the former
gets just a piece of memory while the later finds a valid object that needs
to be properly de-constructed first.
]

---
template: plain
header: #### Distinguishing between Copy and Move

If both exists (copy and move), behaviour is as follows:._[]

```
MyClass foo() { return …; }  // … must be an expression of
                             // type MyClass (or something
                             // convertible to MyClass)
// constructor use:
MyClass a;        // (expects c'tor with no arguments)
MyClass b(a);     // copy c'tor (does not modify a)
MyClass c(foo()); // move c'tor (may modify temporary)

// assignment use:
a = c;            // copy assignment (does not modify c)
b = foo();        // move assignment (may modify temporary)
c = a + b;        // move assignment (may modify temporary
                  //                  returned from operator+)
```

.F[:
Of course, adding operands of type `MyClass` in the last line of the example
also assumes `operator+` exists and returns by value, as is the usual behaviour.
In the (unusual) case that operator were defined but returns something that C++
considers to be "more persistent" (like a reference), copy assignment would be
used instead, though a move could be enforced then: `c = std::move( … );`
]

---
template: plain
name: default_arguments
header: ### Argument Default Values

Arguments may take default values "from right to left", i.e.:

* As soon as one argument has a default value,
* all others following on the right must have one too.

.N[
The default value needs to be known where the function is called. Therefore it
is part of the declaration and – for functions shared between `.cpp` files –
needs to go into the header file.
]

As usual for declarations, argument names are optional:._[]

```
// the following function can be called with 1..3 arguments:
double foo(int &count, int minsize = 0, char separator = 'z');
…
// same as:
double foo(int &, int = 0, char = 'z');
```

.F[:
Using names for arguments in prototypes has pro's and con's: it is of course
more self-documenting but there is at least a remote chance for surprising and
**extremely hard to find** name clashes with preprocessor macros. Hint: view
preprocessor output (`g++ -E …`) whenever you get desperate because of an
completely unexplainable syntax error in your source code.
]

---
template: plain
name: overloading_vs_overriding
header: ### Overloading and Overriding

The above two terms are sometimes confused, though – if used precisely – they
have a well defined, different meaning:._[]

* *Overloading* means there are two (or more) functions with identically spelled
  function names but with different parameter lists so that the compiler can
  select one based on the actual call arguments.

* *Overriding* means that some class uses the same name for a member function
  that has already been used in one of its base classes.

As the usual translation for "overriding" to German is "überschreiben", by
sloppy back-translation sometimes the term "overwriting" has been introduced
as a synonym for "overriding".

.F[:
Disregarding the fact that an object in a member function call is syntactically
not part of the argument list (but goes to the left, separated with a dot), from
a purely technical perspective the object involved in the call is just another
argument and hence "under the hood" overloading and overriding are actually
related.
]

---
template: plain
name: overriding_example
header: #### Overriding Example (1)

In the following example there are three overloaded member functions `foo`:
```
class Base {
    …
    void foo(int);
    void foo(double);
    void foo(const char *);
    …
};
```

It are **all(!)** of the above that get overridden by a **single** member
function `foo` in a derived class:
```
class Derived : public Base {
    …
    void foo(double);
    …
};
```

---
template: plain
name: overriding_example
header: #### Overriding Example (2)

How the following calls are resolved sometimes even surprises seasoned C++
developers:
```
Base b;
b.foo(42);       // calls Base::foo(int) -- no surprise
b.foo(3.14);     // calls Base::foo(double) -- no surprise
b.foo("hello");  // calls Base::foo(const char *) -- no surprise
…
Derived d;
d.foo(3.14);     // calls overriding Derived::foo(double)
d.foo(42);       // as before(!) with type conversion of argument
d.foo("hello");  // ERROR (does not compile)
```

.W[
Especially if there are automatically applied type conversions (like above from
`int` to `double`) the problem might go unnoticed for a long time.
]

---
template: plain
name: overriding_and_using
header: #### Overriding and the `using` Directive

If a derived class shall inherit **all** overloads of its base class and then
**some** are selectively overridden, the `using` directive will help:
```
class Derived : public Base {
    …
    using Base::foo;
    void foo(double);
    …
};
…
Derived d;
d.foo(3.14);     // calls overriding Derived::foo(double)
d.foo(42);       // calls Base::foo(int) -- no surprise
d.foo("hello");  // calls Base::foo(const char *) -- no surprise
```

.W[
There might still be surprises in case of argument types that do not exactly
match and hence undergo a conversion.
]

Luckily many oversights falling into that category of problems will manifest
themselves in ambiguities and cause the compilation to fail.

---
template: plain
name: type_conversions
header: ## Type Compatibility and Conversions

--------------------------------------------------------------------------

* [Type Compatibility for Native Types		](#native_type_typeconv)
* [Type Compatibility and Inheritance 		](#public_base_typeconv)
* [Explicit Type Conversion by *Cast*		](#explicit_typeconv)
* [Class-Specific Type Conversions		](#specified_typeconv)
* [Achieving General Type Safety		](#general_typesafety)

--------------------------------------------------------------------------

---
template: plain
name: native_type_typeconv
header: ### Type Compatibility for Native Types

[Integer Types]: http://de.cppreference.com/w/cpp/language/types#Integer_types
[Floating Point Types]: http://de.cppreference.com/w/cpp/language/types#Floating_point_types

The most important rules for type compatibility among native types are:

* All *Arithmetic Types* – subsuming [Integer Types], [Floating Point Types],
  and `bool` – are compatible among each other and participate in automatic
  conversions as necessary, striving to preserve the value.._[]

.W[
Conversions between arithmetic types often require some code (machine
instructions) to be executed and hence are not completely "free".
]

.F[:
Of course, preserving the value has its limits like for conversions to types
with a smaller range of values (usually truncated) and especially when
converting to `bool` the result is `true` for non-zero values while – vice versa
`true` is converted to the value `1` (unambiguously).
]

---
template: plain
header: #### Type Compatibility for Native Types (2)

* The following conversions are **automatically** applied in one direction only:

  * Enumerations (`enum`) **→** Arithmetic Type;
  * Pointers **→** `bool` (all but `nullptr` is `true`);
  * Typed Pointer **→** Generic Pointers (`void *`).

* I.e. there are **no automatic conversions** reversing the above.

The last rule improves [General Type Safety of C++](#general_typesafety)
in a critical case._[]

.I[
Differently from C in C++ there can be no "silent" type conversion going from
a typed pointer to a generic pointer and back.
]

.F[:
The reason for that change is that according to C89 the `malloc` library
function (including its cousins `calloc` and `realloc`) return generic pointers,
the compiler is not aware of their special nature.
]

---
template: plain
name: public_base_typeconv
header: ### Type Compatibility and Inheritance

[Slicing]: http://www.geeksforgeeks.org/object-slicing-in-c/

* Pointers to publicly derived classes are automatically converted to pointers
  to direct or indirect._[] base classes, wherever necessary.

* References to publicly derived classes are automatically converted to
  references to direct or indirect._[] base classes, wherever necessary.

* **Objects** of a publicly derived class may be used to automatically
  initialise the members of their base class, called [Slicing].

.I[
Except for multiple inheritance the first two cases usually do **not** involve
execution of any machine instructions, hence are effectively "free".
]

.F[:
For indirect, non-virtual base classes in case of multiple inheritance with
diamond-shaped relation to a common base (annotated as "«disjoint»" in UML)
an automatic conversion would be ambiguous.
]

---
template: plain
name: public_base_lsp
header: #### Public Base Classes and the LSP

[Principle of Substitutibility]: http://dictionary.reference.com/browse/liskov+substitution+principle

The rules on the previous pages are the practical result of Barbara Liskov's

* "*[Principle of Substitutibility]*"

formulated once for "good object oriented software" and often abbreviated as
LSP since it was first expressed.

.N.center[
The LSP in C++ is only valid for public base classes!

**Only in this case it makes sense to talk about "Inheritance"** (in its common
meaning in OOP).
]

Inheritance._[] is also called *Generalisation-Specialisation* and in UML
denoted as solid line with a hollow triangle at the base class end.

.F[:
To be clear once more: what is discussed here is a class relation that implies
substitutability according to the LSP. As inheritance is at the heart of
object-oriented modelling and programming, it will be covered in more depth
later ([see Wednesday Part 1 Inheritance](05_wednesday1.html#inheritance)).
]

---
template: plain
name: private_base_no_lsp
header: #### Private Base Classes (no LSP)

Public and  private base classes in C++

* use the same memory layout, but

* **for private base classes there is no LSP**.

.N[
In the common meaning in OOP a private base class is not inheritance but
composition.
]

Composition is a special case of aggregation._[] and will be denoted in the UML
with a small black diamond at the aggregate side.

.F[:
The special case is that the lifetime of the *part* is coupled to that of the
aggregate. As composition is very important in object-oriented modelling and
there are various ways to implement it in C++, it will be covered in more depth
later ([see Wednesday Part 1 Aggregation](05_wednesday1.html#aggregation)).
]

---
template: plain
name: explicit_typeconv
header: ### Typ-Konvertierung mittels *Cast*

[Cast-Operation]: http://www.cplusplus.com/doc/tutorial/typecasting/

Mittels sogenannter [Cast-Operation]en lassen sich weitere Typ-Konvertierungen
erzwingen.

.W[
Die Cast-Syntax von C, bei welcher man den Zieltyp in runde Klammern einschließt
und den umzuwandelnden Wert direkt dahinter schreibt, sollte in C++ vermieden
werden.
]

Die neue Syntax beginnt mit einem der Schlüsselworte

* [`static_cast`](#static_cast_typeconv)
* [`dynamic_cast`](#dynamic_cast_typeconv)
* [`const_cast`](#const_cast_typeconv)
* [`reinterpret_cast`](#reinterpret_cast_typeconv)

Es folgen der Zieltyp in spitzen Klammern und der umzuwandelnde
Wert in runden Klammern.._[]

.F[:
As an example consider the use of C-style memory allocation for some `struct s`
in C++.
```
struct s *p = static_cast<struct s*>(std::malloc(sizeof (struct s))); // required conversion in C++
          … (struct s*) std::malloc(sizeof (struct s)); // C-style cast, possible but deprecated in C++

```
]

---
template: plain
name: static_cast_typeconv
header: #### Typ-Konvertierung mit `static_cast`

Hiermit lassen sich zum einen Typ-Konvertierungen explizit hervorheben, welche
der Compiler auch automatisch vorgenommen hätte.._[]

Darüberhinaus funktioniert der `static_cast` in **beide** Richtungen für
diejenigen Typ-Konvertierungen, welche **automatisch** nur in einer Richtung
eingesetzt werden:

* Arithmetische Wert **→** Aufzählungstypen (`enum`)

  * automatisch nur Aufzählungstypen in arithmetische Werte

* Generische Zeiger (`void *`) **→** typisierte Zeigern

  * automatisch nur typisierte in generische Zeiger

* Basisklassen in abgeleitete Klassen (Down-Cast)

  * automatisch nur abgeleitete Klassen **→** Basisklassen (Up-Cast)

.F[:
The most typical reason for this is that many compilers will issue a warning
when an arithmetic conversions might not be value preserving, e.g. when an
64-bit integral value is assigned to a 32 bit integral variable. If this is
done with a cast, most compilers will suppress the warning.
]

---
template: plain
name: dynamic_cast_typeconv
header: #### Typ-Konvertierung mit `dynamic_cast`

[`std::bad_cast`]:     http://en.cppreference.com/w/cpp/types/bad_cast
[Laufzeit-Typprüfung]: 04_wednesday2.html#dynamic_cast

Hiermit lassen sich ausschließlich Typ-Konvertierungen innerhalb von
Klassenhierarchien vornehmen.

.N[
Im Fall von Down-Casts findet zur Laufzeit eine Überprüfung mit Fehleranzeige
statt, wenn der Cast nicht durchführbar ist.._[]
]

Die Fehleranzeige besteht

* bei **Casts auf Zeigerbasis** in der Rückgabe eines Nullzeigers;

* bei **Casts auf Referenzbasis** in einer [`std::bad_cast`]-Exception.

Weiteres wird später im Rahmen der [Laufzeit-Typprüfung] (RTTI) behandelt.

.F[:
Der Grund für die eventuelle Undurchführbarkeit muss zusammen mit der
Typ-Kompatibilität zwischen Basisklassen und abgeleiteten Klassen gesehen
werden: Gemäß [LSP](#public_base_lsp) kann ein Zeiger oder eine Referenz, der
bzw. die als Zeiger oder Referenz für eine Basisklasse definiert ist, auch ein
Objekt einer davon abgeleiteten Klasse referenzieren. Ob dies der Fall ist,
lässt sich mit `dynamic_cast` überprüfen und mittels des auf diese Weise ggf.
erhaltenen Zeigers (bzw. der so erhaltenen Referenz) besteht schließlich
Zugriff auf die von der abgeleiteten Klasse hinzugefügten Member-Daten und
-Funktionen.
]

---
template: plain
name: const_cast
header: #### Typ-Konvertierung mit `const_cast`

Die hiermit möglichen Typ-Konvertierungen beschränken sich auf das

* Hinzufügen oder
* Wegnehmen

von `const` und `volatile`.

Alle anderen Unterschiede zwischen dem Zieltyp und dem Typ des umzuwandelnden
Ausdrucks führen zu einem Compile-Fehler.

.W[
Ein `const_cast` hat gemäß dem C++-Standard undefiniertes Verhalten, wenn er
dazu führt, dass auf eine mit Schreibschutz definierte Speicher-Adresse
schreibend zugegriffen wird.
]


Das typische Fehlerbild reicht von der inkonsistenten Wertverwendung (teilweise
alter Wert, teilweise neuer Wert) bis zum Programmabsturz …._[]

.F[:
Abhängig von der Testtiefe, dem verwendeten Compiler, Optimierungs-Optionen usw.
mag es allerdings auch so erscheinen, als würde alles wie gewünscht funktionieren.
]

---
template: plain
name: reinterpret_cast
header: #### Typ-Konvertierung mit `reinterpret_cast`

  [Boost.Variant]: http://www.boost.org/doc/libs/1_57_0/doc/html/variant.html

Dieses Konstrukt wird vor allem dazu eingesetzt, Zeiger auf (bekannte)
Hardware-Adressen zu setzen, wie das u.a. im Bereich der Embedded Programmierung
und bei Gerätetreibern notwendig sein kann.._[]

.F[:
Dass es per `reinterpret_cast` möglich ist, quasi jedes Bitmuster im Speicher
gemäß jedem beliebigen Typ zu interpretieren, führt mitunter zu der Kritik, C++
sei keine "sichere" Programmiersprache. Diese Kritik müsste dann aber für alle
Sprachen gelten, die ein zur C/C++ `union` vergleichbares Konstrukt besitzen …
(zumindest solange kein automatisches "type-tagging" wie bei [Boost.Variant]
erfolgt).
]

Darüber hinaus kann man mit einem `reinterpret_cast`

* **wie auch per `static_cast`** generische Zeiger (`void *`) in typisierte
  Zeiger umwandeln, und

* **anders als per `static_cast`** typisierte Zeiger **direkt** in anders
  typisierte Zeiger umwandeln.

.N[
Es ist dagegen auch mit `reinterpret_cast` nicht möglich, die `const`- und
`volatile`-Qualifizierung zu ändern – dies erlaubt nur der `const_cast`.
]

Um beide Konvertierungen zu kombinieren, müssen die jeweiligen Cast-Konstrukte
ggf. nacheinander (oder geschachtelt) verwendet werden.

---
template: plain
name: reinterpret_cast_examples1
header: #### Typ-Konvertierung mit `reinterpret_cast` (Beispiel 1)

Das folgende Beispiel nimmt an, dass an der Speicheradresse `0xEAD0` die als
`struct uart` beschriebenen Kontrollregister abgebildet sind:
```
struct uart *const sio = reinterpret_cast<struct uart*>(0xEAD0);
```
Der Zugriff kann nun in der Syntax `sio->…` erfolgen.

Gibt es mehrere solche Register-Strukturen im Speicher (als Memory-Mapped-I/O)
abgebildet, kann natürlich auch ein Array initialisiert
```
struct uart *const sio[] = {
    reinterpret_cast<struct uart*>(0xEAD0),
    reinterpret_cast<struct uart*>(0xEAD8),
    …
};
```
und über dieses mit `sio[0]->…`, `sio[1]->…` usw. zugegriffen werden.

.F[:
Wird statt dem Pfeil die Punkt-Notation bevorzugt, geht das auch, und zwar mit:
```
struct uart &sio = *reinterpret_cast<struct uart*>(0xEAD0);
```
]

---
template: plain
name: reinterpret_cast_examples2
header: #### Typ-Konvertierung mit `reinterpret_cast` (Beispiel 2)

  [C++ Calling Conventions]: 06_wednesday2.html#calling_conventions

Das folgende Beispiel nimmt an, dass an der Adresse `0xCAFE` im Code-Segment

* ein Unterprogramm (gemäß [C++ Calling Conventions]) steht,
* welches ein Argument vom Typ `bool` erwartet und
* keinen Rückgabewert liefert.

```
void (*xcall)(int) = reinterpret_cast<void (*)(int)>(0xCAFE);

```
Der tatsächliche Aufruf kann nun so erfolgen:
```
xcall(true);
…
xcall(false);
```
erfolgen.._[]

.F[:
Of course, if there is a value returned supplied (according to the C++ calling
conventions) and specified in the declaration, it could be accessed in the usual
way.
]

---
template: plain
name: specified_typeconv
header: ### Klassenspezifische Typ-Konvertierungen

Eine Klasse kann auch festlegen, wie ihre Objekte bei Bedarf automatisch **aus**
eingebauten Typen und anderen Klassen erzeugt bzw. **in** solche konvertiert
werden können. Dazu folgende Analogie:

* Jede Klasse und jeder eingebaute Typ hat eine spezifische Art von *Ein- und
  Ausgangs-Steckverbindern*, die nur "zu sich selbst" passt.

  * In Initialisierungen und Zuweisungen sind daher zunächst nur Objekte von
    genau dieser Klasse bzw. diesem Typ verwendbar.._[]

* **Konstruktoren mit exakt einem Argument** – sofern nicht als `explicit`
  markiert – sind weitere *Eingangs*-Steckverbinder.

  * Sie passen zum *Ausgangs*-Steckverbinder des Argument-Typs.

* **Typ-Cast-Operatoren** sind weitere *Ausgangs*-Steckverbinder.

  * Sie passen zum *Eingangs*-Steckverbinder des Ziel-Typs.

.F[:
If you like that picture you may include base class conversions by assuming
plugs and sockets with the same basic shape for class hierarchies, using code
pins to make the output connector of a derived class fit into the input connector
of its base class(es), but not vice versa. (For standard conversions of basic
types assume a set of adapter plugs that are applied as necessary.)
]

---
template: plain
name: constructor_conversion
header: #### Typ-Konvertierungen durch Konstruktoren

Konstruktoren sind dann automatische Typ-Konvertierungen, wenn sie

* genau ein Argument besitzen und
* **nicht** mit dem Schlüsselwort `explicit` markiert sind.

```
class MyClass {
    …
public:
    MyClass(int);  // each single argument c'tor is an
                   // automatic conversion ... except
    explicit MyClass(double);  // it is marked explicit
    …
};
```

---
template: plain
header: #### Anwendung von Konstruktoren zur Typ-Konvertierung

Typ-Konvertierungen durch Konstruktoren kommen wie folgt zur Anwendung:

```
void foo(MyClass);
…
foo(33);            // OK (automatic conversion by c'tor)
foo(3.3)            // ERROR, c'tor is explict
foo(MyClass{3.3});  // OK (c'tor is used explicitly)
…
MyClass x{-1};      // this would also work with explicit c'tor but ...
x = 33;             // ... here an automatic conversion is necessary ...
x = 3.3;            // ... so this will fail if there is none
```
.I[
Die Notwendigkeit einer Typ-Konvertierung bei der Zuweisung hängt auch davon
ab, welche (zusätzlichen) Zuweisungs-Operatoren eine Klasse ggf. definiert._[]
]

.F[:
An assignment operator taking **exactly** the type of the expression of its
right hand operand as argument will always be preferred (and of course applied
as there is no need for a conversion). In case the assignment operator takes a
`const MyClass&` argument a temporary will be created if a non-`explicit` c'tor
or a type-cast operator is available as automatic conversion.
]

---
template: plain
name: brace_init_shorthand
header: #### Brace Initialisers as Short-Hand Notation

In some contexts brace initialisation syntax may also be used as short-hand
notation for constructor calls, without naming the class:
```
class MyClass {
   …
   MyClass();
   MyClass(int);
   MyClass(const char*, double);
   …
};
…
void foo(MyClass);
foo({});               // foo(C{});
foo({42});             // foo(C{42});
…
MyClass bar() {
   …
   return {"hi", 3.14};   // return C{"hi", 3.14}
}
```

The only necessary precondition is that the constructors to be applied are not
`explicit`, their argument count does not matter.

---
template: plain
header: #### Temporäre Objekte im Rahmen der Typ-Konvertierung

Bei Referenzübergabe ist zusätzlich zu beachten, dass bei der
Konvertierung ein temporäres Objekt notwendig wird:
```
void baz(MyClass &); // non-const reference argument
…
baz(42);                       // ERROR (no automatic temporary
                               //        for non-const reference)
baz(MyClass(42));              // ERROR (c'tor call does not bind
                               //        to non-const reference)
{ MyClass tmp(42); baz(tmp); } // OK
```

Automatisch wird dies nur für `const`-qualifizierte Referenzen erzeugt:
```
void bar(const MyClass &); // const reference argument
…
bar(42);                       // OK (automatic temporary)
```

---
template: plain
name: typecast_operator
header: #### Typ-Konvertierung durch Type-Cast Operatoren

Type-Cast Operatoren benutzen eine spezielle Syntax, bei der **nach** dem
Schlüsselwort `operator` der Zieltyp folgt:._[]
```
class MyClass {
    …
public:
    // this is called type-cast operator:
    operator Other() const { …; return …; }
                                    // ^-- Other (or at least
                                    //     convertible to Other)

    // the usual explicit alternative:
    int to_int() const { …; return …; }
                                // ^-- int (or at least
                                //     convertible to int)
};
```

.F[:
Dieser stellt zugleich den Ergebnistyp dar, den die `return`-Anweisung liefern
muss.
]

---
template: plain
header: #### Automatische Anwendung von Type-Cast Operatoren

Die Typ-Konvertierungen von der vorhergehenden Seite kommen wie folgt zur Anwendung:
```
void foo(Other);
void bar(int);
…
MyClass m;
foo(m);           // OK, implicit use of type-cast operator
bar(m);           // ERROR (of course), but ...
bar(m.to_int());  // ... usual style for explicit conversion
```

---
template: plain
header: #### Special case: `explicit operator bool()`

Type conversions to `bool` marked `explicit` are a special case:

* They will **not** applied for conversion of general expressions, like argument
  coercion, initialisation, assignment,

* **but will be for boolean operations and in condition testing.**

The examples on the following page build on this:
```
class MyClass {
    …
public:
    explicit operator bool() {
       return …; // some bool
    }
    …
};
…
MyClass obj;
extern void foo(bool);
```

---
template: plain
header: #### Example: `explicit operator bool()`

The following code fragments extend the example from the previous page:

* `#1` shows an unusual but permitted form to call the type conversion to
  `bool`.
* `#2a` is an error as it is ambiguous, which is solved by some extra
  parentheses in `#2b`.
* `#3` is a permitted but unnecessary explicit type conversion.

.pull-left[
```
// this does NOT compile ...
foo(obj);

bool bv(obj);
bool bv(bool(obj));      //#2a
bv = obj;

if (obj == true) …
if (obj == false) …
if (obj == bv) …
// ... compare with code on
// the right for corrections

```
]
.pull-right[
```
// this solves the problems:
foo(bool(obj));
foo(obj.operator bool()); //#1

bool bv((bool(obj)));     //#2b
bv = bool(obj);
if (bool(obj)) …          //#3
if (obj) …
if (!obj) …
if (bool(obj) == bv) …
// boolean operators work too:
if (obj && !bv) …
```
]

---
template: plain
name: general_typesafety
header: ### Type Safety in C++

A practical consequence of the risks by explicit type conversions – i.e. the
four C++ style cast operations and the legacy C-style cast – is this:

.W[
All explicit type conversions (with casts) should be reduced to the
unavoidable minimum.
]

Furthermore, [class specific type conversions][#specified_typeconv) are
sometimes applied where not intended:._[]

.I[
Class specific type conversions should only be defined where a silent change
between these types is very frequent and considered "natural".
]

.F[:
Or to put it slightly different: Experience showed there are scenarios of
practical importance where a compile error would have been preferred over
the way the compiler made the code "correct" by applying a (non-explicit)
constructor or type-cast operator.
]

---
layout: false
template: plain
name: part2

# [C++ FOR](#agenda) (Part 2)

More C++-Basics (Templates, Exceptions, Library)

-------------------------------------------------------------------------------

1. [More C++11/14/… Extensions](#cpp11_14_extensions)
1. [Basics of Type Deduction](#cpp_type_deduction)
1. [Template Basics](#template_basics)
1. [Exception Basics](#exception_basics)
1. [Library Basics – Strings](#string_basics)
1. [Library Basics – I/O-Streams](#iostream_basics)

-------------------------------------------------------------------------------

---
template: plain
name: cpp11_14_extensions
header: ## More C++11/14 Extensions

--------------------------------------------------------------------------

* [Extensions to Literals		](#extension_to_literals)
* [Static Assertions 			](#static_assertions)
* [Explicit `nullptr` Value and Type	](#nullptr_and_nullptr_t)
* [Initialiser Lists			](#initialiser_lists)
* [`auto`-typed Variables (and Objects)	](#auto_typed_variables)
* [Trailing Return-Type Syntax		](#trailing_return_types)
* [Range (-based) `for`-Loops		](#range_based_for)
* [Alternative for Type Definitions	](#alternative_typedefs)

--------------------------------------------------------------------------

---
template: plain
name: extension_to_literals
header: ### Extensions to Writing Literals

C++11 extended the syntax for literals in various ways:

* Character and character string literals:
  * [UTF-8 and UTF-16 encoding can be requested](#utf8_utf16_char_enc)
  * [Quoting of special characters can be reduced](#raw_string_literals)

* Numeric literals:
  * [Readability can be improved by structuring](#num_literals_structure)
  * [Notation can be in binary](#binary_literal_notation)

* All kinds of literals:
  * [May take user defined suffixes](#user_defined_literals)

---
template: plain
name: utf8_utf16_char_enc
header: #### Specifying Encoding of Characters

Since C++11 characters and string literals can explicitly specify:

* UTF-8 encoding by the prefix `u8` (8 bit code units)
* UTF-16 encoding with the prefix `u` (16 bit code units).
* UTF-32 encoding with the prefix `U` (32 bit code units).

Note that the `L`-prefix from C++98 is implementation defined with respect to
code unit size (typically 16 bit on MS-Windows and 32 bit on Linux and most
other execution environments derived from Unix) and encoding.

.I[
For more information on prefixes to specify UTF encoding see:
http://en.cppreference.com/w/cpp/language/character_literal
http://en.cppreference.com/w/cpp/language/string_literal
]

.F[:
If the full code point space of UCS (with the uppermost limit at 0x10FFFF as set
by ISO/IEC10646) is used, a single code point may take up to four code units in
[UTF-8] and one or two code units in [UTF-16]. With [UTF-32] there is always a
1:1 mapping from between code points and code units – but not necessarily
between code points and user perceived characters! Only when the character set
is limited to [UCS-2] – which contains all of the basic multilingual plane
([BMP]) – there is a 1:1 mapping from code points to code units in [UTF-16] too.
(But again: code points are not necessarily user perceived characters!) As there
is currently **very limited support** in standard C++ for conversions between
encodings and other common operations on multilingual text, usually the (free)
[ICU-Library] is recommended for text-centric applications with serious needs
for internationalisation and appropriate localisation.
]

[BMP]: http://en.wikipedia.org/wiki/Plane_%28Unicode%29#Basic_Multilingual_Plane
[UTF-8]: http://en.wikipedia.org/wiki/UTF-8
[UTF-16]: http://en.wikipedia.org/wiki/UTF-16
[UTF-16]: http://en.wikipedia.org/wiki/UTF-32
[UCS-2]: http://en.wikipedia.org/wiki/UCS-2
[ICU-Library]: http://site.icu-project.org/

---
template: plain
name: raw_string_literals
header: #### Raw String Literals

The requirement to quote a number of special characters in string literals is
alleviated in C++11 with the introduction of raw string literals:
```
constexpr char text[] = R"(
… any content … no necessity for quoting here …
… no special interpretation of certain characters …
)"; // <-- except this end of raw string indicator
```

Also the end marker of raw string literals can be freely chosen and the prefix
may be combined with an UTF encoding specifier:
```
… u8R"!!end-of-text!!( … whatever … )!!end-of-text!!" …
```

The usual splicing of lines ending in a backslash will **not** happen in raw
string literals as the first and second of the [Phases of Translation] do not
apply to their content.

.I[
For more information on raw string literals see:
http://en.cppreference.com/w/cpp/language/string_literal
]
[Phases of Translation]: http://en.cppreference.com/w/cpp/language/translation_phases

---
template: plain
name: num_literals_structure
header: #### Structuring Numeric Literals for Readability

Since C++14 it is possible to write apostrophes inside numeric literals:
```
int x = 250'000;       // 250-thousand (250000)
int y = 12'500'000;    // 12-million 500-thousand (12500000)
int z = 1'500'000'000; // one and a half (US-) billion (1500000000)
                       // or: 1,5 Milliarden in German
auto t = 0.125'379'12; // if t is a time in seconds this would add
                       // up to: 125 milliseconds
                       //      + 379 microseconds
                       //      + 120 nanosecond (yes, 120!)
```

Note that apostrophes may be inserted anywhere in a numeric literal, not just to
separate groups of three or groups of the same length.

.I[
See also:
http://en.cppreference.com/w/cpp/language/integer_literal
http://en.cppreference.com/w/cpp/language/floating_literal
]

.F[:
It can be expected that this feature will confuse a number of editors or C++
IDEs with syntax-highlighting – until such are adapted. (This is possible
visible on this page, which uses a JavaScript-plugin for syntax highlighting,
that is not yet adapted to that feature at the time of writing this page.)
]

---
template: plain
name: binary_literal_notation
header: #### Numeric Literals in Binary Notation

C++14 introduced a syntax for binary literals, starting with `0b`:
```
… 0b101010 …                // same as: 052, or 42, or 0x2A
… 0b'00'1101'101'110101' …  // same as: 0x1B75
```

Interspersing apostrophs anywhere, like in the second example, might be used to
reflect a domain specific grouping of bits (2-4-3-6 in the example).

.I[
See also:
http://en.cppreference.com/w/cpp/language/integer_literal
]

---
template: plain
name: user_defined_literals
header: #### User Defined Literals

C++11 introduced a new form of operator overloading to allow user specific
suffix to numeric, character and string literals.

There are many possible uses, one is to provide readable, strongly typed units
for literals representing physical quantities.

C++14 applied that feature to provide a number of additional suffixes, e.g.._[]

* `"hello"s` – represents an object of type `const std::string` initialised
  with `hello`.

* `2.0i` – represents an object of type `std::complex` with the real part set
  to zero and the imaginary part set to two.

.I[
For more information see:
http://en.cppreference.com/w/cpp/language/user_literal
]

---
template: plain
header: #### User Defined Literals Example (1)

As a motivating example assume a class representing a length as a distinct type,
i.e. one that should not mix with ordinary (dimensionless) numbers.

The initial shot could look as follows:
```
class Length {
    long double metres;
    constexpr Length(long double m) : metres(m) {}
    …
};
```

Internally a `long double` is used to represents some length in metres, but to
avoid wrong assumptions on the user's side the constructor is private.

---
template: plain
header: #### User Defined Literals Example (2)

To create objects of this class it provides a number of helper functions:
```
class Length {
    …
public:
    static constexpr Length m(long double v) {
        return Length(v);
    }
    static constexpr Length km(long double v) {
        return Length(v*1000.0);
    }
    static constexpr Length mm(long double v) {
        return Length(v/1000.0);
    }
};
```

---
template: plain
header: #### User Defined Literals Example (3)

If the class also provides some output operation, like
```
#include <iostream>
…
class Length {
    …
    friend
    std::ostream &
    operator<<(std::ostream &lhs, const Length &rhs) {
        return lhs << rhs.metres << "m";
    }
}
```

the following small demo program should compile:
```
int main() {
    auto dtm = Length::km(385000);
    auto inch = Length::mm(25.4);
    std::cout << "Distance to moon is " << dtm << std::endl;
    std::cout << "One inch is " << inch << std::endl;
}
```

---
template: plain
header: #### User Defined Literals Example (4)

User defined literals would provide the following convenience:
```
auto dtm = 385000_km;
auto inch = 25.4_mm;
```

In the following implementation they delegate to a single helper
```
constexpr Length operator"" _km(unsigned long long v) {
    return Length::m(v*1000.0);
}
constexpr Length operator"" _mm(long double v) {
    return Length::m(v/1000.0);
}
```

so the other helpers are not any more necessary – even no helper at all
were necessary if the functions were turned into friends of `Length`.

---
template: plain
name: static_assertions
header: ### Static Assertions

C++11 introduced the compile time directive `static_assert` to allow for
tests that may terminate compilation, if some condition is not fulfilled.

C++1y will make the second argument of `static_assert` optional.

.I[
For more information on static assertions see:
http://en.cppreference.com/w/cpp/language/static_assert
]

---
template: plain
name: static_assertions
header: #### Static Assertion Example

Application for static assertions are manifold.

The following example shows how a user defined literal could check for a
certain properties of the value supplied, e.g. when only even numbers from
the range `1` to `1001` make sense:
```
MyClass operator"" _mysfx(unsigned long long v) {
    static_assert(1 <= v && v <= 1001, "value out of range");
    static_assert((v % 2) == 0, "only even numbers accepted");
    return {v}; // assuming MyClass has a non-explicit constructor
                // taking an argument of type unsigned long long
}
…
… 12_mysfx …     // OK
… 123_mysfx …    // ERROR (due to check with static assert)
… 12.3_mysfx …   // ERROR (because operator"" _mysfx()
                 //        expects an integral value)
```

---
template: plain
name: static_assertions
header: #### Static Assertion Recommendations

.N[

* If some erroneous condition can be checked at compile time, this is
  **always** preferable to a test at run time.

* Static assertions require expressions that can be evaluated at compile time,
  hence `constexpr` helper functions will often come in handy.

* To unlock the full potential of static assertions, be sure to get a good
  understanding of what is provided via the header file [`<type_traits>`].

]

[`<type_traits>`]: http://en.cppreference.com/w/cpp/header/type_traits

---
template: plain
name: nullptr_and_nullptr_t
header: ### Explicit `nullptr` Value and Type

C++11 introduced the new keyword `nullptr` of type `std::nullptr_t`._[]

* to denote a literal constant for an address,

* which will never be given to a valid

* variable of some built-in type or

* object of some class.

Before, either the preprocessor macro `NULL` or a literal `0` had to be used.

.I[
For more information on `nullptr` and `std::nullptr_t` see:
http://en.cppreference.com/w/cpp/language/nullptr and
http://en.cppreference.com/w/cpp/types/nullptr_t
]

.F[:
Other as for `void *`, **into which** any other pointer type will be converted
if necessary, the type `std::nullptr_t` which converts vice versa converts
**into** any other pointer type, but its only possible value is `nullptr`.
]

---
template: plain
header: #### `nullptr` Example (1)

The use of `nullptr` as an argument may help to resolve overloads (and avoid
surprises) in some cases like the following.

.pull-left[
Assume a function with overloads for integral values and char pointers:
```
…
void foo(int);
void foo(const char *);
…
```
]
.pull-right[
What is called here?
```
foo(NULL);
```
Here the intent is clear:
```
foo(0);
foo(nullptr);
```
]

Since `nullptr` is a keyword, it is available without any include file, but to
use `std::nullptr_t` the header `<cstddef>` has to be included.

---
template: plain
header: #### `nullptr` Example (2)

Even `nullptr` is not helpful if there are several overloads on pointers:
.pull-left[
```
…
void foo(void *);
void foo(const char *);
void foo(int *);
void foo(MyClass *);
…
```
]
.pull-right[
Given a number of overloads for different kinds of pointers as shown left, the
following call is ambiguous:
```
foo(nullptr);   // ambiguous
```
]

The solution is to cast the `nullptr` (or `0` or `NULL`) to the correct
type:._[]
```
foo(static_cast<int*>(nullptr)); // OK (in C++11, as nullptr used)
foo(static_cast<int*>(0));       // OK (in C++98 and C++11)
foo((int*)0);   // also OK (but C-style cast is deprecated in C++)
```

.F[:
If all the pointer overloads test for the `nullptr`-case – like it should be
expected for a wide interface in which the client may legally hand-over that
value – and if all react in the same way, an alternative were to add another
overload for `std__nullptr_t`
]

---
template: plain
name: nullptr_usage
header: #### Usage Recommendations for `nullptr`

.N[

* With `nullptr` there is little reason to stay with the classic
  alternatives.._[]

* Any use `0` or `NULL` in a pointer context can safely be changed to `nullptr`.

* Care has to be taken when `0` or `NULL` is explicitly casted to some pointer
  type.

* Some (but not all) of such usages will still require the use of a cast.
]

.W[
A `reinterpret_cast` on a `nullptr` (or `0` or `NULL`) should always be
looked-at with suspicion, as it just reuses the `bits and bytes` given to it
with a different interpretation.
]

.F[:
One exception were backward-compatibility to compilers not (yet) implementing
C++11.
]

---
template: plain
name: initialiser_lists
header: ### Initialiser Lists

As new type the template `std::initializer_list` has been introduced with C++11.

* Initializer lists may be used as argument to constructors to fill containers.

* The type of the contained initialisers may be

  * deduced from the call context and accordingly converted (if mapped to an
    `std::initializer_list<T>`-s with a known `T`), or

  * must at least be unique (if mapped to an `std::initializer_list<T>` with
    a dependant type `T`).

.I[
For more information on initialiser lists see:
http://en.cppreference.com/w/cpp/utility/initializer_list
]

---
template: plain
header: #### Initialiser List Example

A (hypothetical) class `Polygon` might be initialised as follows:._[]
```
#include <initializer_list>
…
class Polygon {
    std::vector<Point> points;
public:
    Polygon(std::initializer_list<Point> init) {
        std::copy(init.begin(), init.end(),
                  std::back_inserter(points));
   }
   …
};
…
Polygon drawing{ {Point{7, 12}, Point{3, 8}, Point{1, 5}} };
```

.F[:
Also the classic initialisation syntax may be used as long as the initialiser
list is enclosed in curly braces. (Also, as shown in the last line, the class
name `Point` may be omitted, but only with brace initialisers.)
```
   // alternatives to the above:
Polygon drawing = {Point{7, 12}, Point{3, 8}, Point{1, 5}};
Polygon drawing({Point{7, 12}, Point{3, 8}, Point{1, 5}});
Polygon drawing({Point(7, 12), Point(3, 8), Point(1, 5)});
Polygon drawing({ {7, 12}, {3, 8}, {1, 5} });
```
]

---
template: plain
header: #### Initialiser List Recommendations

.N[

* Initialiser lists allow more compact initialisation of container-like classes.

* Though they are not limited to that area, they might e.g. also be
  [used with range-`for`](#range_for_init_list).

* Aside from simple uses, as for (by-) value elements with copy initialisation,
  be aware of some limitations, like e.g.:._[]

  * Initialiser lists containing move-only types can still be handed over as
    function arguments via rvalue references …
  * … but elements from such lists cannot be move-out, only accessed in place.

]

.F[:
Also if some such limitations may not be obvious at the first glance, they have
a natural reason that becomes evident if alternative choices are considered.
]

---
template: plain
name: auto_typed_variables
header: ### `auto`-typed Variables and Objects

Instead of supplying the type in a definition of a variable or object, C++11
allows the use of the keyword `auto`.._[]

* There must be an initialising expression.

* The type of the definition is taken from that expression.

* If `auto` is used unadorned, then the type is the type of the initialising
  expression with `const`, `volatile` and references (`&`, `&&`) stripped away.

The type deduction rules for `auto` will be considered in more detail later.

.I[
For more information on `auto` as type specifier see:
http://en.cppreference.com/w/cpp/language/auto
]

.F[:
Actually this is a change of the meaning `auto` once had in C, which is to
request a stack-based variable with the option to omit the type and use the
default `int`. As types were not any more optional in C++ since long, the
new meaning cannot cause silent changes.
]

---
template: plain
name: auto_type_examples
header: #### Examples for `auto`-typed Variables (and Objects)

Though the main use cases for `auto` as type of a variable or object comes in
later examples (with more complex types), here are some trivial cases using
`auto` instead of an explicit type, which behave "like expected".

.pull-left[
Given the following definitions …
```
int a = 0;
long int b = 42;
const int &r = a;
const std::string s("hi");
```
]

.pull-right[
… `auto` may be used as shown:
```
// type of variable is:
auto u = 42LL;    /*1*/
auto v = 2*b;     /*2*/
auto w = r;       /*3*/
auto x = s;       /*4*/
auto y = "hi!";   /*5*/
auto z = nullptr; /*6*/
```
]

Types were not named on the right, in case you want try yourself :-) …._[]

.F[:
… here they are, in the order of appearance:

* `u` has type `long long`
* `v` has type `long`
* `w` has type `int` (plain `int`, no `const`, no reference)
* `x` has type `std::string` (no `const`)
* `y` has type `const char *`
* `z` has type `std::nullptr_t`
]

---
template: plain
name: auto_type_usage
header: #### Usage Recommendations for `auto`-typed Variables

.N[

* Advantages for simple types (like shown so far) are debatable.

* Some C++-Gurus nevertheless recommend to **always** prefer `auto`.._[]

* One obvious advantage is that it guarantees initialisation.

* If a specific type is required, it may also "go to the right" like in:
  `auto x = std::uint16_t{0xFFFF};`

* This makes code look more unique as the above is similar to e.g.:
  `auto p = new MyClass{"hi!", 3.14};`

]
.W[
Do not blindly change any use of typed variables to plain `auto`, as not
everybody may be familiar with how to specify types in literal initialisers.
Especially – for the moment – do not combine `auto` with brace initialisers.
]

.F[:
Here is a section from a video in which Herb Sutter gives his arguments why he
would prefer to see a change of customs … but also concedes to other experts to
have "the right to have a different opinion":
https://www.youtube.com/watch?feature=player_detailpage&v=xnqTKD8uD64#t=1704
]

---
template: plain
header: #### Intermezzo: `auto` and Brace Initialisation Corner Cases

.pull-left[

**Minimised Number of Rules**

The fewer the rules exist, the lesser is to learn and to remember.
All cases, from trivial to highly complicated, can be explained
with the given set, though the outcome is (sometimes) not the most
convenient.
]
.pull-right[

**Principle of Least Surprise**

If a feature "just works" in a way that meets the expectations of
"most users", then nothing at all is to be learned …  except – maybe – for
some dark corner cases, where it works not as expected.
]

For new features and their cooperation with each other the trade-off is
sometimes hard to make and an initial try may come out wrong:

.pull-left[
All below is currently deduced as `std::initializer_list`:
```
auto x{2, 3, 5};
auto x = {2, 3, 5};
auto y{42};
auto y = {42};
```
]
.pull-right[
Expected for C++1y and already implemented in some compilers:._[]
```
auto x{2, 3, 5}; // illegal
auto x = {2, 3, 5}; // list
auto y{42}; // deduced as int
auto y = {42}; // list
```
]

.F[:
Surely this does not minimise the number of rules … so does it at least avoid
surprises?
]

---
template: plain
header: #### Recommendations for `auto` and Brace Initialisation

The least to state is that brace initialisation in cooperation with `auto`
did probably not "simplify" learning C++, even if no legacy code were to be
maintained and all the "old" initialisation syntax could be forgotten.

.I[
For more information, especially when an why the rules do not produce the
expected behavior and therefore will probably change with C++1y (and are
already implemented in the new way in MS-VC++ and the upcoming releases
GCC 5.0) see:
http://arne-mertz.de/2015/02/type-deduction-and-braced-initializers/
]

For now the most easy to follow recommendation to avoid surprises in case of
brace initialisation and `auto`-typed variables is this:

.N[

* Do not combine `auto`-typed variables with brace initialisation.

]

---
template: plain
name: trailing_return_types
header: ### Trailing Return-Type Syntax

Since C++11 `auto` can also be used to specify the return type of a function
after its formal argument list, like in:
.pull-left[
```
const char *foo() {
    …
    return "hello, world";
}
```
]
.pull-right[
```
auto foo( … ) -> const char * {
    …
    return "hello, world";
}
```
]

In these simple examples an advantage is hard to see, but they will become
visible in later (more advanced) use cases.

.I[
For further coverage of leading and trailing return type syntax see:
http://en.cppreference.com/w/cpp/language/function
]

---
template: plain
name: trailing_return_types
header: #### Completely Omitted Return-Type

Since C++14 when replacing the leading return type of a function with `auto`,
the trailing return type may also be omitted in some cases.

If a function is only declared but not defined, the return type must be given:
```
auto foo() -> const char *; // trailing return type required
```

.pull-left[
Otherwise the return type is deduced if there is only a single return statement
or all return statements have the same type:
```
auto foo()
    …
    return "hello, world";
}
```
]
.pull-right[
More than one return statement and different types:
```
auto foo() -> const char * {
    if ( … )
        return nullptr;
    …
    return "hello, world";
}
```
]

---
template: plain
name: trailing_return_usage
header: #### Usage Recommendations for Trailing Return Types

.N[

* In many (simple) cases using the trailing return type syntax has no direct
  benefit.

* Instead it requires more typing and breaks with the familiar "look & feel" of
  function definitions.

* Nevertheless deciding to **require** the use of trailing return types – e.g.
  per local *Style Guide* – might help to produce a more consistent programming
  style … (on the long run, after most traditional usages are changed).

* Also be prepared for rejection by a substantial fraction of developers,
  clinging to traditional style (with various arguments).

]

.W[
Do **not omit** trailing return types completely unless you surely know you
will **never** have to compile in environments less recent than C++14.
]

---
template: plain
name: range_based_for
header: ### Range (-based) `for`-Loops

C++11 introduced a unified syntax to loop over all elements of a collection.

It looks similar to the classic `for`-Syntax, but  inside the parentheses
following the keyword `for`

* a place-holder variable

* is separated by a colon (`:`)

* from a collection.

Its use becomes usually obvious from some characteristic examples, like those
shown in the next pages, and also feels quite natural soon.

.I[
For more information on range-based loops (aka. "range-for") see:
http://en.cppreference.com/w/cpp/language/range-for
]

---
template: plain
header: #### Example: Range-For over Classic Array

Using range-`for` to read or modifying all elements in a classic array …
.pull-left[
```
int data[100];
… // fill with 100 values
```
]
.pull-right[
```
for (int e : data)
    … // sequentially read
      // values from data via e
…
for (int &v : data)
    … // sequentially modify
      // values from data via v
```
]
.pull-left[
… the code on the right side is equivalent to the code below, accessing all
elements of data one after the other by index …
```
for (int i = 0; i < 100; ++i) {
    int e = data[i];
    … // read data[i] via e
}
…
for (int i = 0; i < 100; ++i) {
    int &v = data[i];
    … // modify data[i] via v
}
```
]
.pull-right[
… or – more C-style – via pointer:._[]
```
for (int *p = data;
    p < data+100; ++p)
    … // read data via *p
…
for (int *p = data;
    p < data+100; ++p)
    … // modify data via *p
```
]

.F[:
Performance evaluations typically show neither version has an advantage over the
other.
]

---
template: plain
header: #### Example: Range-For over STL-Vector

One of the main advantages of range-`for` is its uniform syntax that applies to
STL containers too (below left) instead of classic iterator loop (right):
.pull-left[
```
std::vector<int> data;
… // fill with values
for (int e : data)
    … // read data values
      // via e
…
for (int &v : data)
    … // modify data values
      // via v
```

```
for (auto e : data)
   … // access via copy
for (const auto &e : data)
   … // access via reference
```
]
.pull-right[
```
typedef
vector<int>::iterator Iter;
for (Iter it = data.begin();
          it != data.end();
        ++it)
    … // access (read or
      // modify) data
      // values via *it
```
Also `auto` comes in handy as well for read-only (left) as for modifying
access (below):._[]

```
for (auto &e : data)
   … // access via reference
```
]

.F[:
Actually this will allow for modifying access only if `data´ is not
`const`-qualified, because otherwise the place-holder of the range-`for`
loop would be deduced as `const` reference!
]

---
template: plain
header: #### Example: Range-For over STL-Map

In case of an STL-Map the place-holder is in the range-`for` loop is a pair of
the maps key value-type … which might seem inconvenient to specifiy …
```
std::map<std::string, int> data:
… // fill with key-value pairs
for (std::pair<std::string, int> e : data)
    … // access key via e.first and
      // associated data via e.second
```
.pull-left[
… but again `auto` comes in handy:
```
for (const auto &e : data)
    … // access key via e.first
      // and associated data
      // read-only via e.second
```
]
.pull-right[
```
for (auto &e : data)
    … // access key via e.first
      // and associated data
      // modifiable via e.second
```
Note that the key is always non-modifiable!
]

---
template: plain
header: #### Example: Range-For over Non-Standard Containers

It is well possible to use range-`for` loops with non-standard containers
```
MyContainer data;
… // fill data with values
for (auto e : data) … // read (by copy) via e
for (const auto &e : data) … // read (efficiently) via e
for (auto &e : data) … // access modifiable via e
```

given one of the following helpers exist:._[]
.pull-left[
**Either:**
`MyContainer` provides (the standard STL container interface with) the
**member functions**:

* `… MyContainer::begin() …`
* `… MyContainer::end() …`.

]
.pull-right[
**Or:**
There are overloads with an argument of type `MyContainer` for the
**global functions**:

* `… begin(… MyContainer& …) …`
* `… end(… MyContainer& …) …`.

]

.F[:
In both cases the return type and some details of the argument transfer in case
of global functions are left unspecified here. But what is returned from these
functions must be equality-comparable (and eventually compare unequal if the
loop is expected terminate regularly) and there must be increment and
dereference operations for the returned type.
]

---
template: plain
name: range_for_init_list
header: #### Example: Range-For with Initialiser List

It is also possible to combine range-`for` with `std::initializer_list`-s:
```
enum class Color { Red, Blue, Green, Unspecified = -1 };
…
for (auto c : { Color::Red, Color::Blue, Color::Green }) {
    … // do something with c
}
```

If such lists (of all values of some enumeration type) are required in many
places, they may be specified as initialised constants, preferably close to the
definition of the enumeration, so that both can be easily maintained in
parallel.
```
enum class Color { Red, Blue, Green, Unspecified = -1 };
constexpr auto ALL_COLORS = { Color::Red, Color::Blue, Color::Green };
…
for (auto c : ALL_COLORS ) …
```

---
template: plain
header: #### Usage Recommendations for Range-`for` Loops

.N[

* Replacing typical iterator loops over containers with range-`for` usually
  causes no problems and will result in code that is more readable and easier to
  maintain.

* The same is often true for `std::for_each`, at least as long as a container is
  processed **completely**.

* For processing container sub-ranges `std::for_each` is still useful.

* Non-standard containers should **strongly consider** to provide the interface
  required by range-`for` to iterate over their content.

]
.W[
Efficiency problems may result if some container holds large objects which are
not cheap to copy and the place-holder in a range-`for` loop is not specified as
reference.._[]
]

.F[:
The recommendation for *generic code* is to use `auto&&` because this will
always give optimal results. On the other hand, `auto&&` is a language construct
which should not be carelessly (i.e. without really understanding the
implications).
]

---
template: plain
name: alternative_typedefs
header: ### Alternative for Type Definitions

There is a completely new way to specify a type alias in C++11.

Its syntax is._[]

* the keyword `using` followed by
* the new type name
* an equals sign
* some existing type.

The whole construct may also be specified as a template, requiring (one or
more) instantiation types when used.

.I[
For more information on *type aliases* see:
http://en.cppreference.com/w/cpp/language/type_alias
]

.F[:
Since long `typedef` is a feature of C and hence became part of C++ too. Though,
looking closely, its syntax seems not straight-forward compared to the usual
assignment syntax, as the new "name" that gets an existing type as "value" is
on the right.
]

---
template: plain
header: #### New C++11 Type Aliases Example (1)

How to use the feature becomes quickly obvious from a few examples:._[]
```
using counter_type = int;
using MyDataContainerType = std::vector<int>;
using named_counter_t = std::map<std::string, counter_type>;
```

.N.center[
The new names are aliases (only).
]

Especially they do not constitute new types on which overloading were possible,
i.e.  the semantics are the same as for `typedef`.

---
template: plain
header: #### New C++11 Type Aliases Example (2)

Often local type definitions or aliases may help to make code more readable.

The `typedef` may look more familiar as everybody knows it …

```
typedef map<std::string, unsigned long>::iterator MapIterator;
for (MapIterator it = data.begin(); it != data.end(); ++it)
    …
```
… but aliases with `using` may appears more natural, as the new identifier being
defined goes to the left and what it stands for to the right.._[]

```
using MapIterator = map<std::string, unsigned long>::iterator;
for (MapIterator it = data.begin(); it != data.end(); ++it)
    …
```
}

.F[:
It is probably because the switched around positions of the new type name and
what it is aliased to, together with the equals sign that makes it easy see the
role of each part, what makes the new syntax with `using` better readable.
]

---
template: plain
header: #### New C++11 Type Aliases Example (3)

A particularly convincing example for the improved readability is this:

* A pointer to a function
* taking an argument list of
  * a pointer to non-modifiable characters and
  * an integer
* returning a result of type `bool`.

Usual C style (up to C++98):
```
typedef bool (*MyFuncPtr)(const char *, int);
```
With C++11 type aliases:
```
using MyFuncPtr = bool (*)(const char *, int);
```

---
template: plain
header: #### New C++11 Type Aliases Example (3)

An additional advantage of the new syntax is that it allows to be templated:._[]
```
template<typename CounterType>
using NamedCounters = std::map<std::string, CounterType>;
```

It also allows for default arguments, but an empty angle bracket remains if the
default is to be used (and no other template arguments remain).
```
template<typename CounterType = long long>
using NamedCounters = std::map<std::string, CounterType>;
…
NamedCounters<> counters;
```

.F[:
By using the new type aliases in C++14 (in addition to) the classic style in
which [Type Traits] were made available in C++11, a lot of (ugly and seemingly
redundant) `typename` …`::type` constructs can be simplified, as the following
are equivalent:

* … `typename std::enable_if<(N > 0), typename std::add_lvalue_reference<T>::type>::type` …
* … `std::enable_if_t<(N > 0), std::add_reference_t<T>>` …
]

[Type Traits]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3655.pdf

---
template: plain
name: trailing_return_usage
header: #### Usage Recommendations for C++11 Type Aliases

.N[

* As type aliases in C++11 style are much more readable there is little reason
  not to use them.

* As they have block scope introducing an alias with an expressive name can
  make (closely following) code easier understandable.

* Templated type aliases allow elegant solutions for a number of problems that
  formerly required more effort, like derived classes with a certain amount
  of duplicated code.

* Beyond the definition syntax nothing new needs to be learned since the
  semantics of C++11 type aliases are identical to `typedef`-s.
]
.W[
Identical semantics also means that C++11 type aliases do not constitute types
of their own, so **overloading will not work** for different aliases mapping to
the same underlying type.
]

---
template: plain
name: cpp_type_deduction
header: ## Basics of Type Deduction

-------------------------------------------------------------------------------

* [Type Deduction – Why and Where?		](#reasons_for_type_deduction)

* [Type Deduction for `auto` Variables		](#auto_type_deduction)

* [Type Deduction for Templates			](#template_type_deduction)

* [More Type Deduction Scenarios		](#more_type_deduction)

-------------------------------------------------------------------------------

These chapter centrally introduces into type deduction so that this topic is
not sprinkled through the other parts, where type deduction occurs.


---
template: plain
name: reasons_for_type_deduction
header: ### Type Deduction … Why and Where

There are several places where type deduction is done by the compiler. Some have
to do with convenience, but most have to do with [Generic Programming], which is
the C++ solution to the following observation:

* Some code, especially reusable code designated for a library, only differs in
  types, not in algorithm.

* Code duplication can not be the solution, as it violates the [DRY-Principle].

* To weave together generic code and the places of its use with specific types,
  the compiler needs to carry out type deductions.

.N[
The latter may seem – and are – trivial in simple cases but can also become
quite complicated, because the underlying rules try too guarantee an outcome
according to *what the users (of generic code) expect (in their special use
case*.
]

[Generic Programming]: http://en.wikipedia.org/wiki/Generic_programming
[DRY-Principle]: http://de.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself

---
template: plain
name: auto_type_deduction
header: ### Type Deduction for `auto`-Variables

Using `auto` as type was introduced into C++11 mainly as a convenience
feature._[], though in the meantime using `auto` on a regular base becomes
part of some style recommendations.

The basic rules, how the type is deduced from the initialising expression,
differs between the unadorned use and possible declarators like `*`, `&`, `&&`
(pointer, reference) and qualifiers like `const` or `volatile`, e.g.:
```
auto x = …        // any initialising expression
auto *p = …       // initialiser must denote an address
const auto &r = … // initialiser must be an lvalue but
                  // access does not allow modifications
```

.I[
For an exhaustive summary of `auto` type deduction rules see:
http://en.cppreference.com/w/cpp/language/auto (and maybe follow the
[link to Other contexts](http://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts)
in section 1 of Explanations)
]

---
template: plain
header: #### Type Deduction unadorned `auto`

The rules follow the prevailing user expectations._[] that `const` will not get
part of the type of the defined variable
```
auto x = 42; // x is type int (NOT const int)
auto y = 0L; // y is type long (NOT const long)
```
despite the fact that `42` and `0L` are both literals and hence constant.

This logically extends to `const` qualified names and references used as
initialising expressions
```
const unsigned int MAX = 1000;
…
auto limit = MAX; // limit is type unsigned int (NOT const)
```
where the `const` qualifier does **not** propagate from `MAX` as initialiser
into the type deduced for `auto`.

.F[:
Alternatively the reasoning about why these rules make sense can be built on the
argument that the alternative – carrying over `const`-ness into the type deduced
by `auto` – would make that feature much less useful: you may much more often
need variables initialised with a value from a constant, as you need (another)
name for an existing constant.
]

---
template: plain
header: #### Type Deduction `auto` and References

With respect to references there is a difference between

 * an initialising expression of reference type, and
 * a reference declarator as part of the `auto` type.

```
int s;
int &r;
…
auto x = r;   // x is int (NOT int reference)
auto& y = s;  // y is reference to int (and s needs to be an lvalue)
auto& z = r;  // z is reference to int (and r needs to be an lvalue)
```

Again the rules meet the user expectations, especially for `y` and `z` which
of course need to be references as to expect from the involved declarator (`&`).

Furthermore, in case of `auto&` it makes sense to carry over `const`-ness into
the deduced type:
```
const int s2 = -1;
…
auto& z2 = s2; // s2 is reference to const int
```

---
template: plain
header: #### Type Deduction for `auto` with Adornments

If a variable type is to be deduced automatically and it is not plain `auto`

* the adornments to `auto` get part of the deduced type,
* the type of the initialising expression may be limited accordingly, and
* `const` qualifiers from the initialiser become part of the deduced type.

.pull-left[
Given existing variables (below) used to initialise `auto` typed variables (right):
```
int a;
const int b = 20;
```
If you want to try yourself … ._[]
]

.pull-right[
```
const auto v = a;    /*1*/
auto *p1 = &a;       /*2*/
auto *p2 = &b;       /*3*/
const auto *p3 = &a; /*4*/
auto &r1 = a;        /*5*/
auto &r2 = b;        /*6*/
const auto &r3 = a;  /*7*/
```
]

.F[:
… the result is:

* `/*1*/` is `const int`
* `/*2*/` is pointer to `int`
* `/*3*/` is pointer to `const int`
* `/*4*/` is pointer to `const int` (even though `a` is not `const`)
* `/*5*/` is reference to `int`
* `/*6*/` is reference to `const int`
* `/*7*/` is reference to `const int` (even though `a` is not `const`)
]

---
template: plain
name: template_type_deduction
header: ### Type Deduction for Templates

Before `auto` was introduced to derived the type of a variable from the
initialising expression with C++11, there was already a set of type deduction
rules in C++98, used in case of template function parameters:._[]
```
template<typename T> void foo(T arg) { … }
template<typename T> void bar(T &ref) { … }
template<typename T> void bar(const T *ptr) { … }
```

In this case a type were to be deduced from the call argument.

.I[
For an exhaustive summary of template argument type deduction rules see:
http:[//en.cppreference.com/w/cpp/… …/language/template_argument_deduction]
]
[//en.cppreference.com/w/cpp/… …/language/template_argument_deduction]: http://en.cppreference.com/w/cpp/language/template_argument_deduction

.F[:
In fact, as templates are much older, their type deduction rules were used to
guided the rules for `auto`, but there are although subtle differences.
]

---
template: plain
header: #### Template Type Deduction Example (1)

.pull-left[
Assuming the template functions from the previous page and given existing
variables (as below) valid calls might look like on the right:
```
int a;
const int b = 20;
```
]

.pull-right[
```
foo(12);  /*1*/
foo(a);   /*2*/
foo(b);   /*3*/
bar(a);   /*4*/
bar(b);   /*5*/
baz(&a);  /*6*/
baz(&b);  /*7*/
```
]

The key point to understand here is that actually two types are deduced:

* The type formally represented by `T` and
* the type of the argument (`arg`, `ref`, or `ptr`).

Again, if you want to try yourself … ._[]

.F[:
… the result is:

* `/*1*/` to `/*3*/` `T` and `arg` is type `int` (call by value)
* `/*4*/` `T` is type `int` and `ref` is type reference for `int`
* `/*5*/` `T` is type `const int` and `ref` is type reference for `int`
* `/*6*/` `T` is type `int` and `ptr` is type pointer to `const int`
* `/*7*/` `T` is type `int` and `ptr` is type pointer to `const int`

Make sure you did not overlooked the different use of `const` in the  definitions of `bar` and `baz`!
]

---
template: plain
header: #### Template Type Deduction Example (2)

In case it is not obvious so far, template typed deduction may look "deeply"
into an argument definition to find the templated type and hence will also
manage deduce `T` in the following examples:
```
#include <cstdlib> // for extern int std::atoi(const char[]);
#include <vector>
…
std::vector<double> data;
…
template<typename T1, typename T2>
void foo(T1 (*f)(const char *), std::vector<T2> &c);
…
foo(std::atoi, data);   // f is poiner to function
                        //   - taking a const char * argument
                        //   - and returning an int
                        // c is reference to std::vector<double>
                        // hence:  T1 is int and T2 is double
```

Surely it would be nice if the type deduction as far as stated in the comments
of the above example could be "proven" somehow …._[]

.F[:
… though this can be tricky with the standard instruments of C++. For more
convenience [Boost.Typeindex] may be used.
]

[Boost.Typeindex]: http://www.boost.org/doc/libs/1_58_0/doc/html/boost_typeindex.html

---
template: plain
header: #### Template Type Deduction Example (3)

Templated types are also deduced if they occur more than once in the argument
list:._[]
```
template<typename T>
void bar(T (*)(const char *), std::vector<T> &c);
…
bar(std::atof, data);   // f is poiner to function
                        //   - taking a const char * argument
                        //   - and returning a double
                        // c is reference to std::vector<double>
                        // hence:  T is double
bar(std::atoi, data);   // ERROR (T cannot be both, int and double)
```

.F[:
Sometimes the problem may be subtle, but can be recognized (and solved) with a
systematic analysis, like in the example below:
```
   // which change will make the following code compile?
template<typename T> void baz(T &val, std::vector<T> &c);
…
std::vector<double> data;
const double PI = 3.14152;
baz(PI, data);
```
]

---
template: plain
name: more_type_deduction
header: ### More Type Deduction Scenarios

Besides the type deduction scenarios introduced here, there are some more:

.pull-left[
**Introduced with C++11 was:**

* `decltype`
* perfect forwarding
* lambda captures and returns
]

.pull-right[
**C++14 added some more:**

* `decltype(auto)`
* lambda init captures
* function return values
]

These use similar basic rule sets but with some variations._[] and will be
covered – as far as necessary – in an adequate later chapters.

.N[
For most C++ developers it is not necessary to become the ultimate specialist
for type deduction, as – especially in the simple cases – everything works
as expected …
]

.F[:
… thus opening the door for confusion. A good starting point to delve deeper
into the topic of type deduction is the following video lecture by Scott Meyers:
https://vimeo.com/97344493
]

---
template: linkinfo
graphic: ParametrizedTypesAndSizes
name: template_basics
header: ## Template Basics

-------------------------------------------------------------------------------

* [Parametrized Types and …			](#parametrized_types)

* [… Compile-Time Constants …			](#parametrized_constants)

* [… Demonstrated with a `RingBuffer` Example	](#example_ringbuffer)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: ParametrizedTypesAndSizes
section: Parametrizing Type
name: parametrized_types
header: ### Parametrized Types

C++-Templates were designed with the original intent to reduce mostly identical
**source code** when different variants of a class or (member) function only
differ in data types.

* The function or class will take a formal type parameter list in angle
  brackets,

* introducing **symbolic names** to the compiler that represent types which
  will later be specified concretely.

.N[
The symbolic type names may be used anywhere in declarations and in the
implementation of the class, where a type is syntactically permitted.
]

When instantiating a **class template** concrete types need to be named at the
corresponding position in the angle brackets while for a **function template**
such types are often visible (and deduced) from the types of arguments given by
the caller.

.F[:
Each name is preceded by the keyword `class` or `typename`, which may be used
interchangeably with the same meaning. (But note that the two keywords have
different meanings elsewhere.)
]

---
template: withinfo
graphic: ParametrizedTypesAndSizes
section: Parametrizing Size
name: parametrized_constants
header: ### Parametrized Compile-Time Constants

Besides types a template class or functions may also parametrize compile-time
constants.

For that purpose

* the function or class will take a formal value parameter list in angle
  brackets,

* introducing **types and symbolic names** to the compiler that represent
  constants of their given type.

.N[
The symbolic names may be used anywhere in the class implementation (usually
following) where syntactically a constant of the given type is permitted.
]

When instantiating a (class or function) template concrete constants need to be
named at the corresponding positions in the angle brackets.._[]

.F[
The usual automatic type converions take place as necessary – e.g. between
arithmetic types.
]

---
template: withinfo
graphic: ParametrizedTypesAndSizes
section: Parametrizing Type and Size
name: example_ringbuffer
header: ### Example `RingBuffer`

Turning `RingBuffer`-class originally implemented with given (fixed) type and
size into a template is straight forward,as it boils down to some rather
systematic "find and replace":

* This is especially true as `double` occurs in the source only where the (now)
  parametrized type symbol `T` needs to appear.

* The constant `11` specifies (in the original code) the maximum number of
  elements in the `RingBuffer` **plus one!**._[]

  * From the perspective of the `RingBuffer`-s user it makes more sense to
    supply the net size `N` (number of elements that can actually be held).

  * This can be easily achieved by replacing each occurence of `11` (in the
    original code) with `(N+1)` (in the template).

.F[:
So that the *empty* and *full* state can be easily discerned without an
additional flag, the buffer never gets completely filled but a single element is
always left unused, if the position into which to "put" is directly behind the
position from which to "get".
]

---
template: linkinfo
graphic: ExceptionBasics
name: exception_basics
header: ## Exception Basics

-------------------------------------------------------------------------------

* [Hierarchical Exception Classes		](#exception_hierarchies)

-------------------------------------------------------------------------------

* [Flow of Control with and without Exceptions	](#exception_flowcontrol)

-------------------------------------------------------------------------------

* [Understandig Exception Classes as Labels	](#exception_as_label)
* [Grouping Related Exceptions 			](#exception_grouping)
* [Activating Re-Entry Points			](#exception_try_block)

-------------------------------------------------------------------------------

* [Re-Throwing Exceptions			](#exception_rethrow)
* [Catching Any Exception			](#exception_catchall)

---
template: withinfo
graphic: ExceptionBasics
section: Exception Class Hierarchies
name: exception_hierarchies
header: ### Hierarchien von Exception-Klassen

[`std::exception`]: http://en.cppreference.com/w/cpp/error/exception
[`std::logic_error`]: http://en.cppreference.com/w/cpp/error/logic_error
[`std::logic_error`]: http://en.cppreference.com/w/cpp/error/runtime_error

Exceptions thrown by library functions build a class hierarchy:

* The common base is the class [`std::exception`].

* Derived from this are the following two which may also be a good choice to
  extend the hierarchy for specific purposes:

  * [`std::logic_error`]

  * [`std::runtime_error`]

---
template: withinfo
graphic: ExceptionBasics
section: Execution Path taken for Exception
name: exception_flowcontrol
header: ### Flow of Control with and without Exceptions

When no exceptions are thrown, flow of control is as usual:

.N[
If the end of a `try`-block is reached, all subsequent `catch`-blocks are
skipped over.
]

Insofar behaviour is analogous to an `if`-block which skips all subsequent
`else if` and the final `else, when the condition (of the first `if`) holds
true.

---
template: withinfo
graphic: ExceptionBasics
section: Exception Classes Viewed as Labels
name: exception_as_label
header: ### Understanding Exception Classes as Labels

When a `throw`-statement is executed, all the `catch`-blocks after an active
`try`-block are like labels, i.e.:

.N[
Control flow always **branches back** (removing stack frames) into the direction
of the main function.
]

* A `catch`-block is chosen

  * according to the dynamic nesting of function calls, **and**

  * **top - down** among all `catch`-blocks subsequent to an active `try`-block.

* The selected `catch`-Block is the first one with an exception type compatible
  to the exception thrown.

* If there is no such `catch`-block, the next active `try`-blocks (closer to the
  main function) is considered.

* If none is found down to the main function program execution stops.

---
template: withinfo
graphic: ExceptionBasics
section: Grouping Exceptions
name: exception_grouping
header: ### Grouping Related Exceptions

Compatibility of the exception thrown and the exception named in a `catch`-block
is – with respect to automatic conversions that may be applied – decided in the
same way as for arguments on function calls:

* Especially the LSP is effective, i.e. publicly derived classes are compatible
  with (any of) their base classes.

* Therefore class hierarchies make sense for exceptions too, as related
  exceptions then may (optionally) be caught in a common `catch`-block.

.N[
Even in the parentheses following `catch` make the construct look like a
function argument list, having the control flow branch back to a `catch`-block
is different from a function calls
]

Rather `catch`-blocks are points for re-entry into a still active function.._[]

.F[:
It is rather some kind of special return into the control flow of the (still)
active function with the (once) active `try`-Block. But there are even more
similarities to a function and a parameter specification, not only that the
usual type conversions take place, but also with respect to `const` and value or
reference access to the exception object thrown. Finally, two requirements
imposed syntactically are that there must always be exactly one "argument" and
that a `catch`-block must always be written as block, so even if it contains
exactly one statement the curly braces may not be omitted.
]

---
template: withinfo
graphic: ExceptionBasics
section: Enabling Handler Blocks
name: exception_try_block
header: ### Activating Re-Entry Points

A `try`-Block becomes active as soon as the control flow reaches the first contained
statement.

.N[
Targets for branching-back in case of an exception throw are only `catch`-blocks
following active `try`-blocks.
]

A `try`-Block is not any longer active after it is left by

* `return`._[]
* `break`
* `continue`

or when last contained statement has completed execution.

.N[
The `catch`-blocks following this `try`-block are not any longer considered as
targets for thrown exceptions.
]

.F[:
If a value is returned, evaluation of an expression may be part of the return.
The evaluation itself takes place while technically still in the active
`try`-block. But when the function has returned and its return value is only
used – say in another copy c'tor outside the function that has returned – the
function's `try`-block is not active any more and hence the `catch`-blocks
following it are not any more possible targets.
]

---
template: withinfo
graphic: ExceptionBasics
section: Re-throw Exceptions
name: exception_rethrow
header: ### Re-Throwing Exceptions

It is not unusual that a `catch`-blocks may only partially resolve the problem
indicated by an exception thrown. Then the exception must be re-thrown from that
`catch`-block.
```
    try {
        …
        … // code that may throw SomeException (no matter if
        … // directly, or indirectly from a function called)
        …
    }
    catch (SomeException &ex) {
        …
        … // (assuming partial recovery only)
        …
        throw;
    }
}
```

.N[
The use of `throw;` is not limited to `catch`-blocks. Instead it may also be
part of a function called.._[]
]

.F[
This may make sense if several `catch`-blocks end with a large common part which
is delegated to a single function.
]

---
template: withinfo
graphic: ExceptionBasics
section: Catch Any Exception
name: exception_catchall
header: ### Catching Any Exception

It is possible to specify a `catch`-block to match any exception:

* In the parentheses (analogous to variadic functions) three dots need to be
  specified.

* If present, such a block must be the last of all `catch`-blocks following some
  `try`-block.._[]

.F[:
This is not syntactically enforced but as "`...`" catches any exception and the
`catch`-blocks are considered as label-like targets top down, it will otherwise
catch thing for which a specific `catch`-block follows.
]

```
int main() {
    try {
        …
        …
    }
    catch (...) {
        std::cerr << "!! unhandled exception !!\n";
    }
}
```

---
template: linkinfo
graphic: StringBasics
name: string_basics
header: ## Library-Basics – Strings

-------------------------------------------------------------------------------

* [Klassen (Übersicht)				](#stdstring_classes)
* [Kompatibilität zu C				](#stdstring_c_compatibility)
* [Effizienz-Betrachtungen			](#stdstring_efficiency)
* [Optionales "Copy On Write"			](#stdstring_cow)

-------------------------------------------------------------------------------

* [Grundlegende Operationen			](#stdstring_basicops)
* [Weitere Operationen im Überblick		](#stdstring_moreops)
* [Umwandlung von/in arithmetische Werte	](#stdstring_numconv)
* [Ein- und Ausgabe                    		](#stdstring_io)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: StringBasics
section: Classes
name: stdstring_classes
header: ### Classes (Overview)

The classes for character strings `std::string` and `std::wstring` from C++98
were augmented in C++11 with `std::u16string` und `std::u32string`. These are
just type definitions like the following:._[]
```
namespace std {
    typedef basic_string<char> string;      // since C++98
    typedef basic_string<wchar_t> wstring;  // since C++98
    typedef basic_string<char16_t> wstring; // since C++11
    typedef basic_string<char32_t> wstring; // since C++11
}
```

.I[
For more details refer to
http://en.cppreference.com/w/string/
]

.F[:
The type definitions show only half of the truth: other template arguments are a
character traits class and an allocator (memory management policy). Both have
been omitted in the example as they do not change the essential point to make.
]

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_c_compatibility
header: ### Compatibility with C

[Small Buffer Optimisation (SBO)]: https://akrzemi1.wordpress.com/2014/04/14/common-optimizations/

The class `std::_basic_string` stores characters of a string in contiguous._[]
memory, which has at least the required size, but often is allocated with some
extra space.

The internal representation frequently is via three pointers:

* The address of the first contained character.

* The address of the last (valid) character.

* The address to mark the end of allocated memory (usually one character beyond)

Also on 64-bit architectures (and for strings of 8-bit wide characters)
[Small Buffer Optimisation (SBO)] is common.

.N[
From the viewpoint of a C++ application dealing with the character strings based
on the standard string classes there is no restriction to which characters can
be contained (like it is in C where `'\0'` ends the string).
]

.F[:
The C++98 standard left it to the library implementors whether to chose
contiguous or non-contiguous storage, though that freedom is – at least in
effect – removed in C++11.
]

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_cstr_use
header: #### Using `std::string` as `const char *`

A C-API expecting a C-style string – for example as name of a file – needs
an address (of the first character) and `'\0'` termination (to mark the end).

The necessary adaption is done by the `c_str()` member function:
```
std::string filename;
…
… // get file name from user (or elsewhere)
…
// open file for reading, using the C-API
FILE *fp = std::fopen(filename.c_str(), "r");
```

The above code is **correct and bears no risk**, as the pointer returned by
`c_str()` (or the memory reachable via it)

* is accessed only **inside** `std::fopen`, this

* does not modify the variable `filename`, and

* therefore any possible heap allocation will not change.

.F[:
If the mode to open the file came from an `std::string` too, of course it needs
to be converted similarily like that:
`… std::fopen( … , openmode.c_str()) …`
]

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_cstr_risk
header: #### Risks of Using `c_str()`

It should be understood that using `c_str()`._[] that the memory area
accessible via the returned pointer will have a valid content **only** up to the
the next modifying operation of the underlying string object.

.pull-left[
```
std::string s("see me, ");
const char *p = s.c_str();
s += std::string("feel me,");
…
s.append(" touch me, hear me");
…
```
]

.pull-right[
```
const char *mammamia() {
    std::string local;
    …
    return local.data();  // as
    // of C++11 same as c_str()
}
```
]

The above code has a **high potential risk** to access invalid
memory, allocated for quite a different purpose than to store the characters of
the string it once held.

.F[:
In the example on the right hand side, dereferencing the pointer returned from
the function will access deallocated heap memory (once owned by `local`) with
near to 100% certainty.
]

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_cstr
header: #### Using `const char *` as `std::string`

Turning a classic C-string into an `std::string` object is always automatic,
as it happens as type conversion by a (non-`explicit`) constructor.

.N[
The easiest way to make functions callable with both, `std::string` objects
**and** classic C strings is to use an argument of type `const std::string&`.
]

In terms of the code to be written it will be much more work to provide a number
of overloads._[], e.g. for

* `const char *`,
* `const std::string &`, and
* (maybe) `std::string &&`.

bereitzustellen.._[]
.F[:
On the other hand, each version could then be optimized for its argument type.
]

---
template: withinfo
graphic: StringBasics
section: Efficiency
name: stdstring_efficiency
header: ### Efficiency Considerations

[Small String Optimisation]: http://john-ahlgren.blogspot.de/2012/03/small-string-optimization-and-move.html

Typical measures to improve efficiency of `std::string`-s are:

* Allocating some excess memory at the end.

* Proportionally enlarging the allocation (not a constant number of extra
  characters).

* Especially on 64-Bit hardware: [Small String Optimisation]

.F[:
Proportional here means that when the current allocation doesn't suffice any
more it will be doubled (or made 1.5 or 1.8 times as large). This gives O(1)
performance to algorithms that fill a long character string by appending
single characters to the end. Increasing the allocation by a constant, fixed
amount would yield much worse O(N<sup>2</sup>) performance.
]

---
template: withinfo
graphic: StringBasics
section: May or May not Have COW-Implementation
name: stdstring_cow
header: ### Optional "Copy On Write"

[Copy On Write (COW)]: http://www.gotw.ca/publications/optimizations.htm

This optimisation will especially improve code that hands over `std::string`
objects by value (instead of `const std::string&`).

* Copying the string content will not happen right away:._[]

  * Instead a flag is set to mark the string content as shared, and
  * actually copying the content only if a modification takes place.

* As long as in the shared state only there is only non-modifying access
  to the string content, nothing more needs to happen.

.N[
If a (shared) instance ends its life-time without any modification to the
string content, no copying ever needs to take place.
]

.F[:
[Copy On Write (COW)] "optimisations" have shown substantial disadvantages in
multi-threaded environments: the expected performance improvement often is more
then outweighed by necessary locking mechanisms to guarantee exclusive access of
only one single thread.
]

---
template: withinfo
graphic: StringBasics
section: Basic Operations
name: stdstring_basicops

header: ### Basic Operations

Most of these are intuitive, like

* Assignment with `=`,

* Comparision with `==`, `!=` etc.

* Concatenation with `+` and

* Element Access with `[…]`.

and hence cause never problems

.N[
Code not extremely performance relevant should consider to use `at()` instead of
`operator[]` to avoid undefined behavior in case of out-of-bounds access.
]

---
template: withinfo
graphic: StringBasics
section: Advanced Operations
name: stdstring_moreops
header: ### Overview of More Operations

It is fully intended to model `std::string` with a close resemblance to
`std::vector<char>`. Especially:

* Also `std::string` has the usual iterator interface,
* making it compatible with all STL algorithms of interest (besides member and
  free functions dealing with the class itself).

It may be a matter of experience – and to slight degree a matter of taste –
what kind of coding style is more comprehensible:

The following fragment reads an `std::string s` from standard input and checks
if it contains nothing else but white-space before further processing.

```
// with std::string member function
if (std::getline(std::cin, s)
 && s.find_first_not_of(" \t") == std::string::npos)) …

// with STL algorithm (and predicate specified as lambda)
if (std::getline(std::cin, s)
 && !std::all_of(s.begin(), s.end(),
                 [](char c) { return (c == ' ' || c == '\t'); })) …
```

---
template: withinfo
graphic: StringBasics
section: Numeric Conversions
name: stdstring_numconv
header: ### Converting between `std::string` and Arithmetic Types

Conversions between character sequences and native arithmetic types (`int`,
`unsigned`, `long`, … `double`) is a frequent necessity.

Often unnecessary complicated, cumbersome, and hence error prone code is used:
```
std::string tmpfilename; // fixed part, followed by sequence number
…
char *cp = const_cast<char*>(tmpfilename.c_str());
while (*cp && !std::isdigit(*cp))
    ++cp;                       // locate first digit
const int num = std::atoi(cp);  // convert digit sequence to int
std::sprintf(cp, "%d", num+1);  // and store back incremented by 1
```

.F[:
If not obvious from reviewing the code, the fragment above has the following
problems:
**1.** `std::atoi` converts up to the first non-numeric character only (hence a
missing numeric part will not be recognized – though in some cases this might be
rather a feature than a bug).
**2.** Some else's memory might be silently overwritten if at `cp` not enough
space is available for storing `num` incremented.

]

---
template: plain
name: stdstring_str2num
header: #### Convert `std::string` into Arithmetic Type

C++11 has introduced a new set of functions:

* The naming scheme is `std::stoXX` for `s`tring `to` with a letter code
* `XX` according to the following table:

| Letter Code     | Conversion to        | (based on)      |
|:---------------:|:---------------------|:----------------|
| `i`             | `int`                | `std::strtol`   |
| `l`             | `long`               | `std::strtol`   |
| `ll`            | `long long`          | `std::strtoll`  |
| `ul`            | `unsigned long`      | `std::stroul`   |
| `ull`           | `unsigned long long` | `std::strtoull` |
| `f`             | `float`              | `std::strtod`   |
| `d`             | `double`             | `std::strtod`   |
| `ld`            | `long double`        | `std::strtold`  |

.I[
For more information see:
http://en.cppreference.com/w/cpp/string/basic_string/stol,
http://en.cppreference.com/w/cpp/string/basic_string/stoul, and
http://en.cppreference.com/w/cpp/string/basic_string/stof.
]

---
template: plain
name: stdstring_num2str
header: #### Create `std::string` from Arithmetic Type

To convert arithmetic types into `std::string` C++11 introduced a number of
overloads for the (free) function `std::to_string`:

Use is trivial and probably obvious together with the functoin `std::stoull`
introduced on the previous page:
```
std::string tmpfilename; // fixed part followed by sequence number
…
const auto n1 = tmpfilename.find_first_of("0123456789");
assert(n1 != std::string::npos);
const auto n2 = tmpfilename.find_first_not_of("0123456789", n1+1);
std::size_t nx;
const auto num = std::stou(tmpfilename.substr(n1, n2), &nx);
assert(nx == n2-n1);
tmpfilename = tmpfilename.substr(0, n1)
            + std::to_string(num+1)
            + tmpfilename.substr(n2);
```

---
template: withinfo
graphic: StringBasics
section: Input and Output
name: stdstring_io
header: ### Input and Output

Output of character strings is usually done with an overload of `operator<<`,
sometime even called "output operator":._[]
```
std::string greet{"hello, world"};
…
std::cout << greet;
```

.N[
Note that the result for strings containing embedded `'\0'` characters might not
be what is expected (depending on the expectation :-)).
]

.F[:
Of course, this is not a specific operator for output but an overload to the
left-shift operator (as introduced in C), when the left-hand operand is an
output stream. Nevertheless, especially when C is used outside the realm of
embedded programming, some call `operator<<` now *output operator*.
]

---
template: withinfo
graphic: StringBasics
section: Input and Output
name: stdstring_in_word
header: #### Reading with `operator>>`

[White Space]: http://de.wikipedia.org/wiki/Leerraum

The overloaded `operator>>` for `std::string`-s reads words by word:
```
std::string word;
while (std::cin >> word) …
```

Words are separated by arbitrary [White Space], usually (at least) the
characters for:

* Line Feed (`'\n'`)
* Space (`' '`), and
* horizontal / vertical Tabulators (`'\t'` and `'\v'`).

.N[
When reading `std::string`-s with `operator>>` usually no empty lines can be
recognized, as any line feed characters are silently skipped as white space.
]

---
template: withinfo
graphic: StringBasics
section: Input and Output
name: stdstring_in_word
header: #### Reading with `std::getline`

Input into `std::string` can also be read by line …
```
std::string line;
… std::getline(std::cin, line) …
```

… or upto an arbitrary delimiter character:
```
std::string field;
… std::getline(std::cin, field, ':') …
```

.N[
Flexibility of the above is limited as **exactly one** delimiter character may
be specified.
]

It is not possible to specify a set of alternative delimiters – e.g. full
stop, comma, and semicolon.._[]

.F[:
While a small helper function accepting a set of delimiters shouldn't be that
hard to write, this kind and much more sophisticated parsing of input patterns
is possible with [Regular Expressions]. After having been available through
[Boost.Regex] for a long time – regular expressions became part of the C++11
standard library (see http://en.cppreference.com/w/cpp/regex/basic_regex).
]

[Boost.Regex]: http://www.boost.org/doc/libs/release/libs/regex/doc/html/index.html
[Regular Expressions]: http://en.wikipedia.org/wiki/Regular_expression

---
template: linkinfo
graphic: IOStreamBasics
name: iostream_basics
header: ## Library-Basics – I/O-Streams

-------------------------------------------------------------------------------

* [Front-End and … 	](#iostream_frontend)
* [… Back-End 		](#iostream_backend)

-------------------------------------------------------------------------------

* [I/O-State (Bits) 	](#iostream_statebits)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: iostream_frontend
header: ### I/O-Stream Front-End

The I/O-Stream Front-End consists of

* the base class `std::ios`._[] with some common defintions

* derived from it classes `std::istream` und `std::ostream` which are typically
  used as reference arguments to parametrise I/O-streams for functions called,

* and the following classes meant to be instantiated:

  * `std::ifstream`, `std::ofstream`, and `std::fstream` (File-Streams)
  * `std::istringstream`, `std::ostringstream`, and `std::stringstream`
     (String-Streams).

.F[:
As with `std::string` the architecture is even more generic and the "classes"
above are rather `typedef`-s for more generic template classes, which are
parametrized not only in a character type but also in some other respects. This
fact need not be made prominently visible if the focus is on explaining the
relationship between the classes participating in the design – as it is the
case here.
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: io_streams
header: #### Common Interface

Operations for stream input and output are partially implemented as member
functions of classes `std::istream` and `std::ostream`, partially as free
standing functions.

.N[
More overloads of `operator>>` and `operator<<` may be added to support user
defined data types.
]

Such overloads can only have the form of free functions (as otherwise new
member functions would have to be added to `std::istream` and `std::ostream`).

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_ios
http://en.cppreference.com/w/cpp/io/basic_istream
http://en.cppreference.com/w/cpp/io/basic_ostream
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: io_filestreams
header: #### File Streams

The various file stream classes are used depending on the I/O direction:

* `std::ifstream` for reading
* `std::ofstream` for writing
* `std::fstream` for reading and writing._[]

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_fstream
http://en.cppreference.com/w/cpp/io/basic_ifstream
http://en.cppreference.com/w/cpp/io/basic_ofstream
]

.F[:
Note that in this case read and write positions in the stream are independent of
each other and – depending on the task at hand – may or may not need explicit
synchronisation.
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: io_stringstreams
header: #### String Streams

The various file stream classes are used depending on the I/O direction:

* `std::istringstream` for reading
* `std::ostringstream` for writing
* `std::stringstream` for reading and writing._[]

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_stringstream
http://en.cppreference.com/w/cpp/io/basic_istringstream
http://en.cppreference.com/w/cpp/io/basic_ostringstream
]

.F[:
Note that in this case read and write positions in the stream are independent of
each other and – depending on the task at hand – may or may not need explicit
synchronisation.
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Streams Back-End
name: iostream_backend
header: ### I/O-Stream Back-End

The main responsibility of the I/O-Stream back-end is abstraction and buffering
(in case file streams).

Buffering allows to

* transmit data between internal memory and external storage in optimised block
  sizes,
* while the application has any freedom in which portions data is consumed or
  produced.
]

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_streambuf
http://en.cppreference.com/w/cpp/io/basic_filebuf
http://en.cppreference.com/w/cpp/io/basic_stringbuf
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Stream State-Bits
name: iostream_statebits
header: ### Zustands-Bits der I/O-Streams

Jeder Stream besitzt eine Reihe von Zustandsbits.

* Ist keines gesetzt ist, befindet sich der Stream im *good*-Zustand.

* Bei im Rahmen der Eingabe eines bestimmten Daten-Typs *unerwarteten (also
  nicht zu verarbeitenden)* Zeichen wird das `std::ios::failbit` gesetzt.

* Tritt im Rahmen der Eingabe die *End-Of-File*-Bedingung ein, wird das
  `std::ios::eofbit` gesetzt.

* Bei anderen – vom Standard nicht näher spezifizierten – Fehlerbedingungen kann
  auch das `std::ios::badbit` gesetzt werden.._[]

.F[:
The usual difference between setting the *fail*- or *bad*-bit is that in the
latter case there is often no (portable) way to recover, while in the former any
unexpected input causing the state-switch might simply be skipped.
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Streams State-Bits
name: iostream_statebits
header: #### State-Dependent I/O-Stream Behaviour

As soon as an I/O-stream leaves the *good*-state (i.e. if any of its state bits
gets set), further operations with that stream are ignored **except for `clear()`
and `close()`**.

This has especially to be considered for a more detailed analysis of
(unexpected) input:

* Any state change leaves the current position in the stream **prior to** the
  character causing the problem.
* Input not adhering to the expected format (usually determined by the data type
  to be read with `operator>>`) – e.g. if a letter occurs where a digit is
  expected – input is processed **up to but not including** the unexpected
  character.

To skip over (at least) this character,

* **first** the stream must be put in the *good*-state, only
* **then** an operation like `ignore` will work.

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_ios/clear
http://en.cppreference.com/w/cpp/io/basic_istream/ignore
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Streams State-Bits
name: iostream_statebits
header: #### Exceptions on State Change

Individually for each stream and state it can be chosen that an exception is
thrown for any

* **change to** that state (i.e. setting the corresponding state bit) and
* attempted operation **while in** that state.

```
// Excerpt from a hypothetical "forever running" TCP-Client
std::ifstream from_server;
… // establish connection through TCP/IP-Socket
from_server.exceptions(std::ios::badbit
                     | std::ios::eofbit
                     | std::ios::failbit);
try {
    for (;;) {
        std::string command_string;
        std::getline(from_server, command_string);
        … // process command_string
    } /*notreached*/
}
catch (std::ios_base::failure &e) {
    … // socket connection closed and/or data transfer failed
}
```
---
layout: false
template: blank
name: part3

# [C++ FOR](#agenda) (Part 3)

Containers and Iterator Basics

-------------------------------------------------------------------------------

1. [Sequenzielle Container	](#sequence_containers)
1. [Iterator-Grundlagen 	](#iterator_basics)
1. [Assoziative Container	](#associative_containers)
1. [Iterator-Details 		](#iterator_details)
1. [Praktikum			](#exercise_tue1)

-------------------------------------------------------------------------------

---
template: linkinfo
graphic: STL-SequenceContainers
name: sequence_containers
header: ## Sequenzielle Container

-------------------------------------------------------------------------------

* [Zusammenhängender Speicher		](#stl_vector)

-------------------------------------------------------------------------------

* [Doppelt verkettete Liste und …	](#stl_list)
* [… einfach verkettete._[]		](#stl_forward_list)

-------------------------------------------------------------------------------

* [Double-Ended Queue (Deque)		](#stl_deque)

-------------------------------------------------------------------------------

.F[:
Kein Bestandteil von C++98 sondern erst mit C++11 verfügbar.
]

---
template: withinfo
graphic: STL-SequenceContainers
section: Contiguous Storage Space
name: stl_vector
header: ### Zusammenhängender Speicher

Die grundlegende Datenstruktur ist hier ein Stück zusammenhängender Speicher.

Dieser wird – typischerweise zuzüglich etwas Reserve – auf dem Heap angelegt.

Ein Objekt der Klasse `std::vector` besitzt in der typischen Implementierung drei
(private) Daten-Member:._[]

.F[:
As the implementation is not dictated by the C++ standard, it is free to chose
whatever it sees fit, but usually an `std::vector` uses three pointers, holding
the address of the whole storage area, the begin of free space after elements
contained in the vector, and the next address after the allocated space.
]

* Anfangsadresse im Heap-Speicher
* Größe des benutzten Bereichs
* Größe der Gesamt-Reservierung

Links zur ausführlichen Online-Dokumentation:

* http://en.cppreference.com/w/cpp/container/vector
* http://www.cplusplus.com/reference/vector/

---
template: plain
header: #### Vorteile eines `std::vector`

Effizient unterstützt werden:

* Elemente einfügen und entnehmen **am Ende**
* Wahlfreier Zugriff (mit oder ohne Indexprüfung)
* Move-Konstruktor und -Assignment
* Vertauschung (*swap*) zweier `std::vector`-Inhalte

.N[
Die Speicheranforderung auf Vorrat macht den inkrementellen Aufbau eines
`std::vector` durch vielfaches Anfügen ebenfalls relativ effizient.._[]
]

.F[:
Crucial here is to increase space proportionally, i.e. if the pre-allocated size
is filled completely, the next element to store will extend memory allocation by
some constant factor, not a constant number of elements. In the latter case
runtime behaviour would have O(N<sup>2</sup>) performance, while the former
gives amortized O(1).
]

#### Einschränkungen eines `std::vector`

* Kein (effizientes) Einfügen und Entnehmen an verschiedenen Enden

* Kein effizientes Einfügen und Entnehmen in der Mitte

* Aufwändige Weitergabe als Wert (bzw. Wertkopie)

---
template: withinfo
graphic: STL-SequenceContainers
section: Double Linked List
name: stl_list
header: ### Doppelt verkettete Listen

Die grundlegende Datenstruktur sind einzelne Abschnitte im Heap-Speicher
(typisch einer pro Element), welche untereinander durch Vor- und Rückwärts-Zeiger
verbunden sind.

Ein Objekt der Klasse `std::list` besitzt in der typischen Implementierung drei
(private) Daten-Member:

* je ein Zeiger auf das erste und …
* … das letzte enthaltene Element,._[] sowie
* eine Ganzzahl welche die Anzahl der Elemente angibt.

.F[:
An empty `std::list` can simply use `nullptr`-s for both (or might leave the
pointers uninitialised and check the list's size member before each access).
]

Links zur ausführlichen Online-Dokumentation:

* http://en.cppreference.com/w/cpp/container/list
* http://www.cplusplus.com/reference/list/

---
template: plain
header: #### Vorteile einer `std::list`

Effizient unterstützt werden:

* Elemente einfügen und entnehmen **am Anfang und am Ende**
* Einfügen und Entnehmen auch in der Mitte._[]
* Move-Konstruktor und -Assignment
* Vertauschung (*swap*) zweier `std::list`-Inhalte

.F[:
Vorausgesetzt wird dabei, dass per Iterator bereits die Position bestimmt wurde,
in deren näherer Umgebung Elemente oder komplette Listen eingefügt oder entnommen
werden sollen.
]

#### Einschränkungen einer `std::list`

* Kein wahlfreier Zugriff

* Aufwändige Weitergabe als Wert (bzw. Wertkopie)

.N[
Die doppelt verkettete Liste tendiert zu einem hohen Overhead für den
**Speicherbedarf pro Element** – um so mehr, je weniger Platz die Nutzdaten
benötigen (wegen typischerweise notwendigem Alignment bis hin zum 24-fachen bei
`char`-Elementen und einer 64-Bit-Hardware).
]

---
template: withinfo
graphic: STL-SequenceContainers
section: Singly Linked List
name: stl_forward_list
header: ### Einfach verkettete Listen

Ein im Rahmen von C++11 hinzugefügter, auf minimalen Overhead ausgelegter
Container mit der grundlegenden Datenstruktur einer einfach verketteten Liste,
deren Elemente wiederum auf dem Heap angelegt werden.

Ein Objekt der Klasse `std::forward_list` besitzt in der typischen
Implementierung genau ein (privates) Daten-Member:

* Zeiger auf das erste enthaltene Element._[]

.F[:
An empty `std::forward_list` needs to use a `nullptr` (or maybe some other address
that can be unmistakeably recognized as not being a list member address).
]

.N[
Die Anzahl der Elemente einer `std::forward_list` wird nicht gezählt (anders als
bei der `std::list`).
]

Links zur ausführlichen Online-Dokumentation:

* http://en.cppreference.com/w/cpp/container/forward_list
* http://www.cplusplus.com/reference/forward_list/

---
template: plain
header: #### Vorteile einer `std::forward_list`

Effizient unterstützt werden:

* Elemente einfügen und entnehmen **am Anfang**
* Einfügen und Entnehmen auch in der Mitte._[]
* Move-Konstruktor und -Assignment
* Vertauschung (*swap*) zweier `std::forward_list`-Inhalte

.F[:
Vorausgesetzt wird dabei, dass per Iterator bereits die Position bestimmt wurde,
hinter der (direkt oder in näherer Umgebung) Elemente eingefügt oder entnommen
werden sollen.
]

.N[
Das Einfügen und Entnehmen in der Mitte hat eine im Vergleich mit den anderen
sequenziellen Containern ungewöhnliche Semantik, die am Namen der Operationen
deutlich wird: `insert_after` und `erase_after`
]

#### Einschränkungen einer `std::forward_list`

* Kein wahlfreier Zugriff

* Kein (effizientes) Einfügen und Entnehmen an verschiedenen Enden

* Aufwändige Weitergabe als Wert (bzw. Wertkopie)

---
template: withinfo
graphic: STL-SequenceContainers
section: Double-Ended Queue
name: stl_deque
header: ### Deque

Hierbei handelt es sich quasi um einen "in Abschnitte zerstückelten" `std::vector`,
welcher grob zusammengefasst sich wie folgt vom `std::vector` unterscheidet:

* Keine Garantie, dass **alle** Elemente in zusammenhängendem Speicher
  aufeinander folgen.._[]

* Elemente können an **beiden** Enden eingefügt und entnommen werden.

* Wahlfreier Zugriff ist möglich und nur geringfügig weniger performant.

.N[
Anders als ein `std::vector` kann eine `std::deque` Basis für eine
FIFO-Speicherung (Warteschlange) sein, ist aber nicht als Schnittstelle
zu Legacy-Code nutzbar, der ein klassisches (eingebautes) Array erwartet.
]

.F[:
Sofern `std::deque::operator[]()` und `std::deque::at()` eine Referenz auf den
Elementtyp liefern, ist die anschließende Anwendung des Adress-Operator nicht
auszuschließen, um so die Speicheradresse des Elements zu bestimmen. Damit in
Schnittstellen zu Legacy-Code die Verwendung von `std::vector` sichergestellt
ist, empfiehlt sich die Benutzung von dessen Member-Funktion `vector::data()`.
]

---
template: linkinfo
graphic: STL-ContainerIterators
name: iterator_basics
header: ## Iterator-Grundlagen

-------------------------------------------------------------------------------

* [Prinzip des Iterators …		](#iterator_principle)
* [… auf Elemente oder …		](#pointing_to_iterator)
* [… dazwischen zeigend			](#pointing_between_iterator)

-------------------------------------------------------------------------------

* [Vorwärts-Iterator auf …		](#pointing_to_fwd_iterator)
* [… oder zwischen Elemente zeigend	](#pointing_between_fwd_iterator)

-------------------------------------------------------------------------------

* [Rückwärts-Iterator auf …		](#pointing_to_reverse_iterator)
* [… oder zwischen Elemente zeigend	](#pointing_between_reverse_iterator)

-------------------------------------------------------------------------------

* [Gesamter Container … 		](#container_complete)
* [… und Beschränkung auf Teilbereich	](#container_subrange)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: STL-ContainerIterators
section: Essentials
name: iterator_principle
header: ### Prinzip des Iterators

Iteratoren sind spezifisch für ihren jeweiligen Container-Typ als geschachtelte
(Helfer-) Klassen definiert.

Sie kommen vorwiegend dann zur Anwendung,

* wenn auf die Elemente eines Containers oder eines Teilbereichs sequenziell
  nacheinander zugegriffen werden soll,

* werden aber auch verwendet, um Grenzen anzugeben (gesamter Container oder
  Teilbereich),

* oder weisen auf spezifische Elemente, z.B. das Ergebnis einer Suche.

---
template: withinfo
graphic: STL-ContainerIterators
section: Essentials (top left)
name: pointing_to_iterator
header: #### Iterator *auf* Elemente zeigend

Man kann Iteratoren grafisch als *auf Elemente zeigend* veranschaulichen.

Dann bekommt man allerdings ein Erklärungsproblem mit der Iterator-Endposition
und auch mit der Erklärung, wohin der Iterator im Falle eines leeren Containers
zeigt.

.N[
Als Ausweg wird häufig ein – nicht wirklich vorhandenes – Element hinter dem
letzten Container-Element angenommen, zusammen mit der Einschränkungen, dass ein
Iterator in dieser Position **nicht mehr dereferenziert** werden darf.
]

---
template: withinfo
graphic: STL-ContainerIterators
section: Essentials (top right)
name: pointing_between_iterator
header: #### Iterator *zwischen* Elemente zeigend

Mit dieser grafischen Veranschaulichung werden die zuvor beschriebenen Probleme
vermieden.

Dafür stellt sich die Frage, was ein Iterator bei der Dereferenzierung
liefert – er zeigt ja nicht auf Elemente sondern dazwischen.

.N[
Veranschaulicht man Iteratoren als zwischen Elemente zeigend, ist die
Bewegungsrichtung des Iterators wichtig, also in wohin er bei Anwendung des
`operator++` verschoben wird.

Genau das Element, über das hinweg der Iterator damit weiter gesetzt würde,
wird bei der Dereferenzierung geliefert.
]

Damit wird zugleich klar, dass ein Iterator in End-Position nicht dereferenziert
werden darf, denn es gibt ja auch keine Position, zu der er weiter gesetzt werden
könnte.

---
template: withinfo
graphic: STL-ContainerIterators
section: Forward Iterator (left)
name: pointing_to_fwd_iterator
header: ### Vorwärts-Iterator *auf* Elemente zeigend

Bei Dereferenzierung liefern Vorwärts-Iteratoren eine Referenz auf dasjenige
Element im Container, auf das sie gerade zeigen.

* Mit `++` bewegen sich Vorwärts-Iteratoren *vom Container-Anfang zu dessen
  Ende*.._[]

* Dort ist ein – technisch gesehen schon außerhalb des Containers liegendes –
  Element anzunehmen, auf das ein Vorwärts-Iterator in seiner letzten gültigen
  Position am Container-Ende noch zeigen kann.

.W[
Einen Vorwärts-Iterator in dieser Position zu *dereferenzieren* oder
*weiterzubewegen*, liefert undefiniertes Verhalten.
]

.F[:
Sofern es sich um Iteratoren aus der Kategorie der Bidirektional-Iteratoren
handelt, bewegen sie sich bei `--` natürlich Richtung Container-Anfang.
]

---
template: withinfo
graphic: STL-ContainerIterators
section: Forward Iterator (right)
name: pointing_between_fwd_iterator
header: ### Vorwärts-Iterator *zwischen* Elemente zeigend

Bei Dereferenzierung liefern Vorwärts-Iteratoren eine Referenz auf dasjenige
Element im Container, über das sie mit der nächsten `++`-Operation
weiter geschaltet würden.

* Mit `++` bewegen sich Vorwärts-Iteratoren vom Container-Anfang zu dessen
  Ende.._[]

* In ihrer Endposition zeigen sie hinter das letzte Element im Container.

.W[
Einen Vorwärts-Iterator in dieser (End-) Position *weiterzubewegen* oder zu
*dereferenzieren*, liefert undefiniertes Verhalten.
]

.F[:
Sofern es sich um Iteratoren aus der Kategorie der Bidirektional-Iteratoren
handelt, bewegen sie sich bei `--` natürlich Richtung Container-Anfang.
]

---
template: withinfo
graphic: STL-ContainerIterators
section: Reverse Iterator (left)
name: pointing_to_reverse_iterator
header: ### Rückwärts-Iterator *auf* Elemente zeigend

Bei Dereferenzierung liefern Rückwärts-Iteratoren eine Referenz auch dasjenige
Element des Containers, auf das sie gerade zeigen.

* Mit `++` bewegen sich Rückwärts-Iteratoren *vom Container-Ende zu dessen
  Anfang*.._[]

* Dort ist ein – technisch gesehen schon außerhalb des Containers liegendes –
  Element anzunehmen, **auf** das ein Rückwärts-Iterator in seiner letzten
  gültigen Position **am Container-Anfang**  noch zeigen kann.

.W[
Einen Rückwärts-Iterator in dieser (End-) Position zu *dereferenzieren* oder
*weiterzubewegen*, liefert undefiniertes Verhalten.
]

.F[:
Sofern es sich um Iteratoren aus der Kategorie der Bidirektional-Iteratoren
handelt, bewegen sie sich bei `--` natürlich Richtung Container-Ende.
]

---
template: withinfo
graphic: STL-ContainerIterators
section: Reverse Iterator (right)
name: pointing_between_reverse_iterator
header: ### Rückwärts-Iterator *zwischen* Elemente zeigend

Bei Dereferenzierung liefern Rückwärts-Iteratoren eine Referenz auf dasjenige
Element im Container, über das sie mit der nächsten `++`-Operation weiter
geschaltet würden.

* Mit `++` bewegen sich Rückwärts-Iteratoren vom Container-Ende zu dessen
  Anfang.._[]

* In ihrer Endposition zeigen sie vor das erste Element im Container.

.W[
Einen Rückwärts-Iterator in dieser (End-) Position *weiterzubewegen* oder zu
*dereferenzieren*, liefert undefiniertes Verhalten.
]

.F[:
Sofern es sich um Iteratoren aus der Kategorie der Bidirektional-Iteratoren handelt,
bewegen sie sich bei `--` natürlich Richtung Container-Ende.
]

---
template: withinfo
graphic: STL-ContainerIterators
section: Full Container Processing
name: container_complete
header: ### *Alle* Elemente im Container

Um **über alle Elemente** eines Containers zu iterieren, wird oft folgende
Konstruktion verwendet (hier demonstriert am Beispiel einer `std::list`):
```
std::list<int> li;
…
for (auto it = li.begin(); it != li.end(); ++it)
    … *it …
```
Mit C++98 muss statt `auto` der exakte Iterator-Typ angegeben werden, wozu sich
der Übersichtlichkeit und Wartungsfreundlichkeit wegen eine Typ-Definition für
den Container anbietet:._[]
```
typedef std::list<int> INTLIST;
```
Der Iterator ergibt sich damit als:
```
for (INTLIST::iterator it = li.begin(); it != li.end(); ++li)
   … *it …
```
.F[:
Die neue C++11-Syntax zur Typdefinition funktioniert natürlich auch:
`using INTLIST = std::list<int>;`
]
---

template: withinfo
graphic: STL-ContainerIterators
section: Partial Container Processing
name: container_subrange
header: ### *Teilbereich* eines Containers

Um über die **Elemente in einem Teilbereich** eines Container zu iterieren,
werden die Grenzen mit zwei Iteratoren angegeben, die

* *hinter den Anfang* und/oder
* *vor das Ende* zeigen,

hier demonstriert am Beispiel eines `std::vector<std::string>`:._[]
```
std::vector<std::string> sv;
…
assert(sv.size() >= 5);
for (auto it = sv.begin()+3; it != sv.end()-2; ++it)
    … *it …
```

.F[:
Die Korrektheit des Beispiel beruht wesentlich auf der Tatsache, dass die
Iteratoren eines `std::vector` zur Kategorie der
[Random-Access-Iteratoren](04_tuesday2.html#random_access_iterators)
gehören. Andernfalls liefert die Addition oder Subtraktion einer Ganzzahl bei
Anwendung auf einen Iterator ein Compile-Fehler.
]

---
template: linkinfo
graphic: STL-AssociativeContainers
name: associative_containers
header: ## Assoziative Container

-------------------------------------------------------------------------------

* [Kombination der Varianten	](#associative_combinations)

-------------------------------------------------------------------------------

* [Speicherverfahren:
   Red-Black-Tree._[]		](#associative_rb_tree)
* [Speicherverfahren:
   Hashing			](#associative_hashing)

--------------------------------------------------------------------------------

.F[:
Eine stets balancierte Variante des Binärbaums.
]

---
template: withinfo
graphic: STL-AssociativeContainers
section: Combinations of Associative Containers
name: associative_combinations
header: ### Kombination der Varianten

Die verfügbaren assoziativen Container unterscheiden sich in folgenden Aspekten:

* Zur Abspeicherung verwendete Datenstruktur:

  * Red-Black-Tree (Binärbaum) vs. Hashing (neu in C++11)

* Nur Schlüssel oder Schlüssel mit zugeordnetem Wert:

  * `set` vs. `map`

* Eindeutige Schlüssel oder Mehrfachschlüssel erlaubt:

  * normale vs. `multi`-Version

.I[
Da die drei Kriterien unabhängig voneinander sind, ergeben sich insgesamt
acht (2<sup>3</sup>) Kombinationen.
]

---
template: withinfo
graphic: STL-AssociativeContainers
section: RB-Tree-based Storage
name: associative_rb_tree
header: ### Speicherverfahren Red-Black-Tree

Hierbei handelt es sich um eine permanent balancierte._[] Variante des
Binärbaums.

.F[:
Ein Binärbaum ist balanciert, wenn alle Zweige eine möglichst gleichmäßige Tiefe
haben. Ein nicht balancierter Binärbaum entspricht im Extremfall einer einfach
verketteten Liste.
]

Die folgende Tabelle verdeutlicht den Zusammenhang zwischen der Tiefe eines
balancierten Binärbaums und der Anzahl enthaltener Einträge. Die Tiefe bestimmt
vor allem auch die (maximal) nötige Anzahl von Vergleichen, mit der ein
gegebener Schlüssel gefunden werden kann.

| Tiefe | und minimale .. maximale Zahl der Einträge              |
| :---- | :------------------------------------------------------ |
|   1   | 1 .. 1                                                  |
|   2   | 2 .. 3                                                  |
|   5   | 16 .. 31                                                |
|   7   | 64 .. 127                                               |
|  10   | 512 .. 1023                                             |
|  20   | 524 288 .. 1 048 575 (ca. eine Million)                 |
|  30   | 536 870 912 .. 1 073 741 823 (ca. eine Milliarde)       |
|  40   | 549 755 813 888 .. 1 099 511 627 775 (ca. eine Billion) |


---
template: withinfo
graphic: STL-AssociativeContainers
section: Hash-based Storage
name: associative_hashing
header: ### Speicherverfahren Hashing

[Big O Notation]: http://en.wikipedia.org/wiki/Big_O_notation
[Quicksort]:      http://en.wikipedia.org/wiki/Quicksort
[Bubblesort]:     http://en.wikipedia.org/wiki/Bubblesort
[TSP]:            http://en.wikipedia.org/wiki/Travelling_salesman_problem

Unter dem Begriff *Hashing* wird (u.a.) ein Abspeicherungsverfahren verstanden,
welches – eine gut streuende Hash-Funktion vorausgesetzt – Suchzeiten in der
Größenordnung O(1) erlaubt.

.N[
Die [Big O Notation] wird in der Informatik häufig verwendet, um die
(theoretische) Effizienz eines Algorithmus anzugeben.
]

Es ist die Obergrenze des Zeitbedarfs abhängig von der Datenmenge (N):

| Größenordnung             | und typisches Beispiel                            |
| ------------------------- | :------------------------------------------------ |
| O(1)                      | Suchzeiten bei Hashing                            |
| O(log<sub>2</sub>(N))     | Suchzeiten in (balanciertem) Binärbaum            |
| O(N)                      | Suchzeiten in linearer Liste                      |
| O(N × log<sub>2</sub>(N)) | optimaler Sortieralgorithmus (z.B. [Quicksort])   |
| O(N<sup>2</sup>)          | primitiver Sortieralgorithmus (z.B. [Bubblesort]) |
| O(n!)                     | Lösung des "Handlungsreisenden Problems"._[]      |

.F[:
The [TSP] or "Traveling Salesman Problem" is infamous for its combinatoric
explosion of possibilities to check, when trying a brute force solution.
]



---
template: plain
header: #### Prinzip des Hashing

[Hashing]: http://en.wikipedia.org/wiki/Hash_function

Diese Verfahren verläuft nach folgendem [Grundprinzip][Hashing]:

1. Zu jedem abzulegenden Schlüssel._[] wird mittels einer Hash-Funktion ein
   ganzzahliger Wert berechnet.

2. Die Formel zu dieser Berechnung ist so ausgelegt, dass der Wert in einem
   vorgegebenen Bereich streut.

3. Dieser Wert dient als Index, welcher (für Schlüssel und Datenwert)

   * die Position zur Abspeicherung innerhalb eines Arrays festlegt,

   * dessen Größe dem Streubereich der Hash-Funktion entspricht.

.F[:
Bei den verschiedenen Varianten des `std::set` gibt es keinen dem Schlüssel
zugeordneten Datenwert – oder anders gesagt: der Datenwert ist in diesem Fall
auch der Schlüssel.
]

.N[
Abhängig von der Anzahl der Schlüssel und Datenwerte (im Verhältnis zur Größe
des Arrays) wird es dabei zu Mehrdeutigkeiten kommen:
**Früher oder später werden verschiedene Schlüssel auf ein und denselben Index
abgebildet.**
]

---
template: plain
header: #### Behandlung von Kollisionen

Bildet die Hash-Funktion verschiedene Schlüssel auf ein und denselben Index ab,
spricht man von einer Kollission und das auslösende Element wird nun auch
*Überläufer* genannt.

.N[
Gut streuende Hashfunktionen liefern bis zu einer ca. 70 .. 80%-igen Belegung
des zur Verfügung stehenden Indexraums nur relativ selten Kollisionen.
]

Prinzipiell können Kollisionen aber ab dem zweiten Eintrag immer auftreten!

* Eine Technik zur Speicherung von Überläufern muss Bestandteil jedes
  hash-basierten Speicherverfahrens sein.

* Übliche ist, für *jeden* per Hash-Funktion errechneten Index die Möglichkeit
  einer verketteten Liste vorzusehen, die nach dem ersten aufgetretenen Wert
  auch alle späteren Überläufer aufnimmt.._[]

.F[:
There are variations, like simply using the next (available) empty slot in the
array. Though this simplifies data structures, it may lead to complications (or
at least bad performance) if the array gets close to full, especially if many
entries may be inserted and removed over time.
]

---
template: plain
header: #### Re-Hashing

Ist der Umfang der Datenmenge unbekannt, muss der Indexraum möglicherweise zu
einem späteren Zeitpunkt vergrößert werden, um stets gute Performance zu bieten.

* Eine universell verwendbare Klasse wie `unordered_set` oder `unordered_map`
  (die jeweiligen `multi`-Varianten eingeschlossen) kann dies vollautomatisch
  tun.

* Zusammen mit der Erweiterung des Indexraums muss die Hash-Funktion angepasst
  werden, so dass sie die Schlüssel auf einen entsprechend größeren Bereich
  verteilt.._[]

.N[
Anschließend müssen alle mit der vorher gültigen Hash-Funktion im alten,
kleineren Indexraum verteilten Schlüssel mit der neuen Hash-Funktion wieder
im neuen, größeren Indexraum verteilt werden.
]

.F[:
Für diesen auch Re-Hashing genannten Vorgang gibt es spezielle Techniken, welche
die erforderlichen Neuberechnungen hinauszögern (und damit besser über die Zeit
verteilen) oder von der Anzahl her reduzieren (und damit den Rechenaufwand
insgesamt vermindern).
]

---
template: linkinfo
graphic: STL-IteratorDetails
name: iterator_details
header: ## Iterator-Details

-------------------------------------------------------------------------------

* [Iterator nur für lesenden vs. …	](#readonly_iterator)
* [… modifizierenden Zugriff		](#readwrite_iterator)

-------------------------------------------------------------------------------

* [Vorwärts laufender vs. …		](#fwd_iterator)
* [… rückwärts laufender Iterator	](#reverse_iterator)

-------------------------------------------------------------------------------

* [Iterator-Position im leeren Container](#empty_container_position)

-------------------------------------------------------------------------------

* [Index-basierter Zugriff		](#index_based_access)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: STL-IteratorDetails
section: Read-only Iterators
name: readonly_iterator
header: ### Iterator für nur lesenden Zugriff

Diese Seite zeigt einige typische Schleifenkonstrukte mit einem Iterator für
den nicht-modifizierenden Zugriff, am Beispiel einer Container-Klasse `C` und
eines entsprechenden Container-Objekts `c`:

In C++11 mit neuer Bedeutung von `auto` und neuer Initialisierungssyntax:
```
for (auto cit{c.cbegin()}; cit != c.cend(); ++cit)
    … *cit …
```
In C++98 mit expliziter Angabe des Iterator-Typs:
```
for (C::const_iterator cit = c.begin(); cit != c.end(); ++it)
    … *cit …
```
.W[
Den dereferenzierten Iterator zur Modifikation eines Container-Elements zu
verwenden – also in der Form `*cit = …` – ist ein Compilezeit-Fehler.
]

---
template: withinfo
graphic: STL-IteratorDetails
section: Non-Modifiable STL-Container
name: readwrite_iterator
header: ### Iterator für modifizierenden Zugriff

Diese Seite zeigt einige typische Schleifenkonstrukte mit einem Iterator für
den potenziell modifizierenden Zugriff, am Beispiel einer Container-Klasse `C`
und eines entsprechenden Container-Objekts `c`:

In C++11 mit neuer Bedeutung von `auto` und neuer Initialisierungssyntax:
```
for (auto it{c.begin()}; it != c.end(); ++cit) {
    … *it … // Zugriff sowohl lesend als
    *it = … // auch modifizierend erlaubt
}
```
In C++98 mit expliziter Angabe des Iterator-Typs:
```
for (C::iterator it = c.begin(); it != c.end(); ++it) {
    … *it … // Zugriff sowohl lesend als
    *it = … // auch modifizierend erlaubt
}
```

---
template: withinfo
graphic: STL-IteratorDetails
section: Forward Iterator
name: fwd_iterator
header: ### Vorwärts laufender Iterator

Diese Seite zeigt weitere typische Schleifenkonstrukte für den potenziell
modifizierenden Zugriff am Beispiel einer Container-Klasse `C` und eines
entsprechenden Container-Objekts `c`:

In C++98 mit expliziter Angabe des Iterator-Typs:
```
for (C::iterator it = c.begin(); it != c.end(); ++it) {
    … *it … // Zugriff sowohl lesend als
    *it = … // auch modifizierend erlaubt
}
```
In C++11 konkurriert dies auch mit der bereichsbasierten Schleife:._[]
```
for (auto &v : c) {
    … v … // Zugriff sowohl lesend als
    v = … // auch modifizierend erlaubt
}
```

.F[:
Auch wenn es hier keinen explizit sichtbaren Iterator gibt, verwendet die
bereichsbasierte Schleife in ihrer internen Implementierung die
Iterator-Schnittstelle der Klasse des beteiligten Container-Objekts.
]

---
template: withinfo
graphic: STL-IteratorDetails
section: Reverse Iterator

name: reverse_iterator
header: ### Rückwärts laufender Iterator

Diese Seite zeigt das typische Schleifenkonstrukt für den potenziell
modifizierenden Zugriff am Beispiel einer Container-Klasse `C` und eines
entsprechenden Container-Objekts `c`:

In C++98 mit expliziter Angabe des Iterator-Typs:
```
for (C::reverse_iterator it = c.rbegin(); it != c.rend(); ++it) {
    … *it … // Zugriff sowohl lesend als
    *it = … // auch modifizierend erlaubt
}
```
Die einzige, in C++11 mögliche Vereinfachung ist hier die Verwendung von `auto`
für den Typ des Iterators.
```
for (auto it = c.rbegin(); it != c.rend(); ++it) …
```
.I[
Eine spezielle, rückwärts laufende Form der bereichsbasierten Schleife
ist in C++11 nicht verfügbar.
]

---
template: withinfo
graphic: STL-IteratorDetails
section: Iterator Position in Empty Container
name: empty_container_position
header: ### Iterator-Position im leeren Container

Für einen leeren Container sind die Iteratoren in Beginn- und Endposition
einander gleich. Alle der folgenden Schleifen werden daher niemals durchlaufen,
wenn `c` leer ist:

```
// mit modifizierbaren Vorwaerts-Iterator:
for (auto it = c.begin(); it != c.end(); ++it) …
…
// mit nicht-modifizierbaren Vorwaerts-Iterator:
for (auto it = c.cbegin(); it != c.cend(); ++it) …
…
// mit modifizierbaren Rueckwaerts-Iterator:
for (auto it = c.rbegin(); it != c.rend(); ++it) …
…
// mit nicht-modifizierbaren Rueckwaerts-Iterator:
for (auto it = c.crbegin(); it != c.crend(); ++it) …
```

.N[
Da die von den verschiedenen Varianten der `begin()`-Funktion gelieferten
Iterator-Typen unterschiedlich sind, muss der Vergleich auf die Endposition
mit derjenigen Variante der `end()`-Funktion erfolgen, die den selben
Iterator-Typ liefert.
]

---
template: withinfo
graphic: STL-IteratorDetails
section: Accessing Elements via Index
name: index_based_access
header: ### Index-basierter Zugriff

Für die Container

* `std::array`,
* `std::vector` und
* `std::deque`

besteht alternativ zum Durchlaufen mittels Iterator auch die Möglichkeit des
indexbasierten Zugriffs. Die Basis-Variante – wieder dargestellt am Beispiel
eines Containers der Klasse `C` und einem entsprechenden Container-Objekt `c` –
sieht wie folgt aus :
```
for (C::size_type i = 0; i &lt; c.size(); ++i) {
    … c[i] …    // Zugriff ohne Index-Pruefung
    … c.at(i) … // Zugriff mit Index-Pruefung
}
```

.I[
Die Verwendung des in allen STL-Containern definierten Typs `size_type` für die
Indexvariable vermeidet eine eventuelle Warnung beim Vergleich mit dem
Rückgabewert der `size()`-Member-Funktion, da deren Ergebnis ebenfalls diesen
Typ hat.
]

---
template: plain
name: associative_container_iterators
header: ### Iteratoren für Assoziative Container

Eine Besonderheit bei assoziativen Container ist, dass auch über normale
Iteratoren – also nicht nur bei `const_iterator` – auf **Elemente** von

  * `std::set`,
  * `std::multiset`,
  * `std::unordered_set` und
  * `std::unordered_multiset`

sowie auf **Schlüssel** von

  * `std::map`,
  * `std::multimap`,
  * `std::unordered_map` und
  * `std::unordered_multimap`

ausschließlich **lesend** zugegriffen werden kann.._[]

.F[:
Der Zugriff auf den **Wert** (gemäß nächster Seite) ist bei den diversen
`map`-Varianten wie üblich über `…::const_iterator` nur lesend und über
`…::iterator` sowohl lesend wie auch schreibend möglich.
]

---
template: plain
name: key_value_access
header: ### Iteratoren für Maps

Die Iteratoren für `std::map`, `std::multimap`, `std::unordered_map` und
`std::unordered_multimap` müssen den separaten Zugriff auf beides,
**Schlüssel** und **Werte** ermöglichen.

Dies geschieht über ihren speziellen dereferenzierten Typ, ein `std::pair`
über

* dessen erste Komponente (`first`) der Schlüssel und
* dessen zweite Komponente (`second`) der Wert erreicht wird.

Als Beispiel ein Programmfragment zum Zählen von Worthäufigkeiten:._[]
```
std::string word;
std::map<std::string, int> wfreq;
while (std::cin >> word)
    ++wfreq[word];
for (auto it = wfreq.cbegin(); it != wfreq.cend(); ++it)
    std::cout << it->first << ": " << it->second << std::endl;
```

.F[:
The original "pure C" version in *[K&R: The C Programming Language]* has roughly 100 lines …
]

  [K&R: The C Programming Language]: http://en.wikipedia.org/wiki/The_C_Programming_Language

---
template: plain
name: key_value_access
header: ### Bereichsbasierte Schleifen für Maps

Die neue, bereichsbasierte `for`-Syntax von C++11 kann ebenfalls über Maps
iterieren:
```
for (auto e : wfreq)
    std::cout << e.first << ": " << e.second << std::endl;
```
Eine Referenz erspart das Kopieren des jeweiligen Elements:
```
for (auto &e : wfreq)
    std::cout << e.first << ": " << e.second << std::endl;
```
Eine konstante Referenz erlaubt nur noch den Lesezugriff …
```
for (const auto &e : wfreq)
    std::cout << e.first << ": " << e.second << std::endl;
```
… und schützt damit vor unbeabsichtigten Modifikationen, z.B. wenn statt eines
Vergleichs versehentlich die Zuweisung geschrieben würde:

```
if (e.second = 100) … // ERROR
```

---
layout: false
template: blank
name: part4

# [C++ FOR](#agenda) (Part 4)

Iterators and STL Algorithms

-------------------------------------------------------------------------------

1. [Iterator-Kategorien		 		](#iterator_categories)
1. [Konventionen der Iterator-Schnittstelle	](#iterator_conventions)
1. [Iteratoren und Algorithmen			](#iterators_in_algorithms)

-------------------------------------------------------------------------------

---
template: linkinfo
graphic: STL-IteratorCategories
name: iterator_categories
header: ## Iterator-Kategorien

------------------------------------------------------------------------

* [Unidirektionale Iteratoren		](#unidirectional_iterators)

------------------------------------------------------------------------

* [Bidirektionale Iteratoren		](#bidirectional_iterators)

------------------------------------------------------------------------

* [Iteratoren mit wahlfreiem Zugriff	](#random_access_iterators)

------------------------------------------------------------------------

---
template: withinfo
graphic: STL-IteratorCategories
section: Unidirectional Iterators
name: unidirectional_iterators
header: ### Unidirektionale Iteratoren

Iteratoren, welche der Kategorie *Unidirectional-Iterator* angehören, können
sich – ihrem Namen entsprechend – nur in eine Richtung bewegen, nämlich vom
Anfang eines Containers zu dessen Ende hin.

Um pure unidirektionale Iteratoren handelt es sich bei

* `std::forward_list<T>::iterator`

inklusive der zugehörigen `const_`-Variante.


---
template: withinfo
graphic: STL-IteratorCategories
section: Bidirectional Iterators
name: bidirectional_iterators
header: ### Bidirektionale Iteratoren

Iteratoren, die der Kategorie *Bidirectional-Iterator* angehören, können sich –
ihrem Namen entsprechend – in zwei Richtung bewegen, nämlich vom Anfang eines
Containers zu dessen Ende hin und umgekehrt.

.N[
Die Kategorie *Bidirectional-Iterator* schließt die Fähigkeiten der Kategorie
*Unidirectional-Iterator* ein.
]

Um Bidirektionale Iteratoren handelt es sich bei

* `std::list<T>::iterator`
* sowie den Iteratoren der assoziativen Container,

inklusive der jeweiligen `const_`, `reverse_` und `const_reverse_`-Varianten.

---
template: withinfo
graphic: STL-IteratorCategories
section: Random Access Iterators
name: random_access_iterators
header: ### Iteratoren mit wahlfreiem Zugriff

Iteratoren, die der Kategorie *Random-Access-Iterator* angehören, können –
ihrem Namen entsprechend – innerhalb des zugehörigen Containers effizient
wahlfrei zugreifen.

.N[
Die Kategorie *Random-Access-Iterator* schließt die Fähigkeiten der Kategorie
*Bidirectional-Iterator* ein.
]

Neben der Addition und Subtraktion von Ganzzahlen (womit der Iterator über
größere Distanzen weiter geschaltet wird) kann über Differenzbildung auch die
Anzahl der Elemente bestimmt werden, die sich zwischen zwei Iterator-Positionen
befinden.

Um Iteratoren mit wahlfreiem Zugriff handelt es sich bei

* `std::array<T, N>::iterator`,
* `std::vector<T>::iterator` und
* `std::deque<T>::iterator`

inklusive der jeweiligen `const_`, `reverse_` und `const_reverse_`-Varianten.

---
template: plain
header: ### Grenzprüfung bei Iteratoren mit wahlfreiem Zugriff

Hier ist zu beachten, dass die Minimal-Anforderungen des C++-Standards so
gefasst sind, dass eine sehr effiziente Implementierung möglich ist, auch
wenn dies auf Kosten der Sicherheit geht.

.W[
Wenn Operationen, an denen Iteratoren mit wahlfreiem Zugriff beteiligt sind,
eine (neue) Iterator-Position außerhalb des Containers liefern, ist das Ergebnis
undefiniert.
]

Gültige Positionen sind dabei auch die möglichen Endpositionen (am
Container-Ende für normale Iteratoren bzw. an Container-Anfang für
Reverse-Iteratoren).

.W[
Für ein definiertes Ergebnis bei der Differenzbildung müssen die beteiligten
Iteratoren gültige Positionen (inklusive der Endpositionen) im selben Container
haben.
]

Sichergestellt ist aber, dass zwei Iteratoren, die in verschiedene Container
zeigen, niemals als *gleich* angesehen werden.

---
template: linkinfo
graphic: STL-IteratorUsages
name: iterator_conventions
header: ## Konventionen der Iterator-Schnittstelle

----------------------------------------------------------------------------

* [Iteratoren verbinden …	](#iterators_as_glue)
* [… Container mit …		](#container_axis)
* [… Algorithmen		](#algorithm_axis)

----------------------------------------------------------------------------

* [Input-Iteratoren		](#input_iterators)
* [Output-Iteratoren		](#output_iterators)

----------------------------------------------------------------------------

* [Erfolgreiche und …		](#success_from_searching)
* [… gescheiterte Suche		](#failure_from_searching)

----------------------------------------------------------------------------

* [Füllstands- und …		](#state_from_filling)
* [… Löschungs-Anzeige		](#removing_logically_only)

----------------------------------------------------------------------------

---
template: withinfo
graphic: STL-IteratorUsages
section: Iterators as "Glue"
name: iterators_as_glue
header: ### Iteratoren als verbindendes Element

Mit Iteratoren als Bindeglied zwischen Containern und Algorithmen sind bei

* ca. 40 Algorithmen (-Familien) und

* 12 Containern im ISO-Standard

keine 480 (= 12 × 40) Implementierungen notwendig.._[]

.F[:
Selbst unter Berücksichtigung der Tatsache, dass nicht alle Algorithmen für alle
Container sinnvoll sind, würde die Zahl der erforderlichen Implementierungen
immer noch bei mehreren hundert liegen.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Container Dimension
name: container_axis
header: ### Container-Achse

In C++98 wurden drei sequenzielle und vier assoziative Container standardisiert.

Mit C++11 sind es nun insgesamt fünf sequenzielle und acht assoziative Container.

(C++14 hat keine weiteren Container hinzugefügt.)

---
template: withinfo
graphic: STL-IteratorUsages
section: Algorithm-Dimension
name: algorithm_axis
header: ### Algorithmen-Achse

Hier gibt es – je nach Zählweise – im Rahmen des ISO&ANSI-Standards gut drei
Dutzend Einträge.

Viele Algorithmen kommen in "Familien" wie etwa:

* Grundlegende Variante
* Variante endend mit `_if` für flexible Bedingungsprüfung
* Variante endend mit `_copy` für Ergebnisablage in neuem Container
* Soweit sinnvoll die Kombination von Obigem


---
template: withinfo
graphic: STL-IteratorUsages
section: Input Iterators
name: input_iterators
header: ### Input-Iterator

Input-Iteratoren sind *abwechselnd*

* für den *Lese-Zugriff* zu dereferenzieren (`*`)

* und *weiter zu schalten* (`++`).

.W[
Bei Nichtbeachtung dieser Anwendungsvorschrift betrifft das Fehlverhalten oft
nicht alle Arten von Containern, so dass Verstöße nur bei ausreichenden Tests
auffallen.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Output Iterators
name: output_iterators
header: ### Output-Iterator

Output-Iteratoren sind *abwechselnd*

* für den *Schreib-Zugriff* zu dereferenzieren (`*`)

* und *weiter zu schalten* (`++`).

.W[
Bei Nichtbeachtung dieser Anwendungsvorschrift betrifft das Fehlverhalten oft
nicht alle Arten von Containern, so dass Verstöße nur bei ausreichenden Tests
auffallen.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Return Success from Search
name: success_from_searching
header: ### Erfolgreiche Suche

Beim Suchen (und verwandten Container-Operationen) wird der Erfolg dadurch
angezeigt, dass der als Rückgabewert gelieferte Iterator

* auf eine gültige Position

im zur Bearbeitung übergebenen Daten-Bereich zeigt.

.W[
Wird nur ein Teilbereich eines Containers `c` übergeben, der sich nicht bis zu
dessen Ende erstreckt, darf zur Prüfung auf Erfolg oder Misserfolg nicht mit
`c.end()` verglichen werden.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Return Failure from Search
name: failure_from_searching
header: ### Gescheiterte Suche

Beim Suchen wird der Misserfolg damit angezeigt, dass der als Rückgabewert
gelieferte Iterator

* immer auf die Endposition

des zur Bearbeitung übergebenen Bereichs zeigt.

.W[
Beim Suchen in einem leeren Container oder Bereich wird stets die Endposition
des Containers bzw. des Bereichs geliefert.
]

---
template: withinfo
graphic: STL-IteratorUsages
section: Return State from Filling
name: state_from_filling
header: ### Zustandsanzeige nach Füllen

Beim Füllen eines Containers ist es üblich, dass Algorithmen

* den (neuen) Füllstand des Containers

durch einen entsprechenden Iterator als Rückgabewert anzeigen.

.N[
Dies ist sinnvoll und praktisch, um den Container ab dieser Stelle später weiter
füllen zu können.
]

---
template: withinfo
graphic: STL-IteratorUsages
name: removing_logically_only
section: Return "New End" when "Removing" Elements
header: ### Löschungs-Anzeige durch neues (logisches) Ende

Da die Algorithmen für eine große Zahl von Containern funktionieren sollen,
finden gibt es einige aus pragmatischer Sicht sinnvolle aber Besonderheiten.

Eine davon betrifft die Tatsache, dass "löschende" Algorithmen nicht davon
ausgehen, den bearbeiteten Container verkleinern zu können.

.N[
Dadurch funtionieren diese Algorithmen auch für die eingebauten Arrays und
die STL-Klasse `std::array`.
]

Beim Löschen von Elementen aus Containern wird nur "logisch gelöscht", d.h.

* die enthaltenen Elemente erden ggf. anders angeordnet, und

* als Rückgabewert ein Iterator geliefert, der das "neue Ende" bezeichnet.

---
template: plain
name: iterators_in_algorithms
header: ## Iteratoren und Algorithmen

Die konsequente Verwendung von Iteratoren bei der Implementierung aller
STL-Algorithmen verschafft eine besondere Flexibilität.

Iteratoren sind in der Regel einfache (Helfer-) Klassen, welche abhängig vom
Container, für den sie jeweils zuständig sind, eine vollkommen unterschiedliche
Implementierung besitzen können.

.N[
Damit können die Daten, die ein STL-Algorithmus bearbeitet, aus ganz
unterschiedlichen Quellen stammen und ebenso die gelieferten Ergebnisse an
ganz unterschiedlichen Zielen abgelegt werden.
]

---
template: plain
header: ### Beispiel: Implementierung des `copy`-Algorithmus

Zum besseren Verständnis, wie mittels Iteratoren die Algorithmen eine besondere
Flexibilität erzielen, ist ein Blick auf eine mögliche Implementierung des
`copy`-Algorithmus hilfreich:._[]
```
template<typename T1, typename T2>
T2 my_copy(T1 from, T1 upto, T2 dest) {
    while (from != upto)
       	*dest++ = *from++;
    return dest;
}
```

.F[:
Damit dieser Algorithmus ggf. per *Copy&Paste* in ein Programm übernommen und
ausprobiert werden kann, wurde er vorsorglich `my_copy` genannt, so dass auch
bei `using namespace std;` ein Konflikt mit `std::copy` ausgeschlossen ist.
]

---
template: plain
header: #### Kopieren der Elemente eines `std::set` in einen `std::vector`

Die gerade gezeigte Funktion kann problemlos zwischen zwei unterschiedlichen
Containern kopieren:
```
std::vector<int> v;
std::set<int> s;
…
v.resize(s.size());
std::copy(s.begin(), s.end(), v.begin());
```
Da von einen normalen Iterator – wie von `v.begin()` geliefert – nur bereits
vorhandene Elemente überschrieben aber keine neuen Elemente angefügt werden
können, ist es wichtig, den Ziel-Container vor dem Kopieren auf die notwendige
(Mindest-) Größe zu bringen.

---
template: plain
header: #### Anhängen an Vektoren

##### Hilfsklasse: `back_insert_iterator`

Ohne den Ziel-Container zuvor auf eine passende Größe zu bringen, lässt sich
eine sichere Variante des Kopierens auch erreichen, indem neue Elemente mit
`push_back` angefügt werden:._[]
```
std::copy(s.begin(), s.end(),
          std::back_insert_iterator<std::vector<int>>(v)
);
```

.N[
Da die in diesem und vielen folgenden Beispielen an Algorithmen übergebenen
Argumentlisten recht lang sind, erfolgt ein Umbruch innerhalb der
Argument-Liste, um die Lesbarkeit zu verbessern.
]

Dabei werden auch unterschiedliche Formatierungs-Stile demonstriert.._[]

.F[:
Die oben verwendete asymmetrische Klammerung der Argumentliste ist sicher
Geschmackssache, dupliziert aber den oft auch bei geschweiften Klammern
üblichen Stil.
]

---
template: plain
header: ##### Hilfsfunktion: `back_inserter`

Die – redundant erscheinende – Angabe von `int` als Datentyp des Containers `v`
ist technisch der Tatsache geschuldet, dass ein (temporäres) Objekt der
Template-Klasse `std::back_insert_iterator` erzeugt werden muss und der
Konstrukor aus dem Argumenttyp nicht auf den Instanziierungs-Typ schließen kann.

Eine Hilfsfunktion._[] vermeidet diese Redundanz:
```
std::copy(s.begin(), s.end(), std::back_inserter(v));
```

.F[:
Diese Funktion ist zwar Bestandteil der Standard-Bibliothek, muss also nicht
selbst implementiert werden, ihre Implementierung ist aber insofern interessant,
als die zugrundeliegende Technik in ähnlich gelagerten Fällen zur Vermeidung
redundanter Typangaben eingesetzt werden kann:
```
   template<typename T>
inline std::back_inserter_iterator<T> std::back_inserter(T &c) {
    return std::back_insert_iterator<T>(c);
}
```
]

---
template: plain
header: #### Am Anfang oder Ende sequenzieller Container einfügen

Selbstverständlich funktionert der `std::back_inserter_iterator` bzw. die
Hilfsfunktion `std::back_inserter` auch für die Klassen

* `std::list` und
* `std::deque`

und es existiert auch ein `std::front_insert_iterator` sowie eine Hilfsfunktion
`std::front_inserter`, welche mit den Klassen

* `std::list`,
* `std::deque` und
* `std::forward_list`

verwendbar ist.._[]

.F[:
Allgemeiner ausgedrückt ist die Anforderung beim `std::back_insert_iterator`,
dass für den zur Instanziierung verwendeten Container eine Member-Function
`push_back` existiert, und beim `std::front_insert_iterator` entsprechend, dass
`push_front` existiert.
]

---
template: plain
header: #### In assoziative Container einfügen

##### Hilfsklasse: `insert_iterator`

Hiermit können z.B. alle Elemente einer Liste wie folgt in ein `std::set`
übertragen werden – wobei Duplikate natürlich nicht übernommen werden:._[]

```
std::list<MyClass> li;
…
std::set<MyClass> s;
std::copy(li.begin(), li.end(),
          std::insert_iterator<std::set<MyClass>>(s)
);
```

.F[:
Es sei denn, es handelt sich um ein `std::multiset`.
]

---
template: plain
header: ##### Hilfsfunktion: `inserter`

Auch hier gibt es eine Hilfsfunktion zur Vermeidung der (eigentlich redundanten)
Angabe des Container-Typs:
```
std::set<MyClass> s;
std::copy(li.begin(), li.end(), std::inserter(s, s.begin()));
```

Etwas ungewöhnlich ist hier das zusätzliche Argument. Dessen Zweck ist es, einen
Optimierungshinweis._[] zu geben, den der Insert-Iterator ggf. verwendet, um die
Suche nach der Einfügeposition abzukürzen.

.N[
Üblicherweise wird – wenn kein wirklicher Hinweis gegeben werden kann – der
Beginn-Iterator des jeweiligen Sets verwendet.
]

.F[:
Da es sich nur um einen Hinweis handelt, ist die Angabe unkritisch, auch wenn
man einen falschen Hinweis gibt (oder keinen passenden Hinweise angibt, obwohl
einer existiert). Dann bleibt lediglich eine Optimierungs-Chance ungenutzt …
]

---
template: plain
header: #### Stream-Iteratoren

So wie ein Back- oder Front-Insert-Iterator letzten Endes (bei der
dereferenzierten Zuweisung) eine `push_back`- bzw. `push_front`-Operation für
den betroffenen Container ausführt, lassen sich auch andere Operationen in den
(überladenen) Operatoren spezieller Iteratoren unterbringen.

##### In Stream schreiben mit `std::ostream_iterator`:

Das folgende Beispiel kopiert den Inhalt einer `std::forward_list` auf die
Standard-Ausgabe und fügt nach jedem Wert ein Semikolon ein:
```
std::forward_list<long> fli;
…
std::copy(fli.begin(), fli.end(),
          std::ostream_iterator<long>(std::cout, ";")
);
```

---
template: plain
header: ##### Aus Stream lesen mit `std::istream_iterator`:

Das folgende Beispiel._[] kopiert Worte von der Standardeingabe bis EOF in eine
`std::forward_list`:
```
std::forward_list<std::string> fli;
copy(std::istream_iterator<std::string>(std::cin),
     std::istream_iterator<std::string>(),
     std::front_inserter(fli)
);
```
.F[:
Zumeist ist es zwar ausreichend, das obige Beispiel mehr oder weniger
"kochrezeptartig" und ggf. sinngemäß verändert anzuwenden, dennoch taucht häufig
die Frage auf, wie es denn "hinter den Kulissen" funktioniert. Daher als Hinweis
das folgende:
Offensichtlich gibt es zwei Konstruktoren, von denen einer ein
`std::istream`-Objekt als Argument erhält. Ein auf diese Weise erzeugter
Input-Stream-Iterator liefert im Vergleich mit einem per Default-Konstruktor
erzeugten Gegenstück zunächst `false`.
Die Operationen `*` und `++` werden auf eine Eingabe mit `operator>>`
abgebildet, wobei die eingelesene Variable genau den Typ hat, der zur
Instanziierung der Template verwendet wurde. Sobald der Eingabestrom den
*good*-Zustand verlässt, liefert der damit verbundene Istream-Iterator beim
erneuten Vergleich mit dem per Default-Konstruktor erstellten `true`.
]

---
template: plain
header: #### Zeiger als Iteratoren

Da die für Iteratoren implementierten Operationen syntaktisch wie semantisch
denen für Zeiger entsprechen, können auch klassische Arrays bearbeitet werden.

##### Kopieren AUS klassischem Array

Mit einem klassischen Array
```
double data[100]; std::size_t ndata{0};
```

und der Annahme, dass nach dessen Befüllen die ersten `ndata` Einträge
tatsächlich gültige Werte enthalten:
```
std::copy(&data[0], &data[ndata], … );
```

Oder:
```
std::copy(data, data + ndata, … );
```

---
template: plain
header: ##### Kopieren IN klassisches Array

Mit einem klassischen Array als Ziel der Kopie:
```
const auto endp = copy( … , … , &data[0]);
```

Umrechnung des Füllstatus-Iterators in Anzahl gültiger Elemente:
```
ndata = endp - data; // oder: ... endp - &data[0]
```

Hier findet allerdings keinerlei Überlaufkontrolle statt!

.W[
Enthält der ausgelesene Container mehr Elemente als `data` aufnehmen kann,
könnten **dahinter** (= an größeren Adressen im Speicher) liegende Variablen
überschrieben werden.
]

---
template: plain
header: #### Kopieren zwischen unterschiedlichen Container-Typen

```
using namespace std;
vector<double> v;

// from standard input float-s appended to vector ...
copy(istream_iterator<float>(cin), istream_iterator<float>(),
     back_inserter(v));

// ... to classic array (widening to double) ...
double data[100]; const auto N = sizeof data / sizeof data[0];

// ... (protecting against overflow) ...
if (v.size() < N) v.resize(N);

// ... (remembering filling state) ...
const auto endp = copy(v.begin(), v.end(), data);

// ... to set (truncating to integer) ...
set<int> s; copy(data, endp, inserter(s, s.begin()));

// ... to stdout with semicolon and space after each value
copy(s.begin(), s.end(), ostream_iterator<int>(cout, "; "));
```

.F[:
Im Rahmen der Zuweisungskompatibilität erfolgt beim Kopieren zwischen
unterschiedlichen Containern auch die Typ-Konvertierung des Elementtyps.
]

---
template: plain
header: #### Kopieren zwischen gleichartigen Container-Typen

[PODs]: http://www.cplusplus.com/reference/type_traits/is_pod/

Obwohl mit dem `std::copy`-Algorithmus *1:1-Kopien* gleichartiger Container
problemlos möglich sind, wird hier eine Zuweisung eher sinnvoll sein, also:
```
std::vector<MyClass> v1, v2;
…
v2 = v1;
```
Und nicht (evtl. nach einem `v2.clear()`):
```
std::copy(v1.begin(), v1.end(), std::back_inserter(v2));
```
.N[
Insbesondere kann der spezifisch für eine Container-Klasse definierte
Zuweisungs-Operator spezielle Eigenschaften der jeweiligen Abspeicherungsart
berücksichtigen.._[]
]

.F[:
Im Gegensatz zum generischen Kopieren werden dabei oft [PODs] (plain old data
types) als Elementtyp erkannt und dann eine unterschiedliche Spezialisierung
verwendet, welche die Operation in ein `std::memmove` oder `std::memcpy`
überführt.
]

---
template: plain
header: ### Einige typische Algorithmen in Beispielen

Die folgenden Programmfragmente gehen jeweils aus von einem STL-Container
```
std::vector<int> v;
```
der mit einigen Datenwerten gefüllt wurde.

#### Zählen der Elemente mit dem Wert 542
```
auto n = std::count(v.begin(), v.end(), 542);
```

---
template: plain
header: #### Suchen des ersten Elements mit dem Wert 542
```
const auto f = std::find(v.begin(), v.end(), 542);
if (f != v.end()) {
    // erstes (passendes) Element gefunden
    …
}
else {
    // kein passendes Element vorhanden
    …
}
```

---
template: plain
header: #### Löschen aller Elemente mit dem Wert 542

```
const auto end = std::remove(v.begin(), v.end(), 542);
```

Die Variable `end` enthält nun einen Iterator, der das neue (logische) Ende des
(von der Anzahl der Elemente gesehen größeren) Containers bezeichnet.
```
// nicht mehr zum Inhalt zu zaehlende  Elemente loeschen
v.erase(end, v.end());
```

.N[
Code wie der gerade gezeigte ist vor allem in generischen Templates zweckmäßig,
bei denen die Klasse von `v` völlig offen gehalten werden soll.._[]
]

.F[:
Wird ein bestimmter, typischer und auch häufiger Anwendungsfall von solchen
Templates deutlich sub-optimal behandelt, kann immer noch eine entsprechende
Spezialisierung erfolgen.
]

---
template: plain
header: ## Callbacks aus Algorithmen

---------------------------------------------------------------------------------

* [Generelle Möglichkeiten für Callbacks		](#callbacks_general)
* [Callback mit Funktor 				](#callback_with_functor)
* [Callback mit Lambda					](#callback_with_lambda)
* [C++14 Erweiterungen für Lambdas			](#cpp14_lambda_extensions)
* [Prädikate für Algorithmen (generell)			](#predicates_general)
* [Prädikate für Algorithmen (Beispielserie)		](#predicate_examples))
* [Algorithmen vs. spezifische Member-Funktionen	](#generic_vs_specific)

---------------------------------------------------------------------------------

---
template: plain
name: callbacks_general
header: ### Generelle Möglichkeiten für Callbacks

Prinzipiell sind Algorithmen zwar Code aus einer Bibliothek, häufig enthalten diese
aber "*Callbacks*" an die Applikation.

Dafür existieren drei Möglichkeiten:

* Klassische (C-) Funktionen und Übergabe als Funktionszeiger:
  * hierbei wird nur Name der Funktion angegeben;
  * die anschließenden runden Klammern entfallen.

* Objekte mit überladener `operator()` Member-Funktion – sogenannte Funktoren:
  * oft wird eine Objekt-Instanz direkt bei der Argumentübergabe erzeugt;
  * in diesem Fall enthalten nachfolgenden runde Klammern
    * die Argumentliste Konstruktors oder
    * bleiben leer (= Default Konstruktor)

* C++11 Lambdas

---
template: plain
name: callback_with_functor
header: ### Callback mit Funktor

Ein typisches Beispiel für die Notwendigkeit eines Call-Backs besteht im Fall
des Algorithmus `std::for_each`, wobei einer Schleife über alle Elemente eines
Containers übergeben wird, was mit jedem Element zu tun ist, z.B. es ausgeben.

Zunächst ein Funktor, der dies leistet:
```
struct PrintWords {
    void operator()(const std::string &e) {
        cout << ": " << e << "\n";
    }
};
```

.N[
Bei der Verwendung folgen dem Klassennamen des Funktors runde Klammern.
]

Dies gilt zumindest dann, wenn – wie oft üblich – ein (temporäres) Objekt der
Funktor-Klasse als Argument an `std::for_each` übergeben wird:
```
std::for_each(v.begin(), v.end(), PrintWords());
```

---
template: plain
header: #### Vergleich mit Funktion

Mit einer Funktion sieht das Beispiel so aus:
```
void print_words(const std::string &e) {
    cout << ": " << e << "\n";
};
```
.N[
Hier entfallen die Klammern, da der Name der Funktion weitergegeben wird.
]

```
std::for_each(v.begin(), v.end(), print_words);
```

---
template: plain
header: #### Lokale Daten in Funktoren

Einer der Vorteile von Funktoren ist, dass sich im Funktor lokale Variable
sauber kapseln lassen.

Hierzu ein leicht modifiziertes Beispiel, bei dem der Funktor die Argumente
durchnummeriert:
```
struct PrintWordsEnumerated {
    void operator()(const std::string &s) {
        std::cout << ++n << ": " << s << "\n";
    }
    PrintWordsEnumerated() : n(0) {}
private:
    int n;
};
```

---
template: plain
header: #### Parameterübergabe an Funktor

Über zusätzliche Member-Daten, die im Konstruktor des Funktors initialisiert
werden, lassen sich auch Argumente aus der Aufruf-Umgebung weiterreichen:
```
struct PrintWordsEnumerated {
    void operator()(const std::string &e) {
        os << ++n << ": " << e << "\n";
    }
    PrintWordsEnumerated(std::ostream &os_) : n(0), os(os_) {}
private:
    int n;
    std::ostream &os;
};
```

Diese sind dann bei der Verwendung zu versorgen:
```
std::for_each(v.begin(), v.end(),
              PrintWordsEnumerated(std::cout));
```

---
template: plain
header: #### Parameter aus Aufrufumgebung

Die mit der Übergabe von Parametern geschaffene Flexibilität ist spätestens
dann wichtig, wenn es sich um Informationen handelt, die in der Aufruf-Umgebung
in lokalen Variablen oder Argumenten vorliegen:
```
void foo(std::ostream &output) {
    …
    std::for_each(v.begin(), v.end(),
                  PrintWordsEnumerated(output));
    …
}
```

.N[
Dies ist nur noch mit Funktoren (und Lambdas) sauber abzubilden, mit einer
Funktion scheidet diese Technik aus.
]

---
template: plain
header: #### Datentypen in Funktoren

Diese richten sich nach der gewünschten Zugriffsart:

|Zugriffsart       |Daten-Member      |Konstruktor-Argument          |
|------------------|------------------|------------------------------|
|über Kopie        |(konstanter) Wert |Wert oder (konstante) Referenz|
|direkt, nur lesend|konstante Referenz|(konstante) Referenz          |
|auch schreibend   |Referenz          |Referenz                      |

Referenzen für Daten-Member dürfen keinesfalls mit Wertübergabe im
Konstruktor kombiniert werden:
```
class SomeFunctor {
    …
    T data1;
    const T &data2;
public:
    …
    SomeFunctor(const T& d1, T d2)
        : data1(d1)  // OK
        , data2(d2)  // SERIOUS PROBLEM HERE !!
    {}
};
```

---
template: plain
name: callback_with_lambda
header: ### Callback mit Lambda

Die in C++ neu eingeführte Lambdas haben gegenüber Funktoren den Vorteil, dass
der ausgeführte Code direkt als Parameter des aufgerufenen Algorithmus zu sehen
ist und nicht an einer mehr oder weniger weit davon entfernten Stelle steht.._[]

#### Grundlegendes Beispiel mit Lambda

Im einfachsten Fall greift das Lambda nur auf das vom Aufrufer übergebene
Argument und evtl. globale Variable bzw. Objekte zu:
```
std::for_each(v.begin(), v.end(),
              [](const std::string &s) {
                      std::cout << s << '\n';
              }
);
```

.F[:
Mit modernen IDEs, welche die Implementierung einer Funktion oder Klasse als
Pop-Up zeigen, sobald man kurze Zeit den Mauszeiger darüber ruhen lässt, spielt
dieser Nachteil aber nur eine geringe Rolle.
]

---
template: plain
header: #### Lambda mit Capture List

Zum Zugriff in den Sichtbarkeitsbereich des umgebenden Blocks muss die
*Capture-List* verwendet werden:
```
void foo(std::ostream &output) {
…
std::for_each(v.begin(), v.end(),
              [&output](const std::string &s) {
                  output << s << '\n';
              }
);
```

Darin werden die übergebenen Bezeichner aufgelistet, ggf. mit vorangestelltem
`&`-Zeichen, wenn Referenz-Übergabe erfolgen soll.

---
template: plain
header: #### Lambda mit privaten Daten

Ein Funktor kann problemlos private Daten besitzen, welche ausschließlich dem
überladenen Funktionsaufruf zur Verfügung stehen.

In C++11 sind die Möglichkeiten zur Kapselung in dieser Hinsicht für ein Lambda
etwas eingeschränkt: lokale Daten können nicht wirklich privat sein sondern sind
auch in der Aufrufumgebung sichtbar:
```
void foo(std::ostream &output) {
    …
    int line_nr = 0;
    std::for_each(v.begin(), v.end(),
                  [&line_nr, &output](const std::string &s) {
                      output << ++line_nr << s << '\n';
                  }
    );
    …
}
```
Obiges zeichnet zugleich den allgemeinen Weg vor, wie ein Lambda auf seine
Aufrufumgebung nicht nur lesend sondern auch modifizierend einwirken kann.

---
template: plain
name: cpp14_lambda_extensions
header: ### C++14 Extensions to Lambdas

With C++14 lambdas have been further extended:._[]

* Lambdas may use [`auto` as argument type](#cpp14_lambda_auto_arg), thus
  allowing generic lambdas, similar to functors with a templated `operator()`.

* The capture list may define so-called [init-captures](#cpp14_lambda_init),
  giving the same options as local (independent) data members of a functor,
  with (possibly context dependant) initialisation.

.F[:
For the curious, C++14 also fixed a minor oversight in the lambda syntax
specification of C++11: While the idea was to allow the lambda argument list
to be completely dropped if empty, including its parentheses if empty, that
was forgotten in the syntax for `mutable` lambdas.

---
template: plain
name: cpp14_lambda_auto_arg
header: #### C++14 `auto`-typed Lambda Arguments

Prior to C++14 argument types of lambdas had to be spelled out explicitly,
which could sometimes be wordy and inconvenient:._[]
```
std::map<std::string, unsigned long> m;
…
std::map<std::string, unsigned long> other;
std::copy_if(m.cbegin(), m.cend(), std::inserter(other),
             [](const std::pair<std::string, unsigned long> &e) {
                 return e.second != 0;
             });
```

Clearly, in the above scenario `auto`-typed arguments for lambdas offer a big
simplification:
```
std::copy_if(m.cbegin(), m.cend(), std::inserter(other),
             [](const auto &e) { return e.second != 0; });
```

.F[:
The problem could be slightly alleviated if there were a type definition for the
map, say `C`, allowing to refer to the element type inside as `C::value_type`
(or if `C` were a dependant type as `typename C::value_type`).
]

---
template: plain
header: #### C++14 Lambda Init-Captures

This C++14 extension allows a third form of capture:
```
// assuming local scope here
SomeType local;
…
… [local]( … ) { // capturing by value-copy
   … // access local copy read-only
  } …
… [local]( … ) mutable { // capturing by value-copy
    … // access local copy modifiable
  } …
… [&local]( … ) { // capturing by reference
    … // access and possibly modify local in outer scope
  } …
… [mine = local]( … ) { // init-capture (C++14 only)
    … // access mine modifiable, initial value from local
  } …
```

The initialisation of init-captures may also use arbitrary expressions.
```
… [mine = 2*local + 1] ( … ) { … } …
… [mine = std::make_shared<SomeType>(local)] ( … ) { … } …
```

---
template: plain
header: #### Extended Type Deduction for C++14 Lambdas

With the extensions to lambdas in C++14 also two new contexts for type deduction
were introduced:

* In case of `auto`-typed lambda arguments the type deduction rules are the same
  as for template functions (and hence **not** exactly the same as for
  `auto`-typed variables!)

* In case of init-captures the type of the newly introduced identifier is determined
  is like for `auto`-typed variables.

---
template: plain
header: #### Init-Captures and Move-Construction

Init-captures solve a problem that lay outside the capabilities of lambdas as
defined by C++11:

* When capturing by value-copy, only the copy-constructor applies.

  * In an init-capture, if the initialising expression is a temporary, the
    move construction may take place – given a move constructor exists and
    the compiler does not choose to prefer [(N)RVO].

Therefore only init-captures allow the following (assuming `local` is a move-only
type._[] or it is its last use and copying is expensive):
```
… [mine = std::move(local)] ( … ) { … } …
```

.F[:
Like e.g. `std::unique_ptr`, `std::thread`.
]

[(N)RVO]: http://en.wikipedia.org/wiki/Return_value_optimization
[ugly work-around]: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3610.html

---
template: plain
header: #### C++14 Init-Capture Pitfalls

One possible pitfall with init-captures compared to value-copy is this:

.W[
Classic (C-style) arrays are treated as value objects captured by value-copy
but decay to pointers (to the first element) in init-captures.
]

<!-- -->

.pull-left[
Secure when capturing value-copies:
```
auto foo() {
    int primes[] = {2, 3, 5, 7};
    return [primes]( … ) {
               … // lambda-body
           };
};
```
]
.pull-right[
Refers to invalidated stack memory:
```
auto foo() {
    int primes[] = {2, 3, 5, 7};
    return [p = primes]( … ) {
               … // lambda-body
           };
};
```
]

<!-- -->

.N[
This can be used as an argument to prefer `std::array` over classic arrays, as
then in both cases copying the content would be copied.
]

---
template: plain
name: predicates_general
header: ### Prädikate für Algorithmen (generell)

Viele STL-Algorithmen haben eine Variante, in der man ein Auswahlkriterium
(Prädikat) flexibel angeben kann. Es handelt sich dabei typischerweise um die
Algorithmus-Variante, die mit `_if` endet.

Als Beispiel zur Verdeutlichung des Prinzips kann wieder die Implementierung
eines Algorithmus zum Kopieren von einem Container in einen anderen dienen,
diesmal beschränkt auf ausgewählte Elemente:._[]
```
template<typename T1, typename T2, typename T3>
T2 my_copy_if(T1 from, T1 upto, T2 dest, T3 pred) {
    while (from != upto) {
        const auto tmp = *from++;
        if (pred(tmp))
            *dest++ = tmp;
    }
    return dest;
}
```

.F[:
In die STL wurde der Algorithmus `std::copy_if` erst mit C++11 aufgenommen.
Allerdings erfüllt das seit C++98 vorhandene `std::remove_copy_if` denselben
Zweck, wenn man das Prädikat invertiert angibt.
]

---
template: plain
header: #### Möglichkeiten zur Übergabe von Prädikaten

Da es sich um eine Template handelt, gilt für das Prädikat `pred` lediglich,
dass als aktuelles Argument etwas "Aufrufbares" (callable) anzugeben ist.

Damit kommen

* [Funktionszeiger](#predicate_fptr),
* [Funktoren](#predicate_functor) und
* [C++11-Lambdas](#predicate_lambda)

in Frage, sofern diese als Rückgabewert ein `bool` liefern.._[]

.F[:
Oder präziser: einen Typ, der ggf. in `bool` umgewandelt wird.
]

Im folgenden werden in einem Container mit Ganzzahlen alle Elemente mit einem
Wert kleiner als 42 gezählt.

---
template: plain
name: predicate_fptr
header: #### Prädikat mit Funktionszeiger übergeben

Zunächst muss die Funktion definiert werden:
```
bool lt42(int n) { return n < 42; }
```
Dann kann sie als Prädikat dienen:
```
… std::count_if( … , … , lt42);
```
.W[
Viele Compiler generieren hier grundsätzlich einen Funktionsaufruf, womit diese
Variante zur Laufzeit recht ineffizient sein kann.._[]
]

.F[:
Die GNU-Compiler erzeugen seit einigen Jahren zumindest auf den höheren
Optimierungsstufen aber deutlich besseren Code, indem sie bei sichtbarer
Funktionsdefinition in Fällen wie dem Obigen eine Inline-Umsetzung vornehmen,
selbst wenn die Funktion `lt42` nicht mit `inline` markiert wurde.
]

---
template: plain
name: predicate_functor
header: #### Prädikat mit Funktor übergeben

Zunächst muss die Funktor-Klasse definiert werden:
```
struct Lt42 {
    bool operator()(int n) const { return n < 42; }
};
```
Dann wird sie als Prädikat zu einem temporären Objekt instanziiert:
```
… std::count_if( … , … , Lt42());
```
.N[
Ist der Funktionsaufruf-Operator explizit oder wie oben implizit `inline`,._[]
wird der erzeugte Code schneller (und oft sogar kleiner) sein als bei Übergabe
eines Prädikats mittels Funktionszeiger.
]

.F[:
In Bezu auf den GCC (g++) sei aber daran erinnert, dass bei ausgeschalteter
Optimierung (`-O0`) grundsätzlich *keine* Funktion als `inline`-Funktion
umgesetzt wird.
]

---
template: plain
name: predicate_lambda
header: #### Prädikat mit C++11-Lambda übergeben

Hier ist das Prädikat unmittelbar bei der Übergabe zu sehen:
```
… std::count_if( … , … , [](int n) { return n < 42; });
```

#### Alternative mit Standard-Bibliotheksfunktion

Diese mit C++98 eingeführte Möglichkeit wirkt sehr unleserlich und wird evtl.
auch aus diesem Grund nur selten benutzt:
```
… std::count_if( … , … , std::bind2nd(std::less<int>(), 42));
```

---
template: plain
name: predicate_examples
header: ### Prädikate für Algorithmen (Beispielserie)

Abschließend eine weitere Beispielserie zum Vergleich der verschiedenen
Möglichkeiten, Algorithmen mit Prädikaten als Bedingungstests zu versorgen:

In der ersten Gruppe geschieht dies ohne jegliche Flexibilität – alles ist
für den jeweiligen Einzelfall "hart kodiert".

* [Funktionszeiger			](#predicate_specific_fptr)
* [Funktor				](#predicate_specific_functor)
* [Lambda				](#predicate_specific_lambda)

In der zweiten Gruppe (für welche Funktionszeiger bereits nicht mehr mächtig
genug sind), besteht mehr Flexibilität – wobei teilweise ähnliche Techniken
aus einem unterschiedlichen Grund zur Anwendung kommen.

* [Parametrisierter Funktor		](#predicate_parametrized_functor)
* [Zugriff auf lokale Daten mit Funktor	](#predicate_capturing_functor)
* [Zugriff auf lokale Daten mit Lambda	](#predicate_capturing_lambda)


---
template: plain
name: predicate_specific_fptr
header: #### Prädikat mit spezifischem Funktionszeiger

Dies ist die aus der C-Programmierung bekannte Technik.

Das Beispiel gibt alle Elemente mit einem Wert ungleich 524 aus:
```
bool notEq524(int n) { return n != 524; }

void foo(const std::vector<int> &v) {
    …
    std::copy_if(v.begin(), v.end(),
       	         std::ostream_iterator<int>(cout, " "),
                 notEq524
    );
    …
}
```

---
template: plain
name: predicate_specific_functor
header: #### Prädikat mit spezifischem Funktor

Dies ist eine für C++-typische Technik.

Das Beispiel gibt alle Elemente mit einem Wert ungleich 524 aus:
```
struct NotEq524 {
    bool operator()(int n) const { return n != 524; }
};
void foo(const std::vector<int> &v) {
    …
    copy_if(v.begin(), v.end(),
            std::ostream_iterator<int>(std::cout, " "),
            NotEq524()
    );
    …
}
```

---
template: plain
name: predicate_specific_lambda
header: #### Prädikat mit spezifischem Lambda

```
void foo(const std::vector &v) {
    …
    std::copy_if(v.begin(), v.end(),
                 std::ostream_iterator<int>(std::cout, " "),
                 [](int n) { return n != 524; }
    );
    …
}
```

---
template: plain
name: predicate_parametrized_functor
header: #### Prädikat mit allgemeiner verwendbarem Funktor

Der im folgenden verwendete Funktor kann in allen Vergleichen benutzt werden,
welche auf die Prüfung hinauslaufen, ob eine Ganzzahl ungleich zu einem
gegebenen Wert ist:
```
class NotEq {
    const int cmp;
public:
    NotEq(int c) : cmp(c) {}
    bool operator()(int n) const { return n != cmp; }
};
…
void foo(const std::vector &v) {
    …
    std::copy_if(v.begin(), v.end(),
                 std::ostream_iterator<int>(std::cout, " "),
                 NotEq(524)
    );
    …
}
```

---
template: plain
name: predicate_capturing_functor
header: #### Prädikat mit Funktor und Zugriff auf lokalen Kontext

Um auf lokale Variablen oder Parameter._[] einer aufrufenden Funktion zugreifen
zu können, muss ein Funktor entsprechende Daten-Member besitzen und sein
Konstruktor muss diese initialisieren:
```
void foo(const std::vector &v, int hide) {
    …
    std::copy_if(v.begin(), v.end(),
                 std::ostream_iterator<int>(cout, " "),
                 NotEq(hide)
    );
    …
}
```
.F[:
Die Parameter einer Funktion entsprechen nahezu ihren lokalen Variablen.
Es kommt lediglich die (garantierte) Initialisierung mit vom Aufrufer
anzugebenden Werten hinzu.
]

---
template: plain
name: predicate_capturing_lambda
header: #### Prädikat mit Lambda und Zugriff auf lokalen Kontext

Um auf lokale Variablen oder Parameter._[] einer aufrufenden Funktion zugreifen
zu können, muss ein Lambda die Capture-List verwenden:

```
void foo(const std::vector &v, int hide) {
    …
    std::copy_if(v.begin(), v.end(),
    	         std::ostream_iterator<int>(std::cout, " "),
                 [hide](int n) { return n != hide; }
    );
    …
}
```

.N[
Lambdas in Member-Funktionen einer Klasse können hier auch `this` angeben. Damit
besteht innerhalb des Lambdas Zugriff auf alle Member (Daten und Funktionen)
desjenigen Objekts, für welches die das Lambda enthaltende Member-Funktion
ausgeführt wird.
]

---
template: plain
name: generic_vs_specific
header: ### STL Algorithmen vs. spezifische Member-Funktionen

Ist die Klasse des Containers genau festgelegt, steht alternativ zu einem
generischen Algorithmus eventuell eine spezifische Member-Funktion zur
Verfügung, deren Verwendung in der Regel einfacher und effizienter ist.

Beispielsweise wird bei löschenden Algorithmen gerne vergessen, dass der
Container dadurch nicht tatsächlich kleiner wird.._[] Zwar könnte man das
Problem so lösen
```
std::list<std::string> li;
…
auto end = std::remove(li.begin(), li.end(), 542);
li.erase(end, li.end());
```

aber kompakter und effizienter geht es so:
```
	li.remove(542);
```

.F[:
Vielmehr werden – [wie bereits dargestellt](#removing_logically_only) – nur
Elemente umkopiert oder getauscht und als Ergebnis wird ein Iterator
zurückgegeben, der das neue logische Ende anzeigt.
]
---
layout: false
template: blank
name: part5

# [C++ FOR](#agenda) (Part 5) C++ from Top – Classes and Class Relations

-------------------------------------------------------------------

1. [Beziehungen zwischen Klassen	](#classes_and_relations)
1. [Unterstützung der Mehrfachvererbung	](#multiple_inheritance)
1. [Rautenförmige Ableitungs-Hierarchien](#diamond_shapes)
1. [Beispiele zu Klassenbeziehungen	](#example_relations)

-------------------------------------------------------------------

---
template: linkinfo
graphic: UML-ClassesAndRelations
name: classes_and_relations
header: ## Beziehungen zwischen Klassen

---------------------------------------------------------------------

* [Klasse (minimal)			](#class_minimal)
* [Klasse (detailiert)			](#class_detailed)
* [Instanziiertes Objekt		](#class_instantiated)
* [Parametrisierte Klasse		](#class_template)

----------------------------------------------------------------------

* [Assoziation				](#association)
* [Komposition				](#composition)
* [Aggregation				](#aggregation)

----------------------------------------------------------------------

* [(Mehrfach-)](#multibased) [Vererbung](#inheritance)
* [Interface				](#interface)
* [Abstrakte Basisklasse		](#abstract_base)

----------------------------------------------------------------------

* ["Rautenförmige" und …		](#diamond_shaped_inheritance)
* [… allgemein mehrstufige
   Vererbungs-Hierarchien		](#broader_deeper_inheritance)

----------------------------------------------------------------------

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Some Class
name: class_minimal
header: ### Klasse (minimal)

[UML]: http://de.wikipedia.org/wiki/Unified_Modeling_Language
[RUP]: http://en.wikipedia.org/wiki/IBM_Rational_Unified_Process
[OOM]: http://www.techopedia.com/definition/28584/object-oriented-modeling-oom

Die minmale Darstellung einer Klasse in der [UML] besteht aus einem Rechteck,
in welchem der Klassenname steht.

.N[
Klassen und Beziehungen zwischen Klassen sind die wichtigsten Bestandteile
einer *Objekt-Orientierten-Modellierung* ([OOM]).
]

Häufig wird eine solche etwa

* beginnen mit einem High-Level-Design (HLD),

* das eine Reihe von Verfeinerungsschritten durchläuft,

* …

* und schließlich enden mit einer Lösungs-Implementierung.._[]

.F[:
Auch im Kern sehr formale Prozesse wie etwa [RUP] beinhalten dabei die
Möglichkeit eines "Tailoring", indem nur diejenigen Artefakte tatsächlich
erstellt werden, von denen man sich einen konkreten Nutzen verspricht.
]

---
template: plain
header: #### Objektorientierte Vorgehensweise

[OOAD]: http://de.wikipedia.org/wiki/Objektorientierte_Analyse_und_Design

Die übliche Abfolge der Schritte ist

* zunächst eine Objektorientierte (Problem-) Analyse (OOA) vorzunehmen,

* der ein mehr oder weniger detailliertes Objekt-Orientiertes (Lösungs-) Design
  (OOD) folgt,

* welches schließlich – vorzugsweise den Mitteln der Objekt-Orientierten
  Programmierung (OOP) implementiert wird.

Die beiden Begriffe *OOA* und *OOD* werden mitunter auch zusammengefasst zu
*[OOAD]* (Objektorientierte Analyse und Design), oder unter Hinzuziehung der
Programmierung zu *OOADP*.

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Instantiated Objects
name: class_instantiated
header: ### Klassen vs. Objekte

Hierfür benutzt die UML im Wesentlichen die selbe Symbolik – der Unterschied
besteht lediglich darin, dass

* bei Objekten der Name unterstrichen ist und
* der Klassenname auch entfallen kann.._[]

#### Klassen
Diese kommen einem *Bauplan* gleich und beschreiben in der UML-Darstellung alle
*Gemeinsamkeiten* der Objekte, die gemäß diesem Bauplan erstellt werden.

#### Objekte
Diese sind *instanziierte Klassen* und beinhalten in der UML-Darstellung die
*Unterschiede* aus, welche trotz des gemeinsamen Bauplans bestehen.

.F[:
Die tatsächlichen Regeln der grafischen Darstellung sind komplizierter und
erlauben prinzipiell, dass ein dem Namen des Objekts ein Doppelpunkt und dann
der Klassenname folgt, wobei beide Namen optional sind und weggelassen werden
können (beispielsweise wenn sie sich aus dem Kontext ergeben).
]

---
template: plain
header: #### Klassen und Objekte in C++

In kompilierten Sprachen wie C++, in denen die Unterstützung der
Objektorientierten Programmierung nicht darin besteht, quasi einen Interpreter
für ein Objekt-System zur Laufzeit anzubieten, gibt es in der Regel einen
weiteren charakteristischen Unterschied zwischen Klassen und Objekten:

.I[
Klassen sind in C++ **statisch** in dem Sinne, dass sie

* vollständig zur Compilezeit beschrieben werden, während
* Objekte sich typischerweise zur Laufzeit verändern.
]

---
template: plain
header: #### C++-Klassen als Compilezeit-Konstrukt

[Itcl]:      http://incrtcl.sourceforge.net/itcl/
[Smalltalk]: http://www.smalltalk.org/smalltalk/whatissmalltalk.html
[Python]:    http://www.python.org/
[Java]:      https://www.java.com/en/download/whatis_java.jsp
[C Sharp]:   http://www.techopedia.com/definition/26272/c-sharp

Die vollständige Festlegung einer Klasse zur Compilezeit ist ein wesentlicher
Unterschied zu deutlich dynamischeren OOP-Sprachen, wie etwa

* [Smalltalk]

* [Python] oder

* [Itcl]

deren Klassen und Objekte – auch und gerade hinsichtlich ihrer Member-Daten und
-Funktionen zur Laufzeit völlig dynamisch erzeugt werden können, und somit z.B.
auch datenabhängig erstellt werden können.._[]

.F[:
[Java] und [C Sharp] sind in dieser Hinsicht wiederum eher ähnlich zu C++,
besitzen allerdings mehr standardisierte Möglichkeiten zur Introspektion und
können mit Hilfe kleiner Kunstgriffe in großen Teilen den Eindruck eines zur
Laufzeit dynamischen Verhaltens bieten.
]


---
template: withinfo
graphic: UML-ClassesAndRelations
section: Class With Some Details
name: class_detailed
header: ### Klasse (detailiert)

In stärkerer Detaillierung beschrieben kann einer Klasse im UML-Diagramm
folgendes hinzugefügt werden:

* Ein Abschnitt mit Attributen

* Ein Abschnitt mit Methoden

Beides wird innerhalb des Klassensymbols durch eine waagrechte Linie getrennt und
beides ist optional.

.N[
Pragmatiker weisen gerne darauf hin, dass die UML **keineswegs** die Nutzung
aller ihrer notationalen Möglichkeiten vorschreibt sondern der
Detaillierungsgrad eines Klassendiagramms stets an dessen Zweck bzw. dem
Zielpublikum entsprechend ausgerichtet sein sollte.
]

---
template: plain
header: #### Attribute

Diese enthalten *Datenwerte* und sind im UML-Diagramm daran zu erkennen, dass
ihnen **keine** runden Klammern folgen. Ein nachgestellter, durch einen
Doppelpunkt abgetrennter Datentyp ist dabei optional.

.I[
In C++ ist hierfür eher die Bezeichnung *Member-Daten* üblich.
]

---
template: plain
header: #### Methoden

Diese enthalten *ausführbare Abläufe* und sind im UML-Diagramm daran zu
erkennen, dass ihnen **runde Klammern folgen**, ggf. auch leere.

.I[
In C++ ist hierfür eher die Bezeichnung *Member-Funktionen* üblich.
]

Innerhalb der Klammern können optional zu übergebende Parameter benannt werden,
inklusive deren Typ (nachgestellt und durch Doppelpunkt getrennt), und der
geklammerten Parameterliste kann (ebenfalls durch einen Doppelpunkt getrennt)
ein Rückgabe-Typ folgen.

---
template: plain
header: #### Zugriffsschutz

Ein weiteres, in der detaillierten Darstellung von UML-Klassen mögliches
Notationselement bezieht sich auf den Zugriffsschutz und kann sowohl
Member-Daten wie auch Member-Funktionen optional vorangestellt werden:

* `+` (öffentlich) – `public` in C++

  * jeder, der Zugriff zu einem Objekt dieser Klasse hat, kann auf diese
    Member-Daten zugreifen bzw. diese Member-Funktionen ausführen.

* `#` (geschützt) – `protected` in C++

  * erreichbar nur für die Member-Funktionen der eigenen und davon abgeleiteter
    Klassen.

* `-` (privat) – `private:` in C++

   * erreichbar nur für die Member-Funktionen der eigenen Klasse.

---
template: plain
header: #### C++ Zugriffsschutz: `class` vs. `struct`

Eine Besonderheit gilt in C++ für den Default des Zugriffsschutzes:

* In einer `struct` ist dieser `public`,
* in einer `class` dagegen `private`.

Abgesehen von diesem Unterschied sind die Schlüsselworte `struct` und `class`
bei der Definition einer Klasse austauschbar.

.pull-left[
```
class MyClass {
// starts private
    …
public:
    …
};

struct MyStruct {
// starts public
    …
private:
    …
};
```
]

.pull-right[
```
struct MyClass {
private:
    …
public:
    …
};

class MyStruct {
public:
    …
private:
    …
};
```
]

---
template: plain
header: #### Klassen-Attribute und -Methoden

In der detaillierten Darstellung einer UML-Klasse unterstrichene Bezeichner
stellen sog. Klassen-Attribute oder -Methoden dar und entsprechen in der
C++-Programmierung den Zusatz `static`.

##### Klassen-Attribute

Diese sind **nicht** pro Objekt sondern pro Klasse gespeichert.._[]

.F[:
Eine typische Anwendung wäre z.B. eine fortlaufende Nummerierung aller jemals
erzeugten Objekte einer Klasse, wobei ein Klassen-Attribut die nächste zu
vergebende Nummer enthält.
]

##### Klassen-Methoden

Diese können ausschließlich auf Klassen-Attribute zugreifen. In C++

* bieten sie zum einen eine kleine Effinzienzverbesserung, da bei ihrem Aufruf
  keine Objektadresse übergeben werden muss, und

* sind zum anderen auch ohne ein vorhandenes Objekt durch Voranstellen des
  Klassennamens gefolgt vom Scope-Operator (`::`) aufrufbar.

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Template Class
name: class_template
header: ### Parametrisierte Klasse

[Generic Programming]: http://en.wikipedia.org/wiki/Generic_programming

Hierbei handelt es sich um die UML-Sichtweise auf das, was in C++ mit dem
Mechanismus der Templates verfügbar ist und auch die Bezeichnung *Generische
Programmierung* ([Generic Programming]) trägt.

.N[
Ursprünglich entsprang der Template-Mechanismus in C++ dem Wunsch, Datentypen
und Compilezeit-Konstanten – etwa Typ und Anzahl der Elemente in einem Array –
parametrisieren zu können, wenn dieses Member einer Klasse ist.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Association
name: association
header: ### Assoziation

Eine Assoziation ist die unspezifischste aller Beziehungen, die zwischen zwei
Klassen bestehen können, und besagt mehr oder weniger nur, dass diese beiden
Klassen eine bestimmte Aufgabe **gemeinsam** erledigen.

Die tatsächliche Beziehung kann stärker sein und auch eine der anderen
Beziehungsformen annehmen, insbesondere die der

* [Aggregation](#aggregation) oder

* [Komposition](#composition).

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Association
name: undirected_association
header: ### Ungerichtete Assoziation in C++

Streng genommen erfordert die Assoziation in C++, dass zwei Klassen gegenseitig
aufeinander verweisen, was z.B. mittels zweier Pointer.._[]

.F[:
Siehe: [Examples/ClassRelations/general_association.cpp](../Examples/ClassRelations/general_association.cpp)
]

.I[
Programmiertechnisch lässt sich nur einer dieser beiden Pointer durch eine
Referenz ersetzen: bei zwei Referenzen ist die (wechselseitige) Initialisierung
nicht realisierbar.
]

#### Beispiel-Code zur ungerichteten Assoziation

.pull-left[
```
class Parent {
    class Child *c;
    …
    Parent() : c(nullptr) {}
    void setChild(Child *c_) {
        c = c_;
    }
};
…
Parent first;
```
]

.pull-right[
```
class Child {
    class Parent &p;
    …
    Child(Parent &p_)
        : p(p_) {
        p.setChild(this);
    }
};
…
Child second(first);
```
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Association
name: directed_association
header: ### Gerichtete Assoziation

Durch Hinzufügen eines Pfeils an der Assoziationslinie wird ggf. die
*eingeschränkte Navigierbarkeit* dargestellt.._[]

.F[:
Siehe: [Examples/ClassRelations/directed_association.cpp](../Examples/ClassRelations/directed_association.cpp)
]

.I[
Für die programmiertechnische Umsetzung bedeutet dies eine Vereinfachung, da
nun klar, dass nur eine Klasse auf die andere verweisen muss – z.B. per Zeiger
oder Referenz.
]

#### Beispiel-Code zur gerichteten Assoziation
.pull-left[
```
class Parent {
    // CANNOT call its child
    // directly (but the child
    // could hand over this on
    // a call to the parent)
    …
};
…
Parent first;
```
]

.pull-right[
```
class Child {
    class Parent &p;
    …
    Child(Parent &p_)
        : p(p_)
    {}
};
…
Child second(first);
```
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Composition
name: composition
header: ### Komposition

Komposition wird durch eine ausgefüllte Raute zum Ausdruck gebracht, welche an
einem Ende der Assoziationslinie hinzugefügt wird.._[]

.F[:
Siehe: [Examples/ClassRelations/composition.cpp](../Examples/ClassRelations/composition.cpp)
]

.I[
Komposition ist eine häufige, stärkere Form der Aggregation, bei der die
Lebensdauer des "Teils" (Ende ohne Raute) an die der "Gesamtheit" (Ende
mit Raute) gebunden ist.
]

#### Beispiel-Code zur Komposition
.pull-left[
```
class Car {
    class Motor engine;
    …
    Car( … )
        : engine( … )
    {}
};
…
Car someCar; // also creates
             // the engine
```
]

.pull-right[
```
class Motor {
    // will usually be created
    // as part of a car and
    // also scrapped with it
    …
};
```
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Aggregation
name: aggregation
header: ### Aggregation

Die Aggregation ist eine nur geringfügig stärkere Form der Assoziation, indem
sie

* die Klasse auf einer Seite zur *Gesamtheit* (Aggregat)

* die Klasse auf anderen zu *deren Teil* erklärt.

Gesamtheit und Teil können dabei unabhängig voneinander existieren.

.N[
In der UML-Darstellung wird an die (Assoziations-) Linie zwischen den beiden
beteiligten Klassen auf der Seite der Gesamtheit eine *nicht-ausgefüllte* Raute
hinzugefügt.._[]
]

.F[:
Aus pragmatischer Sicht ist darauf hinzuweisen, dass Aggregation und Assoziation
häufig eng beieinander liegen und mitunter auch "Ansichtssache" sind, womit ein
längeres Nachdenken oder gar eine kontroverse Diskussion darüber nicht lohnt,
welche Art von Beziehung per UML darzustellen ist.
]

---
template: plain
name: aggregation_example
header: #### Beispiel-Code zur Aggregation

.pull-left[
```
class Car {
    class Motor *e;
    …
    Car(Motor *e_ = nullptr)
        : e(e_)
    {}
    void setEngine(Motor *e_) {
        assert(e && !e_
           || !e && e_);
        e = e_;
    }
};

```
]

.pull-right[
```
class Motor {
    …
};
…
Motor firstMotors;
Motor otherMotor;
Motor unusedMotor;
```
Preferring pointers over references looks like an appropriate decision if a car,
during its lifetime, may get a replacement engine.._[]
]

Some Cars (with and without Motor):
```
Car soldCar(&firstMotor);        // a car with and ...
Car usedForCrashTest;            // ... without an engine
…
soldCar.setEngine(nullptr);      // remove old engine ...
soldCar.setEngine(otherMotor);   // ... for replacement
```

.F[:
Siehe: [Examples/ClassRelations/aggregation.cpp](../Examples/ClassRelations/aggregation.cpp)
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Inheritance
name: inheritance
header: ### Vererbung

[LSP]: http://en.wikipedia.org/wiki/Liskov_substitution_principle

Hierbei geht es um die Beziehung zwischen einem

* allgemeinen Konzept und

* dessen Spezialisierung.

.N[
In der UML-Darstellung wird an die (Assoziations-) Linie zwischen den beiden
beteiligten Klassen auf der Seite der Basisklasse ein nicht ausgefülltes Dreieck
hinzugefügt.
]

Speicher-Layout und Lebenszeit-Kopplung entsprechen zwar der Komposition, als
wichtige Besonderheit gilt jedoch das [LSP].

.I[
Das von Barbara Liskov formulierte Ersetzungsprinzip verlangt, dass ein Objekt
einer abgeleiteten Klasse (Spezialisierung) stets ein geeigneter Stellvertreter
für ein Objekt seiner Basisklasse sein sollte.._[]
]

.F[:
Any conventional compiler which only checks the existence of member functions
and their correct call with respect to argument and return types can guarantee
the LSP only to a very limited degree!
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Multiple Inheritance
name: multibased
header: ### Mehrfachvererbung

Diese liegt vor, wenn eine Klasse zwei Basisklassen hat, also zwei allgemeine
Konzepte spezialisiert.

.N[
In der Geschichte der Objektorientierung gab es zahlreiche Diskussionen über
Sinn und Zweck der Mehrfachvererbung und eine Reihe bekannter OOP-Sprachen –
etwa Java – verzichtet auf Mehrfachvererbung.._[]
]

.F[:
Java unterstützt allerdings Klassen, die mehrere [Interfaces](#interface)
implementieren.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Interface
name: interface
header: ### Interface (Schnittstelle)

[Stereotype]: http://en.wikipedia.org/wiki/Stereotype_(UML)

Bei einem Interface geht es prinzipiell um eine Art Vertrag zwischen zwei
Klassen:

* Es gibt einerseits eine (oder mehrere) Klasse(n), die ein bestimmtes Interface
  implementieren und

* für (in der Regel mehrere) andere Klassen ist damit klar, wie deren Angebot an
  Member-Funktionen aussieht.

.N[
In der UML-Notation steht über dem Namen eines Interfaces das [Stereotype]
`«interface»`.
]

---
template: plain
header: #### Anwendung von Interfaces

[OO-DP]: http://en.wikipedia.org/wiki/Software_design_pattern
[GoF]:   http://en.wikipedia.org/wiki/Design_Patterns_(book)

Generell reduzieren Interfaces die Kopplung, d.h. den Grad zu dem verschiedene
Klassen Details voneinander kennen (müssen).

Zudem bieten sie Flexibilität zur Laufzeit, indem aus mehreren verfügbaren
Implementierungen u.U. die für eine Situation am passende gewählt werden kann.

.N[
Interfaces haben vor allem durch *Objektorientierte Entwurfsmuster ([OO-DP])*
eine gewisse Bekanntheit erlangt und spielen auch im *[GoF]-Buch* eine wichtige
Rolle.
]

---
template: plain
header: #### Interfaces vs. Klassen

Technisch gesehen sind Interfaces in C++ einfach in bestimmter Form Weise
eingeschränkte Klassen:

* Sie besitzen keine Member-Daten und

* ausschließlich rein virtuelle Member-Funktionen.

.N[
Ein spezielles Schlüsselwort, das diese Einschränkungen **erzwingt**, gibt es
in C++ nicht.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Abstract Base
name: abstract_base
header: ### Abstrakte Basisklasse

Die Bezeichnung *abstrakt* wird für Klassen verwendet, die mindestens eine
**rein virtuelle** Member-Funktion haben.

.N[
In der UML-Darstellung wird der Name einer abstrakten Klasse kursiv geschrieben.
]

Abstrakte Klassen können nur als Basisklassen verwendet werden.

Davon abgeleitete Klassen werden dann

* die rein virtuelle(n) Member-Funktion(en) implementieren,

* oder sind selbst (weiterhin) abstrakte Basisklassen.

.W[
Der Versuch, Objekte einer abstrakten Klasse zu erzeugen scheitert in C++ mit
einem Kompilierfehler.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: "Diamond Shaped" Inheritance Graph
name: diamond_shaped_inheritance
header: ### "Rautenförmige" Vererbungsstruktur

Eine solche entsteht, wenn sich bei Mehrfachvererbung auf der mittleren Ebene
Klassen befinden, die wiederum eine gemeinsame Basisklasse besitzen.

Es ist bezüglich der gemeinsamen Basisklasse dann in der UML-Darstellung eine
Unterscheidung zwischen zwei Fällen erforderlich, welche die Daten-Member der
gemeinsamen Basisklasse betreffen:

* `«overlapping»` – die Daten-Member sind nur einmal vorhanden;

* `«disjoint»` – die Daten-Member sind doppelt vorhanden.

.W[
Im zweiten Fall ist in Bezug auf die ganz oben stehende Basisklasse von der ganz
unten stehenden Klasse aus gesehen das LSP außer Kraft gesetzt, da es nicht mehr
eindeutig ist.
]

---
template: withinfo
graphic: UML-ClassesAndRelations
section: Broad(er) and Deep(er) Inheritance Graph
name: broader_deeper_inheritance
header: ### Mehrstufige Vererbung allgemein gesehen

Im Allgemeinen gehen Vererbungs-Hierarchien

* sowohl *in die Breite*, d.h. eine Basisklasse wird oft mehrere direkt
  abgeleitete Klassen haben,

* wie auch *in die Tiefe*, d.h. es gibt mehrere Stufen – sieht man die direkt
  abgeleiteten Klassen als "Kinder", gibt es somit auch "Enkel", "Ur-Enkel"
  usw.

.I[
Rautenförmige Hierarchien mit gemeinsamen `«disjoint»` Basisklassen ausgenommen,
gilt das LSP über alle Stufen einer in die Tiefe gehenden Vererbungshierarchie.
]

---
template: linkinfo
graphic: MultipleInheritance
name: multiple_inheritance
header: ## Mehrfachvererbung und virtuelle Basisklassen

---------------------------------------------------------------------

* [Prinzip der Mehrfachvererbung	](#mi_principle)
* [Virtuelle Basisklassen		](#virtual_bases)

----------------------------------------------------------------------

* [Überlappende Basisklassen		](#overlapping_bases)

----------------------------------------------------------------------

---
template: withinfo
graphic: MultipleInheritance
section: Multiple Inheritance
name: mi_principle
header: ### Prinzip der Mehrfachvererbung

Bei der Mehrfachvererbung kann im Speicher-Layout nur noch eine der Basisklassen
eine gemeinsame Anfangsadresse mit der abgeleiteten Klasse haben.

.N[
Dies stellt keine große technische Herausforderung dar sondern bedeutet
lediglich eine minimale Komplikation bei der Umsetzung des LSP, wo im Fall des
Weiterreichens der abgeleiteten Klasse ggf. ein Offset zum `this`-Zeiger
addiert werden muss.
]

---
template: withinfo
graphic: MultipleInheritance
section: Virtual Base Class
name: virtual_bases
header: ### Virtuelle Basisklassen

Virtuelle Basisklassen bilden in C++ den Hintergrund der Lösung dessen, was die
UML bei rautenförmigen Vererbungshierarchien im Fall von `«overlapping»`-Klassen
an der Spitze verlangt.

.N[
Eine mögliche Implementierung von Mehrfachvererbung bürdet den Overhead den
Klassen auf der mittleren Ebene auf, indem diese nicht nur den Datenteil ihrer
(virtuellen) Basisklasse enthalten, sondern einen zusätzlichen Zeiger, über den
**alle Bezugnahmen auf den Basisklassenteil** erfolgen.
]

---
template: withinfo
graphic: MultipleInheritance
section: Overlapping Common Base Class
name: overlapping_bases
header: ### Überlappende Basisklassen

Im konkreten Fall einer rautenförmigen Hierarchie werden

* die Daten-Member der Basisklasse nur ein einziges Mal in der *Most Derived
  Class* vorhanden sein, und

* die Zeiger in den Klassen der mittleren Ebene werden jeweils auf dieses
  Daten-Member verweisen.

Da alle Bezugnahmen darauf – wie gerade beschrieben – über diese Zeiger laufen,
sprechen die Klassen der mittleren Ebene **ein und dasselbe**
Basisklassen-Objekt an.

---
template: linkinfo
graphic: DiamondShapedInheritance
name: diamond_shapes
header: ### Rautenförmige Ableitungshierarchien

------------------------------------------------------------------------

* [UML-Darstellung `«overlapping»` …		](#overlapping_uml)
* [… versus `«disjoint»`			](#disjoint_uml)

------------------------------------------------------------------------

* [Abbildung auf Speicher `«overlapping»` …	](#overlapping_memory)
* [… versus `«disjoint»`			](#disjoint_memory)

------------------------------------------------------------------------

* [Konstruktor / Destruktor `«overlapping»` …	](#overlapping_ctordtor)
* [… versus `«disjoint»`			](#disjoint_ctordtor)

------------------------------------------------------------------------

---
template: withinfo
graphic: DiamondShapedInheritance
section: UML Class Graph («overlapping»)
name: overlapping_uml
header: #### UML-Darstellung «overlapping»

Die zusammengefasste Darstellung des Falls `«overlapping»` in Bezug auf

* die UML-Darstellung,

erlaubt den direkten Vergleich zum Fall `«disjoint»`.

---
template: withinfo
graphic: DiamondShapedInheritance
section: UML Class Graph («disjoint»)
name: disjoint_uml
header: #### UML-Darstellung «disjoint»

Die zusammengefasste Darstellung des Falls `«disjoint»` in Bezug auf

* die UML-Darstellung,

erlaubt den direkten Vergleich zum Fall `«overlapping»`.

---
template: withinfo
graphic: DiamondShapedInheritance
section: Class to Memory Mapping («overlapping»)
name: overlapping_memory
header: #### Abbildung auf Speicher `«overlapping»`

Die zusammengefasste Darstellung des Falls `«overlapping»` in Bezug auf

* die Speicherabbildung

erlaubt den drekten Vergleich zum Fall `«disjoint»`.

---
template: withinfo
graphic: DiamondShapedInheritance
section: Class to Memory Mapping («overlapping»)
name: disjoint_memory
header: #### Abbildung auf Speicher `«disjoint»`

Die zusammengefasste Darstellung des Falls `«disjoint»` in Bezug auf

* die Speicherabbildung

erlaubt den direkten Vergleich zum Fall `«overlapping»`.

---
template: withinfo
graphic: DiamondShapedInheritance
section: Class to Memory Mapping («overlapping»)
name: overlapping_ctordtor
header: ### Quelltext und C'tor-/D'tor-Ablauf bei `«overlapping»`

Die zusammengefasste Darstellung des Falls `«overlapping»` in Bezug auf

* den Quelltext,

* den Konstruktor- sowie

* den Destruktor-Ablauf

erlaubt den drekten Vergleich zum Fall `«disjoint»`.

---
template: withinfo
graphic: DiamondShapedInheritance
section: Class to Memory Mapping («overlapping»)
name: disjoint_ctordtor
header: ### Quelltext und C'tor-/D'tor-Ablauf bei `«disjoint»`

Die zusammengefasste Darstellung des Falls `«disjoint»` in Bezug auf

* den Quelltext,

* den Konstruktor- sowie

* den Destruktor-Ablauf

erlaubt den direkten Vergleich zum Fall `«overlapping»`.

---
template: linkinfo
graphic: Example-ClassDesign
name: example_relations
header: ## Beispiele zu Klassenbeziehungen

-------------------------------------------------------------------------------

* [Eine anpassbare Komponente …			](#an_adaptable_component)
* [… und deren Nutzung 				](#using_existing_component)

-------------------------------------------------------------------------------

* [Rautenförmige (Mehrfach-) Vererbung		](#with_multiple_inheritance)

-------------------------------------------------------------------------------

* [Drei Interfaces				](#with_three_interface)

-------------------------------------------------------------------------------

* [Flexible Erweiterbarkeit durch "Mix-Ins"	](#with_extensibilty)

-------------------------------------------------------------------------------

* [Orientiert am GoF *Observer Muster*		](#with_elaboration)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: Example-ClassDesign
section: Reusable Component
name: an_adaptable_component
header: ### Eine (anpassbare) Komponente

Anpassbare Komponenten entstehen normalerweise entweder

* durch Planung, wenn zukünftige Variabilität (korrekt) vorhergesehen wurde,
  oder

* durch Erfahrung, wenn zu einer bereits bestehende Funktionalität eine – im
  ersten Entwurf noch nicht eingeplante – neue Variante benötigt wird.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt ist die Template-Version der
`RingBuffer`-Klasse eine solche anpassbare Komponente.
]

.F[:
Sieha auch
[Aufgabe Mittwochvormittag (Teil 2)](../Examples/05_wednesday1_x2) und
[Examples/ClassDesigns/ReusableComponent](../Examples/ClassDesigns/ReusableComponent)
]

---
template: withinfo
graphic: Example-ClassDesign
section: Reusable Adapted Component
name: using_existing_component
header: ### Nutzung der (angepassten) Komponente

Die Nutzung einer (angepassten) Komponente reduziert den Aufwand an immer wieder
neu zu schreibendem Code.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt wird

* die Template-Version der `RingBuffer`-Klasse ggf.
* mit unterschiedlichen Instanziierungs-Argumenten

verwendet.
]

Die Alternative dazu wäre *Copy&Paste-Programmierung*, also ein klarer Verstoß
gegen das *DRY-Pinciple*.

.F[:
[Examples/ClassDesigns/AdaptedComponent](../Examples/ClassDesigns/AdaptedComponent)
]

---
template: withinfo
graphic: Example-ClassDesign
section: Diamond-Shapend Inheritance
name: with_multiple_inheritance
header: ### Rautenförmige (Mehrfach-) Vererbung

Besteht die Bereitschaft den Preis für die dann oft notwendigen, virtuellen
Basisklassen zu zahlen, lassen sich flexible Kombinationsmöglichkeiten mit einem
guten Grad an Wiederverwendung durch Mehrfachvererbung erreichen.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt werden aus den Klassen `Average`
und `Extrema` mittels Mehrfachvererbung zur Klasse `Statistic` kombiniert,
womit diese beide Fähigkeiten vereint:

* den Mittelwert aller Daten zu ermitteln, und
* das Minimum und Maximum aller Daten zu ermitteln.
]

.F[:
[Examples/ClassDesigns/DiamondShaped](../Examples/ClassDesigns/DiamondShaped)
]

---
template: withinfo
graphic: Example-ClassDesign
section: Three Interfaces
name: with_three_interface
header: ### Drei Interfaces

Die Nutzung von Interfaces kann die Komplexität der Gesamt-Architektur aus der
"Sicht einzelner Klienten" etwas vereinfachen.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt werden

* zu einer gemeinsamen Klasse `Statistic`
* drei Interfaces definiert,

so dass

* hinsichtlich der *Nutzer* dieser Klasse jeweils klar ist,
* auf welches Sub-Set der Gesamt-Funktionalität sie angewiesen sind.
]

.F[:
[Examples/ClassDesigns/ThreeInterfaces](../Examples/ClassDesigns/ThreeInterfaces)
]

---
template: withinfo
graphic: Example-ClassDesign
section: Improved Reuse with Mixin Classes
name: with_extensibilty
header: ### Inkrementale Erweiterbarkeit durch Mix-Ins

Über Mixin-Klassen lässt sich ggf. flexible Kombinierbarkeit schaffen, auch ohne
dass virtuelle Basisklassen notwendig werden.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt werden

* die Klassen `Average`, `Extrema` und `Statistic` flexibel zusammengesetzt
  durch
* unterschiedliche Kombinationen der Basisklasse `Value`
* mit den beiden Mixins `AverageMixin` und `ExtremaMixin`.
]

.F[:
Leicht vereinfacht (ohne `RingBuffer`-Komponente) in
[Aufgabe von Mittwochvormittag (Teil 3, Variante 1)](../Examples/05_wednesday1_x3)
]

---
template: withinfo
graphic: Example-ClassDesign
section: Close to GoF "Observer" Pattern
name: with_elaboration
header: ### Orientiert am GoF *Observer Muster*

[Observer Pattern]: http://en.wikipedia.org/wiki/Observer_pattern

Das "Flaggschiff" unter allen hier verglichenen Entwürfen.

Es vereint hohe Flexibilität und geringe Kopplung … hat allerdings auch die
komplexeste Implementierung.

.N[
In den konkreten Beispielen._[] zu diesem Abschnitt werden in Anlehnung an das
[Observer Pattern]

* die Klassen `Average`, `Extrema` und `Statistic` flexibel zusammengesetzt
  durch
* unterschiedliche Kombinationen der Basisklasse `Value`
* mit den beiden Mixins `AverageMixin` und `ExtremaMixin`,

wobei Abhänggkeiten gering gehalten werden

* über das `INotifyUpdate`-Interface und
* ein flexibles Registrierungsprotokoll.
]

.F[:
Leicht vereinfacht (ohne `RingBuffer`-Komponente) in
[Aufgabe von Mittwochvormittag (Teil 3, Variante 2)](../Examples/05_wednesday1_x3)
]
---
layout: false
template: blank
name: part6

# [C++ FOR](#agenda) (Part 6) C++ from Bottom – How the Hardware is Used

-------------------------------------------------------------------------------
1. [Generalisiertes Ausführungsmodell	](#execution_model)
1. [Abbildung von Klassen		](#class_mapping)
1. [Implementierung von Containern	](#implementing_containers)
1. [Typidentifikation zur Laufzeit	](#runtime_type_identification)
1. [Typbasierte Verzweigungen		](#multiway_typeswitch)

-------------------------------------------------------------------------------

---
template: linkinfo
graphic: ExecutionModel
name: execution_model
header: ## Generalisiertes Ausführungsmodell

-------------------------------------------------------------------------------

* [CPU und Speicher				](#essentials)

-------------------------------------------------------------------------------

* [Stack-Daten					](#stackdata)
* [Globalen Daten				](#globaldata)
* [Dynamisch verwaltete Daten			](#heapdata)

-------------------------------------------------------------------------------

* [Stack-Frames (Verwaltungsinformation)	](#stackframes)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: ExecutionModel
section: Essentials
name: essentials
header: ### CPU und Speicher

Allgemein betrachtet sind dies die Kernkomponenten jedes Computers.

* Vom kleinsten Controller in der Waschmaschine …
* … über klassische Mobiltelefone …
* … zu Smart-Phones …
* … Home-PC-s …
* … File- und Applikations-Servern …
* … bis zum größten Main-Frame.

(OK, die größeren haben mehr als eine CPU ziemlich viel Speicher …)

---
template: withinfo
graphic: ExecutionModel
section: Essentials
name: pc_sp
header: #### CPU-Aufbau (Grundlegendes)

##### Program Counter und Stack Pointer

Der innere Aufbau der CPU ist für das Verständnis der hier behandelten Themen
weniger wichtig – bis auf zwei Bestandteile:

* Program Counter – oder deutsch: Programm(schritt)zähler
  * oft abgekürzt zu PC, manchmal auch IP (für Instruction Pointer)
  * enthält die Adresse des als nächsten auszuführenden Progammschritts
  * wird beim Auslesen des nächsten Befehls automatisch weiter gesetzt

* Stack Pointer – oder deutsch: Stapelzeiger (wenig gebräuchlich)
  * oft abgekürzt zu SP
  * gibt die *Grenzadresse* des Stack-Bereichs an

---
template: plain
header: ##### Ausdehnung des Stack-Bereichs

Da der SP nur die *Grenzadresse* angibt, könnte man meinen, es sei lediglich
eine Definitionssache, ob der Stack *darüber* beginnt oder *darunter*.

Tatsächlich hängt die Ausdehnung des Stack aber davon ab, wohin sich der
Stack-Pointer bei Maschinenbefehlen wie

* `push` (Daten: Register => Speicher) bzw. `pop` und
* `jsr` (Unterprogramm-Einsprung._[])

bewegt – wenn zu *kleineren* Adressen hin, gehören ab dem SP alle *größeren*
Adressen zum Stack.

.F[:
Der betreffende Maschinenbefehl muss nicht zwingend `jsr` heißen, dies ist
lediglich ein üblicher Name und steht für "`j`ump to `s`ub`r`outine". Abhängig
von der Assemblersprache sind auch andere Namen üblich, z.B. "branch and link",
wobei das letzte Wort ausdrücken soll, dass anders als bei einem bloßen Sprung
eine Verbindung zur Absprungstelle angelegt wird, damit später dorthin
zurückgekehrt werden kann.
]

---
template: plain
header: #### CPU-Aufbau (Details)

Die folgenden Seiten stellen noch weitere Details zum Aufbau einer typischen CPU
dar.

Sie sind für das Verständnis der Ausführungen in diesem Kapitel weniger wichtig
und können auch [übersprungen werden](#stackdata).

Im einzelnen geht es um:

* [ALU](#alu)
* [Register](#alu)
* [Datenpfad](#datapaths)
* [Steuerungslogik](#datapaths)

---
template: plain
name: alu
header: ##### ALU (Arithmetic Logic Unit)

Hier werden Daten miteinander verknüpft.

Herkunft:

* oft ausschließlich aus [Registern](#register)
* evtl. auch direkt aus dem Speicher

(Ob die ALU nur mit Registern oder auch direkt mit dem Speicher zusammenarbeiten
kann, hängt von der CPU-Architektur ab.)

Ergebnis:

* meist in einem bestimmten Register oder
* in einem Satz ausgewählter Register

Das Register._[], welches zur Ergebnisablage mit der ALU verschaltet werden kann,
wird oft Akkumulator oder kurz Akku genannt.

.F[:
Oder auch mehrere davon.
]

---
template: plain
name: register
header: ##### (Weitere) Register

Je nach CPU-Architektur gibt es eine mehr oder weniger große Zahl universell
verwendbarer Register.

Darüber hinaus gibt es auch solche mit Sonder- oder Spezialfunktionen:

* [Program Counter (PC)](#pc_sp)
* [Stack Pointer (SP)](#sp)
* Flags zur Maskierung von Interrupts
* Stack-Limits._[]

.F[:
Hierbei handelt es sich um harte Grenzen, innerhalb derer sich der SP bewegen
darf. Bei Verlassen dieses Bereich wird ein (Software-) Interrupt ausgelöst.
Dies kann sehr nützlich sein, um zu verhindern, dass durch einen unerwartet
gewachsenen Stack andere Datenbereiche überschrieben werden – insbesondere der
Bereich dynamisch verwalteter und globaler Daten.
]

---
template: plain
header: ##### Datenpfad-Steuerung

Die verbleibenden Teile._[] einer typischen CPU sind im wesentlichen:

* (um-) schaltbare Datenpfade und
* die zugehörige Steuerungslogik

Letztere schalten erstere so um, dass Register, ALU und Speicher so miteinander,
verbunden sind, wie es zur Ausführung des jeweiligen Maschinenbefehls erfordert.

.F[:
Vom Umfang her können die Datenpfade und die zugehörige Steuerungslogik durchaus
einen wesentlichen oder sogar den größten Teil einer typischen CPU ausmachen.
]

---
template: withinfo
graphic: ExecutionModel
section: Stack Data
name: stackdata
header: #### Stack-Daten

Der Stackbereich im Datenspeicher ist generell wichtig für Unterprogramme.

Dort wird abgelegt:

* Aufrufargumente
* Lokale Variable
* Verwaltungsinformation

Bei vielen Hardware-Architekturen wächst der Stack von großen zu kleinen Adressen.

In der oft üblichen Darstellung des Speichers als Rechteck mit

* *kleineren* Adressen unten und
* *größeren* Adressen oben

hängt der "Stapel" also gewissermaßen an der Decke.

---
template: withinfo
graphic: ExecutionModel
section: Global Data
name: globaldata
header: #### Globale Daten

Diese stehen an festen Adressen, die zuvor vom Linker vergeben wurden.

Für alle Objekt-Module, aus denen das endgültige Programm besteht, ermittelt der
Linker den Bedarf an globalem Speicher.

Dieser ergibt sich aus:

* globalen Variable (außerhalb aller Blöcke._[])
* block-lokale `static` Variablen
* `static` Member Variablen

.F[:
Bei globalen Variablen spielt es keine Rolle, ob diese `static` sind oder nicht,
da es sich in beiden Fällen um Speicherplatz im globalen Datenbereich handelt.
Der Unterschied ist lediglich, dass globalen `static` Variablen mit **gleichem**
Namen in unterschiedlichen Objektmodulen auch jeweils **unterschiedlicher**
Speicherplatz zugeordnet werden muss.
]

---
template: withinfo
graphic: ExecutionModel
section: Heap Data
name: heapdata
header: #### Dynamisch verwaltete Daten

Hier werden die Daten abgelegt, für die zur Laufzeit

* explizit Speicher [angefordert](#heap_alloc) wird, der dann
* irgendwann auch wieder [freigegeben](#heap_release) werden sollte.

Andere übliche Bezeichnungen für diesen Bereich sind:

* Heap
* Free Store
* Dynamischer Speicher

---
template: withinfo
graphic: MemoryModel
section: Stack Frame
name: stackframes
header: ### Stack-Frames

Unter einem Stack-Frame versteht man denjenigen Abschnitt auf dem Stack, der
einem aktiven Unterprogramm zuzuordnen ist.

Die Stackframes ergeben sich direkt aus den Maschinenbefehlen bei

* [Aufruf](#stack_call) und
* [Rückehr](#stack_return)

von Unterprogrammen. Grundsätzlich sind dabei folgende Probleme zu lösen:

* Übergabe von Argumenten
* Speicherplatz für lokale Variable
* Entgegennahme eines Rückgabewerts
* Rückkehr an die Aufrufstelle

---
template: plain
name: stack_call
header: #### Detailablauf beim Unterprogramm-Aufruf

Hier ist zu unterscheiden zwischen

* dem Code, der noch vom [Aufrufer des Unterprogramms](#caller_code) (Caller)
  ausgeführt wird,
* dem eigentlichen [Unterprogramm-Einsprung](#jsr_code) und
* demjenigen Code, der im [aufgerufenen Unterprogramm](#callee_code) (Callee)
  ausgeführt wird.

.N[
Hier bestehen grundsätzlich viele Freiheiten für den Compiler, aber nur
solange sichergestellt ist, dass *Caller* und *Callee* zusammenpassen.._[]
]
.F[:
Hierum geht es prinzipiell wenn die Einhaltung bestimmter
[Calling Conventions](#calling_conventions) gefordert wird.
]

---
template: plain
name: caller_code
header: ##### Argumente bereitstellen

Noch an der Aufrufstelle wird i.d.R. Code zum Ablauf kommen,

* die Werte aller Aufrufargumente ermittelt, was
  * im Fall von Variablen einen Speicherzugriff oder
  * im Fall von Ausdrücken eine Berechnung erfordern kann,

* und diese Werte dann zur Verwendung durch das aufgerufene Unterprogramm
  * auf den Stack legt bzw.
  * in bestimmten Registern hinterlässt.

* In welcher Form Stack und Register dabei genau benutzt werden, regeln die
  Calling Conventions.

---
template: plain
name: jsr_code
header: ##### Maschinenbefehl zum Unterprogrammsprung

Im Rahmen des Unterprogramm-Einsprungs wird mindestens der Program-Counter
auf den Stack gelegt:

* Dies ist erforderlich, da Unterprogramme von mehr als einer Stelle aus
  aufgerufen werden können.

* Insofern benötigen sie eine Information, wohin am Ende zurückzukehren ist.

* Der Program-Counter wurde schon beim Holen des `jsr`-Befehls weiter geschaltet.

* Der auf dem Stack gesicherte Wert zeigt somit auf den Befehl direkt dahinter.

Zum Abschluss wird die Startadresse des Unterprogramms in den Program-Counter
übertragen.

---
template: plain
name: calling_conventions
header: ##### Aufrufkonventionen (Calling Conventions)

Hierbei handelt es sich um eine Reihe von Festlegungen, die letzten Endes
sicherstellen sollen, dass die Kommunikation zwischen Aufrufer und aufgerufenem
Unterprogramm funktioniert.

Unter anderem muss Einigkeit über die gesicherten Register bestehen und welche
Register ggf. die Werte von Aufrufargumenten enthalten.

* Da das Sichern von Registern beim Unterprogrammsprung Zeit kostet, sollten es
  einerseits nicht unnötig viele sein.

* Auf der anderen Seite sind Register wertvoller Speicherplatz für temporäre
  Werte.

* Oft befindet sich unter den gesicherten Registern auch der Stack-Pointer,._[]
  obwohl das theoretisch nicht zwingend ist.

---
template: plain
name: calling_conventions
header: ##### Erzeugen von Stack-Backtraces

Mit einem auf dem Stack selbst gesicherten Stack-Pointer – so wie er unmittelbar
vor dem Unterprogramm-Einsprung gültig war, besteht eine

* leicht zu verfolgende Rückwärtsverkettung

zur Main-Funktion (und von dort weiter ins Runtime-Startup-Modul).

Mit deren Hilfe können beim "post-mortem"-Debugging anhand des Speicherabzugs
die zum Zeitpunkt eines Programmabsturzes aktiven Funktionen rekonstruiert
werden.

---
template: plain
name: callee_code
header: ##### Platz für lokale Variable schaffen

Im aufgerufenen Unterprogramm wird

* zunächst Platz für die eigenen, lokalen Variablen geschaffen,
* wozu ein einfaches Verschieben des Stack-Pointers ausreicht.

.N[
Lokale Daten eines Unterprogramms werden (ggf. initialisiert und) mit einem
Offset zum Stack-Pointer adressiert.
]

Die Berechnung der effektiven Adresse erfolgt durch einen speziell für
diese Aufgabe in der CPU vorhandenen Addierer.._[]

* Dies gilt sowohl die die vom Aufrufer übergebenen Argumente
* wie auch für die im Unterprogramm lokal vorhandene Variable.

.F[:
Da diese Technik zur Realisierung lokaler Variablen eine lange Tradition hat,
wird die Adressierung relativ zum Stack-Pointer ausnahmslos von allen modernen
CPUs in effizienter Form unterstützt.
]

---
template: plain
name: local_data
header: ##### Aufrufargumente und lokale Variable

Der Unterschied zwischen beiden besteht bei genauer Betrachtung nur in der
Tatsache

* dass Aufrufargumente noch vom [**aufrufenden** Code](#caller_code) mit
  Initial-Werten versehen werden,
* während lokale Variable, die nicht explizit initialisiert wurden, in ihren
  Anfangswerten unvorhersehbar sind.._[]

Innerhalb eines Blocks mit `static` definierte Variable sind von der Lebensdauer
her *nicht* an die Ausführung eines Blocks oder einer Funktion gebunden und
werden daher bei den globalen Variablen abgelegt.

.F[:
Genauer gesagt ergeben sich die Anfangswerte von nicht explizit initialisierten
Variablen aus der vorherigen Nutzung des Stack-Bereichs, in dem sie liegen.
]

---
template: plain
name: stack_return
header: #### Details bei der Unterprogramm-Rückkehr

Beim Verlassen eines Unterprogramms werden diejenigen Aktionen rückgängig
gemacht, die beim Aufruf stattfanden:

* Zunächst muss der [Rückgabewert](#return_value) bereitgestellt werden (sofern
  das Unterprogramm einen solchen liefert).
* Anschließend wird der für die lokalen Variablen reservierte Stack freigegeben.
* Schließlich erfolgt der [Rücksprung](#code_rts) an die Aufrufstelle.
* Dort muss der für die Parameterübergabe benutzte Stack freigegeben werden.

.N[
Moderne CPU-Architekturen können diese Schritte teilweise zusammenfassen.
Wichtige Voraussetzung dafür ist, dass der Aufrufer **und** das aufgerufene
Unterprogramm Anzahl und Typ der Argumente kennen.._[]
]

.F[:
In C++ ist dies immer gegeben, da die Sichtbarkeit der Deklarationen (Prototyp)
Voraussetzung für den Aufruf einer Funktion ist. Hinsichtlich C wurde ähnliches
im C89-Standard damit erreicht, dass der Compiler bei nicht-sichtbarem Prototyp
einen solchen putativ erstellen kann.
]

---
template: plain
name: return_value
header: ##### Bereitstellung des Rückgabewerts

Die wesentlichen Details hängen hier davon ab, ob es sich um einen Grundtyp
handelt oder um eine größere Datenstruktur.._[]

* Grundtypen werden in der Regel in einem Register zurückgegeben.
* Dies gilt auch für kleinere Datenstrukturen.
* Für größere Datenstrukturen muss der [Aufrufer](#caller_code)
  Stack-Speicherplatz bereitstellen.

Details zur Rückgabe in einem Register regeln ggf. die
[Calling Conventions](#calling_conventions).

.N[
Die Rückgabe über den Stack kann man als (versteckte) Übergabe einer Referenz
sehen, welche die aufgerufene Funktion genau so benutzt, als sei sie über die
Argumentliste übergeben worden.
]

.F[:
Um die mit Strukturen beliebiger Größe verbundenen Probleme zu vermeiden, waren
in den Anfangszeiten von C Rückgabewerte von Funktionen auf Grundtypen (inkl.
Zeiger) beschränkt. Erst mit dem C89-Standard wurde verbindlich die Möglichkeit
eingeführt, beliebige Strukturen als Rückgabewert einer Funktion zu verwenden.
]

---
template: plain
name: code_rts
header: ##### Rücksprung zum Aufrufer

Symmetrisch zum Aufruf sind hierbei zwei Schritte notwendig:._[]

* Erster Schritt
  * Die beim [Einsprung](#jsr_code) in das Unterprogramms gesicherten Register
    werden restauriert.
  * Der Program-Counter zeigt damit auf den nächsten Befehl und der
    Stack-Pointer steht so, wie er nach Übertragen der Aufrufargumente stand.

* Zweiter Schritt
  * Im Code des Aufrufers wird dafür gesorgt, dass der für diese Funktion
    eigentlich gültige Wert des Stack-Pointer restauriert wird.

.F[:
Da Unterprogramme seit langer Zeit wesentlicher Bestandteil höherer
Programmiersprachen sind, verfügen viele moderne CPU-Architekturen –
insbesondere hinsichtlich des Rücksprungs aus Unterprogrammen – über
Maschinenbefehle, welche die hier im Detail dargestellten Abläufe effizient
zusammenzufassen.
]

---
template: plain
name: heap_alloc
header: ### Dynamische Speicherverwaltung

#### Speicheranforderung

Grundsätzlich muss dies Operation explizit angestoßen werden. Rückgabewert
ist ein Zeiger auf den dynamisch bereitgestellten Speicher.

* In C mit:._[]
  * `malloc` – angegeben wird die Speichergröße in Byte
  * `calloc` – ähnlich wie zuvor aber Multiplikator.
  * `realloc` – spätere Änderung der Größe.
* In C++ mit:
  * `new T` – Größe wird daraus als `sizeof T` bestimmt
  * `new T[N]` – ähnlich wie zuvor aber mit Multiplikator `N`

.I[
In C++ wird von der `new`-Operation automatisch der `T`-Konstruktor aufgerufen,
bzw. `N` solcher Konstruktoren.
]


.F[:
Prinzipiell multipliziert `calloc` die beiden Werte. Der erste bestimmt dabei
das Alignment. Ferner wird der Speicherinhalt explizit gelöscht (mit Null
initialisiert), anders als bei `malloc`, das den Speicherbereich so wie
vorgefunden zurückliefert. Falls `realloc` den bereits zugeordneten
Speicherbereich nicht vergrößern kann, wird dessen Inhalt an diejenige Stelle
im Speicher verschoben, deren Adresse als Ergebnis geliefert wird.
]

---
template: plain
name: heap_release
header: #### Dynamische Speicherfreigabe

Grundsätzlich ist dies eine Operation, die explizit angestoßen werden muss:

* In C mit:
  * `free` – anzugeben ist dabei der bei der Anforderung erhaltene Zeiger
* In C++ mit:
  * `delete` – anzugeben ist ein von `new T` erhaltener Zeiger
  * `delete[]` – anzugeben ist ein von `new T[N]` erhaltener Zeiger

.I[
In C++ wird von der `delete`-Operation automatisch der `T`-Destruktor
aufgerufen, bzw. `N` solcher Destruktoren.
]

---
template: plain
name: heap_release
header: #### Typische Fehlerquellen bei dynamischem Speicher

Folgende Situationen erfordern im Umgang mit dynamischen Speicher besondere
Beachtung:

* Es kann kein weiterer Speicher verfügbar gemacht werden.

  * Seit C++98 hat dies eine Exception zur Folge.

  * Es kann durch einen entsprechenden Handler aber auch das vor C++98
    angewendete Verfahren aktiviert werden, nämlich dass unzureichender
    Hauptspeicher von `new` durch Rückgabe eines Null-Zeigers gemeldet
    werden.

Weiterhin im Verantwortungsbereich des Software-Entwicklers liegt die korrekte
Kombination

* von `new` mit `delete`,
* von `nev[N]` mit `delete[]`, und
* von `malloc`, `calloc`, `realloc` mit `free`._[]

.F[:
Seit C89 kann bei `free` genau wie bei `delete` davon ausgegangen werden, dass
die Übergabe eines Null-Zeigers (oder `nullptr` in C++11) wirkungslos bleibt.
]


---
template: plain
name: stacklimit
header: ### Stack-Limit

Da die verschiedenen Arten der Datenablage prinzipiell um den selben Speicher
konkurrieren, muss verhindert werden, dass die einzelnen, für unterschiedliche
Zwecke verwendeten Bereiche nicht ineinander hinein laufen. Insbesondere beim
Stack kann dies ein Problem sein, denn der SP wird sehr oft und von sehr vielen
Maschinenbefehlen – auch implizit – verändert.

Folgende Techniken können zur Anwendung kommen:._[]

* [spezielle CPU-Register](#stacklimit_cpureg)
* [nicht zugeordnete Speicherseite](#stacklimit_pagefault)
* [Generieren von "sicherem Code"](#stacklimit_codegen)
* [statische Vorab-Analyse](#stacklimit_analysis)

.F[:
Kommt keine dieser Möglichkeiten in Betracht bleibt nur beten und hoffen …
]

---
template: plain
name: stacklimit_cpureg
header: #### Stack-Limit mit speziellen CPU-Registern überwachen

Die wichtigste Voraussetzung ist hier natürlich, dass die CPU entsprechende
Register bietet!

* Diese werden auf die Grenzadressen des Stacks gesetzt.
* Verlässt der SP den zulässigen Bereich, wird typischerweise ein Interrupt
  ausgelöst.

In der Interrupt-Reaktion muss eine Notfallmaßnahme greifen:

* Unterstützt ein Betriebssystem die Programmausführung, wird der Prozess
  beendet.
* Ohne diese Unterstützung bleibt meist nur der Neustart (Warm-Boot) als
  Ausweg.

---
template: plain
name: stacklimit_pagefault
header: #### Stack-Limit mit nicht zugeordneter Speicherseite überwachen

Dies setzt eine MMU (memory Management Unit) voraus und deren – zumindest
rudimentäre – Verwaltung durch ein Betriebssystem.

.I[
Grundidee ist, zwischen Stack-Pointer und `brk`-Adresse immer mindestens eine
nicht physikalisch zugeordnete Speicherseite frei zu lassen.
]

Kommt es nun zu einem Page-Fault aufgrund des nicht zugeordneten Speichers, wird

* bei Aufruf eines Unterprogramms, dem Stack eine weitere Seite zugeordnet;
* bei Verschieben der `brk`-Adresse, dem Heap eine weitere Seite zugeordnet.

.N[
Einzige Ausnahme ist, dass die neue Seite die letzte freie Seite zwischen Stack
und Heap wäre: In diesem Fall wird die Programmausführung abgebrochen.
]


---
template: plain
name: stacklimit_codegen
header: #### Probleme mit Stack-Limit durch sicheren Code vermeiden

Wenn keine anderen Mittel zur Verfügung stehen und "Sicherheit vor
Schnelligkeit" geht, könnte auch

* vor jedem `push` (Register auf Stack legen)
* vor jedem `jsr` (Unterprogramm aufrufen)

der aktuelle Wert des Stack-Pointers mit der `brk`-Adresse verglichen werden.
Ist der aktuelle Abstand nicht mehr ausreichend für die anstehende Operation,
wird die Programmausführung abgebrochen.

.N[
Voraussetzung ist hier natürlich, dass verwendete Compiler eine solche
Code-Generierung zumindest optional unterstützt.
]

---
template: plain
name: stacklimit_analysis
header: #### Probleme mit Stack-Limit durch statische Analyse ausschließen

Eine andere Möglichkeit – vor "Beten und Hoffen" – wäre schließlich die,
sämtliche Unterprogramm-Aufrufe zu analysieren und deren maximalen Stack-Bedarf
zu ermitteln.

Dies per Hand zu erledigen ist aufwändig und fehlerträchtig, da die
Schachtelung ja auch von Programmablauf abhängt. Die Unterstützung durch ein
statisches Analyse-Werkzeug ist in diesem Fall mehr als nur wünschenswert.

Weitere Voraussetzungen sind:

* sind Unterprogramme direkt oder indirekt rekursiv, muss die maximale Tiefe
  bestimmt werden;
* insbesondere darf diese nicht datenabhängig sein!

---
template: linkinfo
graphic: ClassToMemoryMapping
name: class_mapping
header: ## Abbildung von Klassen

------------------------------------------------------

* [Abbildung von Member-Daten](#member_data)
* [Abbildung von Member-Funktionen](#member_functions)

------------------------------------------------------

* [Öffentliche Basisklassen](#public_bases)
* [Private Basisklassen](#private_bases)

------------------------------------------------------

* [Komposition](#member_composition)

------------------------------------------------------

---
template: withinfo
graphic: ClassToMemoryMapping
section: Mapping Classes to Code And Data
name: member_data
header: ### Abbildung von Member-Daten

Grundsätzlich wird aus den Member-Daten einer Klasse eine Struktur gebildet.
Die Reihenfolge bleibt dabei erhalten:

* Im Quelltext nachfolgende Member stehen im Speicher an einer größeren
  Adresse.

* Sofern aus Alignment-Gründen notwendig, gibt es zwischen den Membern
  ungenutzten Speicher (Padding).

* Auch am Ende der Struktur kann ein Padding erforderlich sein.

.N[
Vordergründig scheint das Padding am Ende nur für den Fall notwendig zu sein,
dass von der betreffenden Struktur Arrays gebildet werden, es wird jedoch von C
und C++ stets als Bestandteil der Struktur bzw. der Member-Daten einer Klasse
gesehen.
]

---
template: plain
name: padding
header: #### Padding und Alignment

Der allgemeine Grund für Padding in Strukturen sind Alignment-Anforderungen der
Hardware:

* Oft kann nicht jeder Datentyp an einer beliebigen Stelle im Speicher stehen
  sondern erfordert die Ausrichtung auf ene bestimmte Adress-Grenze
  Beispielsweise könnte es notwendig sein, dass
  * 32-Bit Ganzzahlen an einer durch 4 teilbaren Adresse und
  * 64-Bit Ganzzahlen an einer durch 8 teilbaren Adresse stehen.

* Da Strukturen prinzipiell auch als Arrays angelegt werden können, muss ferner
  die Struktur insgesamt gemäß den strengstens Alignment-Anforderungen der in
  ihr enthaltenen Elemente ausgerichtet sein.

.N[
Würde die zweite Regel nicht befolgt, hätten bei Arrays von Strukturen die
Elemente der Struktur an unterschiedlichen Indizes unterschiedlichen Offset.
]

---
template: plain
name: intra_padding
header: ##### Padding zwischen Strukturelementen

Die Garantie, dass die Elemente einer Struktur gemäß ihrer Reihenfolge im Quelltext an
aufsteigenden Adressen abgelegt werden, erfordert bei

```
struct s {
    unsigned a;  // assume 32 bit for int
    long long b; // assume 64 bit for long long
}
```
das Einfügen von vier (ungenutzten) Bytes zwischen `a` und `b`.
Die Größe der Struktur (`sizeof (struct s)`) ist damit 16 (4+4+8) Bytes.

---
template: plain
name: end_padding
header: ##### Padding nach dem letzten Strukturelement (Trugschluss)

Bei der umgekehrten Anordnung
```
struct s {
    long long b; // assume 64 bit for long long
    int a;       // assume 32 bit for short
}
```
scheinen dagegen 12 (= 8+4) Bytes ausreichend zu sein, da zwischen `b` und `a`
nichts eingefügt werden muss …

---
template: plain
name: end_padding
header: ##### Padding nach dem letzten Strukturelement (Notwendigkeit)

… allerdings würde ohne Padding am Ende gegen eine seit den Anfängen von C
gültige Regel verstoßen, die besagt dass für jedes Array

```
struct s { … } arr[N];

```
die Beziehungen

* `(sizeof arr / sizeof (struct s)) == N` und
* `(sizeof arr / arr[0]) == N`

erfüllt sein muss. Damit ist unter anderem garantiert, dass sich die Anzahl der
Elemente in einem initialisierten Array
```
struct s array[] = { {1, 2}, {3, 4}, {5, 6} };
```
in jedem Fall mit den obigen Ausdrücken berechnen lassen und die Anordnung der
Elemente in der Struktur-Definition dafür keine Rolle spielt.

---
template: withinfo
graphic: ClassToMemoryMapping
section: Mapping Classes to Code And Data
name: member_functions
header: ### Abbildung von Member-Funktionen

Hier ist zum einen zu unterscheiden zwischen Member-Funktionen
[mit und ohne](#inline_optimization) den Zusatz `inline`.

Bei Funktionen, die zu echten Unterprogrammen kompiliert werden (nicht `inline`)
kompiliert werden, ist ferner zu unterscheiden zwischen:

* [Statischem Linken](#static_linking) und
* [Dynamischem Linken](#dynamic_linking).

---
template: plain
name: inline_optimization
header: #### Reguläre vs. Inline-Member-Funktionen

Ursprünglich war das Schlüsselwort `inline` nur dazu gedacht, dem Compiler einen
Hinweis zu geben, dass für eine damit markierte Funktion der enthaltene Code
direkt an der Aufrufstelle eingesetzt werden kann. Der Compiler konnte diesen
Hinweis auch ignorieren.

Mittlerweile hat sich die Situation umgekehrt:

.N[
Zumindest im Fall höherer Optimierungsstufen entscheiden viele Compiler von sich
aus, dass sie statt eines Unterprogramm-Aufrufs den Code der Start-Funktion direkt
an der Aufrufstelle auch dann einsetzen, wenn diese Funktion *nicht* mit `inline`
markiert ist.
]

Andererseits ignoriert z.B. der GCC Inline-Funktionen, wenn alle Optimierungen
abgeschaltet sind (Debug-Kompilierung), und sollte so auch das Setzen von Break-Points
Jin solchen Funktionen zu
vereinfachen.

---
template: plain
name: compile_inline
header: #### Inline Member-Funktionen

Grundsätzlich handelt es sich bei Inline-Funktionen um den Tausch von Geschwindigkeit
gegen Programmgröße:

* Inline-Funktionen werden den Programmcode größer._[] machen.
* Dafür werden sie schneller ausgeführt.

.N[
Es gibt allerdings eine wichtige Ausnahme:

Für sehr einfache Inline-Funktionen – insbesondere typische *Getter* und *Setter* –
machen diese nicht nur die Programmausführung *schneller* sondern auch den Code
insgesamt *kleiner*!
]

.F[:
Wieviel Platz im Code-Speicher verfügbar ist hängt natürlich ab von der Anzahl der
Satelitten im Gesamtprogramm ab.
]

---
template: plain
name: compile_call
header: #### Nicht-Inline Member-Funktionen

Für diese wird der Code nur einmal erzeugt und im Speicher abgelegt, während
an den Aufrufstellen lediglich

* die [Argumente versorgt](#caller_code) werden und anschließend
* ein [Unterprogramm-Sprung](#jsr_code) erfolgt.

Sofern die Funktion eine nennenswerte Größe hat, ist der Unterprogrammsprung
allerdings der weniger entscheidende Nachteil.

.N[
Eine viel wichtigere Rolle kommt modernen CPU-Architekturen zu, welche die
Tatsache, dass durch die Verzweigung die rein sequentielle Ausführung
unterbrochen wird.
]

Dies hat zur Folge, dass bei Eintritt in das Unterprogramm und bei dessen
Verlassen die Pipeline mit bereits teilweise dekodierten Maschinenbefehlen
dort gespeichert worden sein müsste.

---
template: plain
name: contra_inline
header: #### Nachteile von Inline-Funktionen

[PIMPL-Idiom]: http://en.wikibooks.org/wiki/C%2B%2B_Programming/Idioms

Weiterhin ist bei der Verwendung von Inline-Funktionen folgendes zu bedenken:

* Die Implementierung muss im Header-Files erfolgen.

* In der Kombination mit `virtual` werden `inline` Funktionen oftmals dennoch
  als echtes Unterprogramm umgesetzt.

.N[
Anders gesagt: bei der Kombination von `inline` und `virtual` bleibt ersteres
u.U.  wirkungslos – [detaillierte Erläuterungen](#virtual_inline) folgen später.
]

Die Implementierung im Header-File erhöht jedoch den Grad der Kopplung durch
Compilezeit-Abhängigkeiten, womit Änderungen an einer `inline` Funktion oft
umfangreiche Re-Kompilierungen auslösen.._[]

.F[:
Im Grunde genommen geschieht durch `inline` für Member-Funktionen das Gegenteil
von dem, was für Member-Daten durch Anwendung des [PIMPL-Idiom] erreicht werden
soll.
]

Der Verzicht auf `virtual` – damit `inline` auf jeden Fall Wirkung zeigt –
beschränkt abgeleitete Klassen darin, von ihren Basisklassen geerbte
Member-Funktionen zu überschreiben, um deren Verhalten anzupassen.

---
template: withinfo
graphic: ClassToMemoryMapping
section: Public versus Private Base Classes
name: public_bases
header: ### Öffentliche Basisklassen

[LSP]: http://en.wikipedia.org/wiki/Liskov_substitution_principle
[Vererbung]: http://en.wikipedia.org/wiki/Class_diagram#Generalization

Gemäß der objektorientierten Sichtweise entspricht dies der *Vererbung*.

Aus Sicht auf die Member-Daten handelt es sich zunächst nur um eine
Verschachtelung von Strukturen:

* Die Daten der für die Basisklasse erzeugten Struktur sind

* **direkt enthalten** in den Daten der für die abgeleitete Klasse erzeugten
  Struktur.

Zusätzlich gilt das [LSP] (Liskov Substitution Principle), gemäß dem ein ggf.
erforderlicher Up-Cast (`Derived` → `Base`) vom Compiler automatisch erfolgt.

.N[
Da die Daten der Basisklasse direkt am Anfang der abgeleiteten Klasse liegen,
erfordert das LSP zur Laufzeit keinerlei Code!._[]
]

.F[:
Bei Mehrfachvererbung gilt diese Aussage nur noch eingeschränkt.
]

---
template: withinfo
graphic: ClassToMemoryMapping
section: Public versus Private Base Classes
name: private_bases
header: ### Private Basisklassen

[Komposition]: http://en.wikipedia.org/wiki/Class_diagram#Composition
[GoF]: http://c2.com/cgi/wiki?DesignPatternsBook
[Template Methode Pattern]: http://c2.com/cgi/wiki?TemplateMethodPattern

Gemäß der objektorientierten Sichtweise entspricht dies der Komposition.

So gesehen sind private Basisklassen in C++ zunächst lediglich eine Alternative
zur Realisierung der [Komposition über Member-Daten](#member_composition).

* Zusätzlich hat bei einer privaten Basisklassen aber die abgeleitete Klasse die
  Möglichkeit, geerbte Methoden zu überschreiben.

* Daher kann das [GoF] [Template Methode Pattern] in C++ auch mit geringerer
  Kopplung._[] zwischen Basisklasse und abgeleiteten Klassen umgesetzt werden.

.F[:
Stronger or looser coupling between too classes defines how much the one depends
on the other – be in terms of documented behaviour (the good part) or accidental
implementation details (what should be avoided in theory but happens in
practice). In case of private base classes the coupling only exists through the
public interface **plus** `virtual` members and hence is lesser as in case of
public base classes, where coupling – at least potentially – may also be via the
protected interface.
]

.N[
Das Speicher-Layout ist dasselbe wie bei Vererbung, es gilt aber **nicht** das
LSP, d.h. ein `Derived`-Objekt kann nicht stillschweigend ein `Base`-Objekt
substituieren.
]

---
template: withinfo
graphic: ClassToMemoryMapping
section: Composition in General
name: member_composition
header: ### Komposition über Member-Daten

Komposition wird in C++ im allgemeinen dadurch realisiert, dass eine Klasse –
die Gesamtheit – eine andere Klasse – das Teil – im Rahmen ihrer Member-Daten
direkt enthält.

* Durch die Anordnung der Daten-Member im Speicher, welche zu steigenden
  Adressen hin der Reihenfolge im Quelltext von oben nach unten._[] entspricht,
  liegt das Teil aber nicht zwingend am Anfang der Gesamtheit.

* Des weiteren muss bei Bezugnahme auf das Teil dessen Name explizit verwendet
  werden, während im Fall der Basisklasse

  * bei Eindeutigkeit keine weitere Qualifikation notwendig ist, und

  * ansonsten der Klassenname per Scope-Operator (`Base::`) vorangestellt wird.

.F[:
It is assumed here that there is only one data member defined per line. If
several data members are defined in the same line, those more to the left get
placed at lower addresses in memory (through lower offsets from the begin of the
class' data space.)
]

---
template: plain
name: composition_example_1
header: #### Vergleich: Komposition über Member-Daten

Zur Verdeutlichung des Unterschieds der beiden Formen von Komposition
hier zunächst der Weg über Member-Daten als Code-Fragment:
```
class Motor {
    …
public:
    void start_engine();
    …
};

class Car {
    Motor m;
    …
    void start_engine() {
        … // prepare starting the motor
        m.start_engine();
        … // check for engine errors
    };
}
```


---
template: plain
name: composition_example_2
header: #### Vergleich: Komposition über private Basisklasse

Und hier das Code-Fragment mit einer privaten Basisklasse zur
Komposition:
```
class Motor {
    …
protected:
    void start_engine();
    …
};

class Car : private Motor {
    …
public:
    void start_engine() {
        … // prepare starting the motor
        Motor::start_engine();
        … // check for engine errors
    };
}
```

---
template: plain
name: composition_example_3
header: ##### Erweiterungspunkte in Basisklassen

Nur mit Hilfe einer privaten Basisklasse läßt sich die folgende Form des
Zusammenspiels von Auto und Motor erreichen, bei welcher der Motor für die
Benutzung durch das Auto._[] bereits *Erweiterungspunkte* vorgibt.
```
class Motor {
    …
    // extension points for aggreagate class
    virtual void prepare_engine_start() {}
    virtual void check_engine_errors() {}
   …
public:
    void start_engine() {
        prepare_engine_start();
        … // actually start the engine
        check_engine_errors();
    }
    …
};
```

.F[:
Oder wo immer der Motor später einmal als Komponente eingebaut wird …
]

---
template: plain
name: composition_example_4
header: ##### Nutzung der Erweiterungspunkte

Das Auto nutzt nun lediglich die vom Motor zur Verfügung gestellten
Erweiterungspunkte, **überschreibt aber nicht die Member-Funktion** zum Starten
des eingebauten Motors.._[]

```
class Car : private Motor {
    …
    // implement extension points ...
    virtual void prepare_engine_start() {
        … // whatever is necessary
    }
    virtual void check_engine_errors() {
        … // whatever is necessary
    };
public:
    using Motor::start_engine;
};
```

.F[:
In a more "cautious" design `Motor` could make its `start_engine()` member
function protected (or even private!) and leave its exposition up to `Car`,
typically then with a public `using Motor::start_engine` directive.
]
---
template: linkinfo
graphic: ContainerImplementations
name: implementing_containers
header: ## Techniken zur Implementierung von Containern

------------------------------------------------------

* [Ableitung von der Elementklasse](#node_inheritance)
* [Verwendung von Templates](#templated_containers)

------------------------------------------------------

* [Containern mit polymorphen Elementen](#polymorphic_elements)

------------------------------------------------------

---
template: withinfo
graphics: ContainerImplementations
section:
name: node_inheritance
header: ### Auf Vererbung basierende Technik

Hierbei wird in der Elementklasse nur die Verwaltungsinformation definiert – bei
einer einfach verketteten Liste ist das lediglich der Zeiger auf das nächste
Element.

Um möglichst wenige Bezeichner in den globalen Namensraum einzubringen, erscheint
es sinnvoll, die Elementklasse geschachtelt zu definieren:._[]
```
class Lifo {
    class Node {
        friend class Lifo;
        Node *next;
    protected:
        Node() : next(nullptr) {}
    };
    …
};
```

---
template: plain
header: #### "Freundschaft" eng gekoppelter Klassen

[Jiri Sukoup]: http://c2.com/cgi/wiki?JiriSoukup
[Taming C++]: http://www.amazon.com/exec/obidos/ISBN=0201528266/portlandpatternrA/

Bei C++-Entwicklern gibt es mitunter Vorbehalte in Bezug auf die Nutzung von
`friend`-Beziehungen.

Der Grund ist vermutlich, dass ältere Fachliteratur._[] mitunter die völlig
unberechtigte Ansicht verbreitete, damit würde der Zugriffsschutz geschwächt –
jedoch ist das Gegenteil ist der Fall!

.I[
Sofern zwei Klassen **miteinander** deutlich enger zusammenarbeiten als "mit
dem Rest der Welt", lässt sich über `friend`-Beziehungen eine deutlich bessere
Kapselung im Sinne des Zugriffsschutzes erzielen.
]

* Durch ausschließlich nicht-öffentliche Member in `Lifo::Node` kann auf den
`next`-Zeiger jetzt nur noch die `Lifo`-Klasse zugreifen.

* Ohne `friend`-Beziehung müssten `Lifo::Node`-s eine Member-Funktion
bereitstellen, mit der **jeder(!)** den `next`-Zeiger verändern kann.

.F[:
Auch in C++-Fachveröffentlichungen gab und gibt es gelegentlich die Tendenz,
einfach voneinander abzuschreiben, ohne die Sachlage selbst zu überdenken …
Explizit **nicht** zur Gruppe solcher Autoren gehört [Jiri Sukoup], der in
seinem Buch [Taming C++] bereits 1994 den Nutzen von `friend`-Beziehungen
ausführlich darstellte, obwohl er sich damit in Gegenposition zu anderen
Autoren begab.
]

---
template: plain
header: #### Container-Elemente mit Daten

Um in den Elementen des Containers auch Daten unterzubringen, müssen
zunächst entsprechende Klassen abgeleitet werden, z.B. für Gleitpunkt-Zahlen …
```
class Double_Node : public Lifo::Node {
public:
    Double_Node(double d) : data(d) {}
    double data;
};
```

… oder Zeichenketten:
```
#include <string>
class Double_Node : public Lifo::Node {
public:
    String_Node(const std::string &s) : data(s) {}
    std::string data;
};
```

Wie man sieht, ist der Code solcher Klassen sehr systematisch!

---
template: plain
header: #### Daten-Elemente als Templates

Das immer wieder nahezu gleiche Quelltext der abgeleiteten Datenklassen legt
die Verwendung von Templates nahe:._[]
```
template<typename ELemType>
class Data_Node : public Lifo::Node {
public:
    Data(const ElemType &d) : data(d) {}
    ElemType data;
};
```
.N[
Dies hat nichts mit der auf Templates basierenden Implementierung von Containern
zu tun, die später gezeigt wird.
]

An dieser Stelle geht es einzig und allein darum, den sehr ähnlichen Quelltext
für die Klassen der Daten-Elemente im Sinne des DRY-Principles zusammenzufassen!

.F[:
Das Argument des Konstruktors wird nun auf jedem Fall per Referenz übergeben,
was im Allgemeinen zu einem leichten Overhead für Grundtypen geringer Größe
führen dürfte. Im obigen Fall handelt es sich jedoch um eine Inline-Funktion
(durch Implementierung in der Klasse selbst), womit effektiv überhaupt keine
Argumentübergabe stattfinden wird.
]

---
template: plain
name: insert_elements
header: #### Datenelemente erzeugen und einfügen

Dies kann für ein `Lifo c` ggf. in einem einzigen Schritt geschehen:
```
c.push(new Double_Node(47.11));
c.push(new String_Node("hello, world!"));
```

Oder mit Templates für die Klassen der Datenelemente:
```
c.push(new Data_Node<double>(47.11));
c.push(new Data_Node<std::string>("hello, world!"));
```

---
template: plain
name: insert_elements
header: #### Template-Helfer-Funktionen

Die redundante Angabe des Typs als Template-Argument im letzten Code-Fragment
legt die Definition einer Hilfsfunktion nahe:
```
template<typename ElemType>
Data_Node<ElemType> *make_Data_Node(const ElemType &v) {
    return new Data_Node<ElemType>(v);
}
…
c.push(make_Data_Node(47,11));
c.push(make_Data_Node(string("hello, world")));
```

Zur bequemen Übergabe von Zeichenketten-Literalen als `std::string` sollte
kann man noch eine spezifische Überladung hinzufügen:._[]
```
Data_Node<std::string> *make_Data_Node(const char *v) {
    return new Data_Node<std::string>(v);
}
…
c.push(make_Data_Node("hello, world"));
```

.F[:
Here we already have taken a few steps beyond the border of "programming with
templates" land – for the moment we will retreat, but this path will be
followed in a later chapter.
]

---
template: plain
header: #### Datenelemente entnehmen

[Java Generics]: http://en.wikipedia.org/wiki/Generics_in_Java

Hier zeigt sich nun ein gravierender Nachteil, denn das grundsätzlich
erforderliche Vorgehen sieht so aus:
```
Lifo c;
…
Lifo::Node *p = c.pop();
```

* Im Rahmen der Implementierung des Containers ist nichts anderes als die
  `Lifo::Node` Klasse bekannt.

* Insofern kann bei der Entnahme mit der Member-Funktion `Lifo::pop` auch nur
  ein solcher, allgemeiner Elementzeiger zurückgegeben werden.

* Für diesen muss zur weiteren Verwendung ein expliziter Down-Cast
  erfolgen.._[]

.F[:
Dies ist alles, was [Java Generics] automatisieren, und insofern sollten diese
– trotz ähnlicher Syntax – nicht mit C++ Templates verglichen werden: es liegen
Welten dazwischen!
]

---
template: plain
header: ##### Datenelemente verwendbar machen mit `dynamic_cast` auf Zeigerbasis

Die sichere Variante verwendet einen Down-Cast mit Prüfung des Laufzeit-Typs:
```
Double_Node *p = dynamic_cast<Double_Node*>(c.pop());
if (p != nullptr) {
    // OK, has expected type
    // may access p->data now
}
else {
    // Oops - not a Double_Node ??
}
```

Bereits C++98 erlaubt übrigens auch die etwas kompaktere Form._[]
```
if (Double_Node *p = dynamic_cast<Double_Node*>(c.pop())) …
```

womit sich die Sichtbarkeit von `p` auf die `if`-Anweisung beschränkt.

.F[:
In C++11 weiter verkürzbar zu:
`if (auto p = dynamic_cast<Double_Node*>(c.pop())) …`
]

---
template: plain
header: ##### Datenelemente verwendbar machen mit `dynamic_cast` auf Referenzbasis

Wenn im Fehlerfall ohnehin ein Abbruch erfolgen müsste, da die falsche Datenart
völlig unerwartet vorgefunden wurde und nicht weiterverarbeitet werden kann,
geht es auch so:
```
Double_Node &n = dynamic_cast<Double_Node&>(*c.pop());
// if the cast didn't throw, n.data may be accessed now
```

Diese Form lässt sich auch mit dem direkten Member-Zugriff verbinden:
```
… dynamic_cast<Double_Node&>(*c.pop()).data …
```

.N[
Mehr zu `dynamic_cast` und ein Vergleich zum weniger sicheren `static_cast`
folgt als Bestandteil des Abschnitts [RTTI](#dynamic_cast).
]

---
template: plain
name: memory_leaks
header: ### Memory Leaks

[Memory Leaks]: http://www.cprogramming.com/tutorial/memory_debugging_parallel_inspector.html

Da in C++ keine Garbage Collection existiert, sind [Memory Leaks] immer wieder
ein Thema.

.W[
In allen vorhergehenden Beispielen, welche Elemente aus dem `Lifo` entnehmen,
wurde das Thema Speicherverwaltung bislang vernachlässigt – es wird dafür auf
den folgenden Seiten im Zentrum stehen.
]

Am besten ist es, wenn das Thema Speicherverwaltung im frühzeitigen
Programm-Design Berücksichtigung findet.

* Probleme, die ihre Wurzeln in einem (für C++) unangemessenen Programm-Design
  haben, nachträglich "per Debugging" anzugehen, kann schnell uferlos werden.

* Zwar gibt es eine Reihe von Tools, welche beim Aufspüren solcher Probleme
  helfen, sie demonstrieren aber nur die "Symptome" und liefern nicht die
  "Arznei" zu deren Vermeidung.

---
template: plain
header: #### Verantwortlichkeit für die Speicherverwaltung

Bei der auf Ableitung von den Elementklassen bestehenden Vorgehensweise liegt
die Verantwortung für die Speicherverwaltung außerhalb der Container-Klasse.

* Die Datenelemente werden **vor** dem eigentlichen Einfügen im dynamischen
 Speicher erzeugt.

* Daher muss auch das Löschen **nach** der Entnahme explizit erfolgen.

```
Double_Node *p = dynamic_cast<Double_Node*>(c.pop());
if (p != nullptr) {
    // OK, has expected type
    … // may access p->data now
    delete p;
}
```

.W[
Dieser Code weist allerdings das Problem auf, dass ein anderer als der erwartete
Datentyp zu einem Memory-Leak führen könnte, da dann kein `delete` erfolgt.
]

---
template: plain
header: #### Speicherfreigabe über Zeiger auf Basisklassen

Ein möglicher Ausweg kann so aussehen:
```
Lifo::Node *p = c.pop();
if (Double_Node *dp = dynamic_cast<Double_Node*>(p)) {
    // OK, has expected type
    … // may access p->data now
}
```
Nun könnten noch weitere Tests auf andere mögliche Elementtypen, und dann ganz
am Ende (außerhalb aller bedingten Blöcke):
```
// release dynamic memory
delete p;
```

.W[
Allerdings ist Code wie der obige nur dann korrekt, wenn der Destruktor
`Lifo::Node::~Node()` virtuell ist.
]

---
template: withinfo
graphic: ContainerImplementations
section: (Node-) Inheritance Technique
name: templated_containers
header: ### Auf Templates basierende Technik

Bei dieser in C++ mittlerweile viel gängigeren Alternative wird zunächst die
`Lifo`-Klasse selbst als Template definiert:
```
template<class ElemType>
class Lifo {
    class Node;
    Lifo *top;
public:
    Lifo() : top(nullptr) {}
    void push(const ElemType &);
    void pop(ElemType &);
};
```

---
template: plain
header: #### Template für Klasse der Datenelemente

Durch die geschachtelte Definition der Elementklasse wird auch diese zur
Template und kann damit den Datenteil im Typ parametrisiert enthalten:
```
template<class ElemType>
class Lifo<ElemType>::Node {
    Node *next;
    ElemType data;
    Node(Node const* n, const ElemType& d)
        : next(n), data(d)
    {}
    friend class Lifo<ElemType>;
};
```

---
template: plain
header: #### Operation zum Einfügen neuer Datenelemente

Mit der gezeigten Änderung des Designs, die den `next`-Zeigers über ein Argument
des Konstruktor initialisiert, ergibt sich eine sehr einfache Implementierung
der Einfüge-Operation:
```
template<class ElemType>
void Lifo<ElemType>::push(const ElemType &d) {
    head = new Node(head, d);
}
```

.I[
Nach wie vor werden die Datenelemente zwar im dynamischen Speicher angelegt, die
Erzeugung ist nun allerdings gekapselt im Code der Container-Klasse.
]

---
template: plain
header: #### Operation zur Entnahme von Datenelemente

Somit erscheint es naheliegend, auch die Freigabe in der `Lifo`-Klasse zu
kapseln:
```
template<class ElemType>
bool Lifo<ElemType>::pop(ElemType &d) {
    if (head == nullptr)
        return false;
    auto p = head;
    d = p->data;
    head = p->next;
    delete p;
    return true;
}
```

.I[
Ein virtueller Destruktor ist nun nicht mehr erforderlich, da die `delete`
Anweisung nicht wie in den auf Vererbung beruhenden Beispielen über einen
Basisklassen-Zeiger erfolgt.
]

---
template: plain
header: #### Destruktor der Container-Klasse

Aufgrund des Übergangs der Verantwortlichkeit für die Verwaltung des dynamischen
Speichers der Datenelemente sollte spätestens jetzt auch die `Lifo`-Klasse einen
Destruktor erhalten:
```
Lifo::~Lifo() {
    auto p = head;
    while (p != nullptr) {
        const auto p_next = p->next;
        delete p;
        p = p_next;
    }
}
```

.N[
Ob ein ähnlicher Destruktor auch für die andere (auf Vererbung basierende)
Implementierung sinnvoll wäre oder gar notwendig ist, hängt von einer
eingehenden Analyse des Codes ab, welcher den Container tatsächlich benutzt.._[]
]

.F[:
Ohne eine solche Analyse wird die Sache leicht zum Grund für Memory-Leaks –
nämlich wenn es *keinen* solchen Destruktor gibt aber eigentlich einen geben
müsste; oder es kommt zu vorzeitig freigegebenem Speicherplatz von noch
benutzten Datenelementen – wenn es einen solchen Destruktor gibt aber eigentlich
*keinen* geben sollte).
]

---
template: plain
name: typesafe_push
header: #### Typsicherheit beim Einfügen

Neben der sicheren Speicherverwaltung macht der Blick auf die Implementierung
einen anderen Vorteil dieser Technik klar:

Die Schnittstelle zum Einfügen und Entnehmen von Elementen ist nun typsicher:
```
Lifo<double> c1;
Lifo<std::string> c2;

// OK
c1.push(3.14);
c2.push("hi!");

// Compile-Error!!
c1.push("hi!");
c2.push(3.14);
```

---
template: plain
name: typesafe_pop
header: #### Typsicherheit beim Entnehmen

Dies gilt ebenso für die Entnahme von Elementen:
```
double d;
std::string s;

// OK
c1.pop(d);
c2.pop(s);

// Compile-Error!!
c1.pop(s);
c2.pop(d);
```

---
template: withinfo
graphics: ContainerImplementations
section: Non-Polymorphic Elements
name: container_implementations
header: #### Slicing als Nachteil der Templates

Die bessere Sicherheit vor Memory-Leaks durch die Übertragung der
Speicherverwaltung in die Verantwortung der `Lifo`-Klasse und der Gewinn an
Typsicherheit beim Einfügen und Entnehmen haben auch eine Kehrseite:

.W[
Eventuell erwünschter Polymorphismus für die Container-Elemente geht damit
verloren.
]

Mit einer Basisklasse für Früchte allgemein (`Fruit`) und abgeleiteten Klassen
für spezifische Früchte (`Apple` `Banana`, `Kiwi`, …) ist `Lifo<Fruit>`
*nicht* der evtl. erwartete "Obstkorb":

* Beim Einfügen wird von den speziellen, für die `Fruit`-Klasse spezifischen
  Anteil entfernt (Slicing) und

* bei der Entnahme kommt somit nur der unspezifische, als `Fruit` implementierte
  Teil zurück.

---
template: withinfo
graphic: ContainerImplementations
section: Polymorphic Elements
name: container_implementations
header: ### Template-Technik mit explizitem Polymorphismus

Wird bei auf Templates basierenden Container Polymorphismus hinsichtlich der
Datenelemente benötigt, muss explizit ein Container von Zeigern verwendet
werden:
```
Lifo<Fruit *> allMyFruits;
```

.W[
Allerdings geht damit die Verantwortung für den Speicherplatz wieder auf
denjenigen über, der den Container benutzt.
]

Das Einfügen muss nun so erfolgen:
```
allMyFruits.push(new Banana( … ));
allMyFruits.push(new Apple( … ));
```

---
template: plain
header: ##### Entnahme von Basisklassen-Zeigern

Die Entnahme sieht prinzipiell so aus:
```
Fruit *f = nullptr;
while (allMyFruits.pop(f)) {
    // got another one!
    … // now wash it, peal it, eat it,
    delete f;
}
```

.W[
Für die Korrektheit des obigen Codes muss der Destruktor `Fruit::~Fruit()`
virtuell sein!
]

C++ Style-Guides legen mitunter nahe, sicherheitshalber

* **alle** Klassen mit einem virtuellen Destruktor auszustatten,
* oder zumindest Klassen, die als Basisklassen verwendet werden,
* oder zumindest Klassen, die wenigstens eine (andere) Member Funktion als
  `virtual` definieren.._[]
.F[:
But all these rules miss the key question, which could have been posed already
at design time: What knowledge about the class hierarchy is available where the
`delete` takes place?
]


---
template: plain
header: ##### Ermittlung der abgeleiteten Klasse

Schließlich muss im Anschluss an die Entnahme einer Frucht geprüft werden, was
man eigentlich bekommen hat:
```
// got another one!
if (auto &apple = dynamic_cast<Apple&>(*f)) {
    // look it's an apple
    … // wash it, eat it
}
if (auto &banana = dynamic_cast<Banana&>(*f)) {
    // look, it's a banana
    … // peal it, eat it
}
```

Während die gezeigte Vorgehensweise funktioniert, kann sie unter dem Aspekt eines
guten objekt-orientierten Designs kritisiert werden.

.N[
[Eine Alternative zur obigen, typbasierten Mehrfach-Verzweigungen wird später
noch ausführlicher betrachtet.](#multiway_typeswitch)
]

---
template: plain
header: #### Pointer in auf Templates basierenden Containern

Durch die damit verbundene Bequemlichkeit bei den STL-Containern wird die
Wert-Semantik schnell zur Gewohnheit.

Damit geht bei expliziten Zeigern in Containern oft der Blick für die damit
verbundenen Gefahren und Besonderheiten verloren.

Beim gerade gezeigten "Obstkorb" besteht z.B. ein Dilemma:

* Sollte er sich als Eigentümer des Speicherplatzes sehen, auf den die
  enthaltenen Zeiger verweisen,
* oder sollte er das eher nicht tun?._[]

.F[:
Do not take this lightly … an inappropriate decision may lead to a memory leak,
or even worse, cause dangling pointers.
]

.N[
ResourceWrapper-Klassen können hier helfen, im konkreten Fall:

* `Lifo<std::unique_ptr<Fruit>>` oder
* `Lifo<std::shared_ptr<Fruit>>`

Diese werden in einem späteren Kapitel ausführlicher behandelt.
]

---
template: linkinfo
graphic: RuntimeTypeIdentification
name: runtime_type_identification
header: ## Typ-Bestimmung zur Laufzeit

-----------------------------------------------------------------------

* [Umsetzung von Dynamischem Polymorphismus	](#dynamic_poymorphism)

-----------------------------------------------------------------------

* [Typ-Identifikation zur Laufzeit		](#explicit_rtti)

-----------------------------------------------------------------------

---
template: plain
name: rtti_prerequisites
header: ### RTTI-Voraussetzungen

Mit C++98 wurde die explizite Laufzeit-Typinformation (RTTI) zum verbindlichen
Sprachfeature.

* Die Information der Klassen-Zugehörigkeit muss dafür im Objekt selbst
  untergebracht sein.

* Nicht jedes Objekt braucht diese Information und sollte unnötigen Overhead
  vermeiden können.

.I[
Klassen müssen mindestens eine virtuelle Member Funktion haben, damit für ihre
Objekte RTTI verfügbar ist.
]

Implizit war eine Laufzeit-Typidentifikation immer schon Bestandteil von C++, da
die Ausführung virtueller Member-Funktionen vom Laufzeit-Typ abhängt. Insofern ist
es auch naheliegend, RTTI an die Existenz virtueller Methode zu knüpfen.

---
template: withinfo
graphic: RuntimeTypeIdentification
section: Details of Late Binding
name: dynamic_poymorphism
header: ### Dynamischer Polymorphismus

Hierbei handelt es sich um eine implizite Form der Laufzeit-Typidentifikation.
Eine andere übliche Bezeichnung ist "spätes Binden" (late binding) oder auch
"dynamisches Binden".

Im Unterschied zum statischen Polymorphismus entscheidet dabei der Laufzeit-Typ über
die Auswahl einer aufzurufenden Member-Funktion.

Voraussetzung dafür ist:

* Der Aufruf erfolgt über eine Objekt-Referenz oder einen Objekt-Zeiger. Diese(r)
  legt den Compilezeit-Typ fest, gemäß dem entschieden wird, **welche** Member
  Funktionen überhaupt aufgerufen werden können.

* Die aufgerufene Member-Funktion wurde in der betreffenden Klasse als `virtual`
  deklariert._[]

.F[:
Da eine geerbte virtuelle Member-Funktion in der abgeleiteten Klasse virtuell
bliebt, auch wenn sie dort nicht explizit so markiert ist, ist die `virtual`
Deklaration in einer Basisklasse ausreichend.
]

---
template: plain
header: #### Zweck des dynamischen Polymorphismus

Generell geht es bei der Ermittlung des Laufzeit-Typs eines Objekts darum, auf
dieser Basis zu entscheiden, welche von ggf. mehreren überschriebenen virtuellen
Member-Funktion aufzurufen ist.._[]
```
class Base { … virtual void foo(); … };
class Derived : public Base { … }; // this does not override foo(),
                                   // but the following two do:
class MoreDerived : public Derived { … virtual void foo(); … };
class OtherDerived : public Base { … virtual void foo(); … };
…
void bar(Base &b) { // or: bar(Base *p)
    b.foo();        //     p->foo();
}
…
// now for some calls of foo through bar:
Base b;         bar(b); // calls Base::foo()
Derived d;      bar(d); // same
MoreDerived m;  bar(m); // calls MoreDerived::foo()
OtherDerived o; bar(o); // calls OtherDerived::foo()
```

.F[:
Another interesting point is this: to compile `bar` nothing but `Base` needs to
be known, in fact the derived classes might not even have been written then, but
the code manages somehow to always call the right overrides …
]

---
template: plain
name: implement_vcall
header: #### Implementierung des dynamischen Polymorphismus

Die übliche Vorgehensweise beruht auf dem indirekten Einsprung in ein
Unterprogramm über eine Tabelle von Zeigern.

Hierzu führt jedes Objekt, das einer Klasse mit **mindestens** einer virtuellen
Member-Funktion angehört,

* **genau** einen zusätzlichen Zeiger mit,

* welcher wiederum auf eine Tabelle mit den Adressen **aller** ihrer virtuellen
  Member-Funktionen zeigt.

Da diese Tabelle **klassenspezifisch** ist, und muss sie in einem Gesamtprogramm
nur **einmal pro Klasse** vorhanden sein.._[]

.I[
Diese Technik ist nicht zwingend aber sehr effizient und wird daher in praktisch
allen C++-Implementierungen benutzt.
]

.F[:
Dies gilt zumindest prinzipiell und hängt in der Praxis davon ab, dass bei einer
modulweise getrennten Kompilierung der Linker ggf. vorsorglich *einmal pro
Objekt-Modul* angelegte Exemplare dieser Tabelle bis auf eines eliminiert.
]

---
template: plain
name: virtual_inline
header: #### Kombination von `virtual` und `inline`

Die früher getroffene Feststellung, das `virtual` und `inline` einander quasi
ausschließen, soll nun etwas präzisiert werden:

* Rein technisch kann beides durchaus zusammentreffen, und zwar

  * sowohl explizit –  wenn beide Schlüsselworte verwendet werden,

  * wie auch implizit, wenn einer als `virtual` gekennzeichneten
    Member Funktion direkt in der Klasse selbst implementiert wird.

* Dann hängen die Details der Umsetzung vom Aufruf ab:

  * Richtet sich dieser **direkt an ein Objekt**, wird der Implementierungs-Code
    an Ort und Stelle statt eines Unterprogramm-Aufrufs eingesetzt.

  * Geht er an ein **über Zeiger oder Referenz** angesprochenes Objekt, erfolgt
    die zuvor beschriebene, polymorphe Umsetzung.

Bei letzterer ist Unterprogrammsprung zwingend und daher wird eine Funktion, die
`virtual` und `inline` ist, stets als potenziell polymorph betrachtet, d.h. es
muss dafür ein echtes Unterprogramm verfügbar sein.

---
template: plain
name: explicit_rtti
header: ### Explizites RTTI

Hierfür stehen zwei Mechanismen zur Verfügung:

* `dynamic_cast` und

* `typeid`

Ersterer prüft den Typ im Sinne des LSP, das heißt eine abgeleitete Klasse
wird auch an Stelle der gewünschten akzeptiert, letzterer prüft exakt.

---
template: plain
name: dynamic_cast
header: #### RTTI mit dynamischem Cast

Es gibt zwei Formen, mit denen z.B. geprüft werden kann, ob der Laufzeit-Typ
einer von `Base` abgeleitete Klasse `Derived` ist – oder noch tiefer abgeleitet.

##### `dynamic_cast` auf Zeigerbasis

```
Base *p = nullptr;
… // p gets assgned an address and may point
  // to Base or any class derived from Base

Derived *dp = dynamic_cast<Derived*>(p);
```
Hier wird `dp` ein `nullptr` sein, wenn die Prüfung negativ ausgeht und muss
somit entsprechend geprüft werden.

```
Base &r = … ; // r gets initialized and may refer to
              // Base or any class derived from Base
Derived *dp = dynamic_cast<Derived*>(&b);
```

---
template: plain
header: #### RTTI mit dynamischem Cast (2)

##### `dynamic_cast` auf Referenzbasis
```
Base &r = … ; // r gets initialized and may refer to
              // Base or any class derived from Base
…
Derived &dr = dynamic_cast<Derived&>(r);
```
Hier wird eine Exception geworfen, wenn die Prüfung negativ ausgeht.

Damit kann diese Form leicht Bestandteil eines Ausdrucks verwendet werden,
insbesondere um eine Member-Funktion aufzurufen, die von einer abgeleiteten
Klasse hinzugefügt wurde:
```
… dynamic_cast<OtherDerived &>(r).phoo( … ) …
```

Die Referenzform ist auch `Base *p`-Zeiger verwendbar:
```
OtherDerived &dr = dynamic_cast<OtherDerived &>(*p);
… dynamic_cast<OtherDerived &>(*p).foo() …
… &dynamic_cast<OtherDerived &>(*p)->foo() …

```

---
template: withinfo
graphic: RuntimeTypeIdentification
section: Storing RTTI Related Meta-Data
name: runtime_typeident
header: ### Implementierung von explizitem RTTI

[`class std::type_info`]: http://en.cppreference.com/w/cpp/types/type_info

Hierfür gibt es keinen durchgängigen Standard – ein klein wenig lässt sich
jedoch erahnen:

Egal ob im Rahmen von RTTI verwendet oder für eingebaute Typen und
nicht-polymorphe Klassen:

* `typeid` liefert eine Referenz auf eine `class type_info` zurück.

* Jeweils ein Objekte dieser Klasse muss ein kompiliertes C++-Programm für
  **jede** darin verwendete Klasse vorhalten, für den Fall, dass es mit
  `typeid` angesprochen wird.._[]

Um dynamischen Polymorphismus zu unterstützen, könnten solche Objekte mit der
Sprungtabelle für die virtuellen Member-Funktionen zusammengefasst werden,
oder sie liegen an anderen Stelle und die Sprungtabelle verweist darauf.

.F[:
Da dies statisch entscheidbar ist, kann spätestens der Linker überflüssige
`type_info`-Objekte aus dem endgültigen, ausführbaren Programm herauslassen.
]


---
template: linkinfo
graphic: TypeBasedBranching
name: multiway_typeswitch
header: ## Typbasierte Verzweigungen

----------------------------------------------------------------------------

* [Typgesteuerter Kontrollfluss		](#typeswitched_controlflow)

----------------------------------------------------------------------------

* [Alternative mit
   virtuellen Funktionen		](#polymorphic_approach)

----------------------------------------------------------------------------

---
template: withinfo
graphic: TypeBasedBranching
section: Type-based Flow Of Control
name: typeswitched_controlflow
header: ### Typ-Gesteuerter Kontrollfluss

.N[
Siehe Info-Grafik zusammen mit den Ausführungen des Dozenten.
]

---
template: withinfo
graphic: TypeBasedBranching
section: Dymnamic Polymorphism
name: polymorphic_approach
header: ### Alternative mit virtuellen Funktionen

.N[
Siehe Info-Grafik zusammen mit den Ausführungen des Dozenten.
]

---
layout: false
template: blank
name: part7

# [C++ FOR](#agenda) (Part 7) From Parametrized Types to Meta-Programming

-------------------------------------------------------------------------------

1. [Implementing Templates			](#writing_templates)
1. [Optimising Templates			](#optimising_templates)
1. [Perfect Forwarding with Templates		](#perfect_forwarding)
1. [Templates as Compile Time Functions		](#compiletime_functions)
1. [Variadic Templates (Parameter Packs)	](#variadic_templates)
1. [Advanced Use of the Preprocessor		](#advanced_preprocessor)

-------------------------------------------------------------------------------

---
template: linkinfo
graphic: TemplateBasics
name: writing_templates
header: ## Templates selbst schreiben

-------------------------------------------------------------------------------

* [Template-Klassen	](#template_classes)

-------------------------------------------------------------------------------

* [Template-Funktionen	](#template_functions)

--------------------------------------------------------------------------------

---
template: withinfo
graphic: TemplateBasics
section: Template Classes
name: template_classes
header: ### Template-Klassen

Template-Klassen sind im Hinblick auf Datentypen und/oder andere
Compilezeit-Konstanten parametrisierte Klassen.

Man spricht in diesem Zusammenhang auch von generischen Klassen.

.N[
Bei der Verwendung von Template-Klassen sind die entsprechenden Typ- und
Wertargumente stets anzugeben.
]

---
template: withinfo
graphic: TemplateBasics
section: Template Functions
name: template_functions
header: ### Template-Funktionen

Template-Funktionen sind in der Regel im Hinblick auf Datentypen._[]
parametrisierte Funktionen

.N[
Bei der Verwendung von Template-Funktionen ergeben sich die tatsächlich zu
verwendenden Typen oft direkt oder indirekt aus den Typen der Aufrufargumente.
]

.F[:
Die Parametrisierung im Hinblick auf Compilezeit-Konstanten ist bei Funktionen
ebenfalls möglich, tritt in der Praxis aber sehr selten auf.
]

---
template: linkinfo
graphic: ReducingCodeBloat
name: optimising_templates
header: ## Optimierung von Templates

------------------------------------------------------------------------

* [Ursache für "Code-Bloat"		](#reason_for_codebloat)

------------------------------------------------------------------------

* [Über einen Zwischenschritt …		](#intermediate_step)
* [… zur optimierten Template		](#optimised_template)

------------------------------------------------------------------------

---
template: withinfo
graphic: ReducingCodeBloat
section: Resons for Code Bloat
name: reason_for_codebloat
header: ### Ursache für "Code-Bloat"

"Unnötig erzeugter" Maschinencode ergibt sich oft aus einer ungeschickten
Strukturierung von Templates.

Problematisch ist eine erhebliche Vermischung von

* Abschnitten, welche abhängig von den Instanziierungs-Parametern stets
  **unterschiedlichen** Maschinencode erzeugen, und

* Abschnitten, die stets **ein und denselben** Maschinencode erzeugen.

---
template: withinfo
graphic: ReducingCodeBloat
section: Intermediate Step
name: intermediate_step
header: ### Vorbereitender Zwischenschritt

Die Vorbereitung für die Reduzierung von Code-Bloat sieht wie folgt aus:

In einer Template-Klasse oder -Funktion sind möglichst große, zusammenhängende
Abschnitte zu schaffen,

* die Maschinencode erzeugen, der tatsächlich von den Instanziierungs-Parametern
  abhängt, und

* diese damit zu trennen von anderen, immer auf ein und denselben Maschinencode
  hinauslaufenden.

---
template: withinfo
graphic: ReducingCodeBloat
section: Optimised Template
name: optimised_template
header: ### Optimierte Template

Abschnitte einer Template, die auf ein und denselben Maschinencode hinauslaufen,
können ausgelagert werden, und zwar

* für eine Template-Klasse in eine **Nicht-Template** Basisklasse, und

* für eine Template-Funktion in eine **Nicht-Template** Hilfsfunktionen.

---
template: plain
name: perfect_forwarding
header: ## Perfect Forwarding with Templates

A special use case for templates is *Perfect Forwarding*, which basically is
about keeping the "Rvalue-ness" of a function argument until it is used.

It can be applied

* either in [cookbook style](#perfect_forwarding_cookbook) or

* with first explaining (and consequently trying to grasp) a lot of its
  [background](http://thbecker.net/articles/rvalue_references/section_01.html).

.N[
One key point with both approaches is to understand that the rvalue reference
declarator (`&&`) is special if used with a template argument.
]

Scott Meyers has even coined a special term for it: [Universal References]

[Universal References]: http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers

---
template: plain
name: perfect_forwarding_cookbook
header: ### Perfect Forwarding - Cookbook Style

Perfect forwarding is achieved by applying the following recipe:._[]
```
template<typename T1, typename T2>
void foo(T1 &&arg1, T2 &&arg2) {
    bar(std::forward<T1>(arg1));
    baz(std::forward<T2>(arg2));
};
```

.N[
If there are overloads of `bar` and `baz` optimized for lvalue and rvalue
arguments, the appropriate one will be called.
]

.F[:
Perfect forwarding always requires the use of templates, even if it is applied
to cope with the exponential explosion of overloads necessary if only arguments
of known types are to be forwarded, like here:
```
  // Assume objects of these classes can be arguments to foo, which it
class MyClass { … }; // it forwards to bar and baz and the caller may
class AnOther { … }; // either supply lvalues or rvalues as argument:
…
void foo(const MyClass  &arg1, const Another  &arg2) { … }
void foo(const MyClass  &arg1,       Another &&arg2) { … }
void foo(      MyClass &&arg1, const Another  &arg2) { … }
void foo(      MyClass &&arg1,       Another &&arg2) { … }
```
]

---
template: plain
name: perfect_forwarding_background
header: ### Perfect Forwarding - The Background

The background of perfect forwarding combines three essential pieces:

1. For a template argument `T&&` there is a special deduction of `T`:
   * `T` is *reference* for lvalue arguments,
   * otherwise it is the plain argument type
     (as usual with `&` and `const` stripped away).

1. Reference collapsing defines what happens if two reference declarators
   are applied in a row:
   * `&` and `&` → `&`
   * `&` and `&&` → `&`
   * `&&` and `&` → `&`
   * `&&` and `&&` → `&&`

1. `std::forward<T>(expr)` statically casts `expr` to `T&&`.

.I[
For more information on `std::forward` see:
http://en.cppreference.com/w/cpp/utility/forward
]

---
template: plain
name: compiletime_functions
header: ## Templates als Compilezeit-Funktionen

Eine weitere Sicht auf Templates ist es, sie als zur Compilezeit ausgeführte
Funktionen zu verstehen.

Der wesentliche Schlüssel dazu ist, das folgende zu verstehen:

* Jeglicher "Input" besteht aus Datentypen.._[]

* Jeglicher "Output" besteht aus Datentypen.

.N[
**Anders ausgedrückt:**
Templates sind (auch) Typ-Transformationen zur Compilezeit.
]

.F[:
Mit einem kleinen Kunstgriff fallen darunter auch sämtliche zur Compilezeit
konstanten Werte von Grundtypen, sowie daraus berechenbaren Werte.
]

---
template: plain
header: ### Wiederholung und Verzweigung

[FP]:      http://en.wikipedia.org/wiki/Functional_programming
[Haskell]: http://tryhaskell.org/ "hier ein interaktives Tutorial"

Allerdings gibt es kein Konstrukt für zur Compilezeit ausgeführte

* Schleifen (analog `while` zur Laufzeit) und

* Verzweigungen (analog `if` zur Laufzeit).

.N[
Verwendbar sind dagegen die entsprechenden Alternativen der *Funktionalen
Programmierung* ([FP]).
]

Es muss vielmehr

* Wiederholung durch **Rekursion** und

* Fallunterscheidung durch **Spezialisierung**

ausgedrückt werden.

Ein bisschen sollte man das vielleicht zunächst trainieren …._[]

.F[:
… was ganz gut mit einer Einführung in eine "echte" FP-Sprache wie etwa
[Haskell] geht.
]

---
template: plain
header: ### Fakultäts-Funktion als Beispiel

#### Der übliche Ansatz …

Die bekannte Funktion zur Fakultätsberechnung kann man in C++ mit einer
Schleife so programmieren:
```
unsigned long long fakul(unsigned long long n) {
    auto result = 1uLL;
    while (n > 0)
        result *= n--;
    return result;
}
```

Oder auch – zur Laufzeit rekursiv – so:
```
unsigned long long fakul(unsigned long long n) {
    return (n == 0) ? 1 : n*fakul(n-1);
}
```

---
template: plain
header: #### … und der im "Haskell-Stil"

```
unsigned long long fakul(unsigned long long n) {
    return n*fakul(n-1);
}
unsigned long long fakul(0uLL) {
    return 1;
}
```
Natürlich ist obiges **kein gültiges C++** … aber doch irgendwie
verständlich, oder nicht?

.N[
Die Idee ist, dass der Abbruch der gemäß der allgemeinen Funktion eigentlich
endlosen Rekursion durch die Spezialisierung von `fakul` für den Argumentwert
`0uLL` (0 im Typ `unsigned long long`) erfolgt.
]

---
template: plain
header: #### Berechnung mit C++-Template

Das folgende aber **ist** gültiges C++ …
```
// the primary template (internally recursive) ...
template<unsigned long long n>
struct fakul {
    static const unsigned long long result = n*fakul<n-1>::result;
};

// ... and its specialisation (stops recursion)
template<>
struct fakul<0uLL> {
    static const unsigned long long result = 1;
};
```
… und doch auch irgendwie "verständlich", oder?

Der "Aufruf" in einem kleinen Testprogramm könnte dann so aussehen:
```
#include <iostream>
int main() {
    std::cout << fakul<5>::result << std::endl;
}
```

---
template: plain
header: ### Beispiele für Typ-Transformationen

#### Eine Zeigerstufe hinzufügen
```
template<typename T> struct add_pointer { typedef T* result; };
```

#### Eine Zeigerstufe wegnehmen
```
template<typename T> struct remove_pointer;
template<typename T> struct remove_pointer<T*> { typedef T result; };
```
#### Alle Zeigerstufen wegnehmen

Denken Sie doch einfach mal selbst kurz nach …._[]

.F[:
The solution – of course – is this:
```
   // primary template
template<typename T> struct remove_all_ptr { typedef T result; };
// specialisation
template<typename T> struct remove_all_ptr<T*> { typedef remove_all_ptr<T> result; };
```
]

---
template: plain
header: ### Type-Traits Library

[Type-Traits]: http://www.boost.org/doc/libs/release/libs/type_traits/doc/html/boost_typetraits/background.html

With C++11 the [Type-Traits] originally developed as a Boost library became a
part if the standard.

.I[
For more information on standard type traits see:
http://www.cplusplus.com/reference/type_traits/
http://en.cppreference.com/w/cpp/types/
]

C++14 simplified the use of the standardised type traits with a number of
template aliases (instead of accessing `::type`` for traits returning types)
and convential conversion to `bool` (as `constexpr`) is implemented for traits
with a `static constexpr bool value`).

* For some type trait `xxx` accessed conventionally via `typename xxx<T>::type`,
  in C++14 just `xxx_t<T>` may be used.

* For some type trait `yyy` accessed conventionally via `yyy::value`, in C++14
  just `yyy{}` may be used.

---
template: plain
header: #### Using SFINAE with `std::enable_if`

Often, after doing type calculations, the final goal is to choose among several
implementations of a given function.

If this is not the automatic effect from calculating a type that selects the
appropriate overload, `std::enable_if` and [SFINAE] can be applied.

The basic idea is this:

* Create an overload set of (template) functions that is deliberately ambiguous.

* Make all but one instantiations of the functions in this set fail for a
  particular condition.

As compile time calculations must express every result as a type (last and finally),
`std::enable_if` creates an illegal type as "substitution failure" and the particular
instantiation is removed from the overload set.

[SFINAE]:http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error

---
template: plain
header: #### Example for SFINAE with `std::enable_if` (C++11)

The following example selects between two implementations of foo, depending on
whether the arguments `arg1` and `arg2` are objects related with each other as
base and derived class:
```
template<typename T1, typename T2>
typename std::enable_if<
    std::is_base_of<T1, T2>::value
>::type foo(T1 arg1, T2 arg2) { … } // called for
                                    // T1 is base class of T2

template<typename T1, typename T2>
typename std::enable_if<
    !std::is_base_of<T1, T2>::value
>::type foo(T1 arg1, T2 arg2) { … } // called for
                                    // T1 is NOT base class of T2
```

---
template: plain
header: #### Example for SFINAE with `std::enable_if_t` (C++14)

With the additions C++14 made to the standard type traits, the previous example
can be slightly simplified to:._[]
```
template<typename T1, typename T2>
std::enable_if_t<
    std::is_base_of<T1, T2>{}
> foo(T1 arg1, T2 arg2) { … } // called for T1 is base of T2

template<typename T1, typename T2>
typename std::enable_if_t<
    !std::is_base_of<T1, T2>{}
> foo(T1 arg1, T2 arg2) { … } // called for T1 is NOT base of T2
```

.F[:
Note that the support for this simplifications is close to trivial In `namespace std { … }`:
```
  template<bool C, typename T = void> using enable_if_t = typename std::enable_if<C, T>::type;
```
And:
```
  typename<T1, T2>
struct is_base_of {
   /* as in C++11, set according to result */ static constexpr bool value = …;
   /* added in C++14 */ constexpr explicit operator bool() const { return value; }
}
```
]

---
template: plain
name: variadic_templates
header: ## Variadic Templates

C++11 introduced [Parameter Packs] to allow templates to accept a variable
number of arguments.

--------------------------------------------------------------------

* [Defining Variadic Templates 		](#define_variadic_template)

* [Unpacking Parameter Packs		](#unpack_parameter_packs)

--------------------------------------------------------------------

Generally variable argument lists help

* to avoid much repetitive systematic coding and
* at the same time removes arbitrary upper limits.

.I[
For more information see on variadic templates see:
http://en.cppreference.com/w/cpp/language/parameter_pack
]

.F[:
The ellipsis was originally introduced with C to indicate variable length
argument list.
]

---
template: plain
name: define_variadic_template
header: ### Defining Variadic Templates

In the **definition** of template a symbolic name be introduced with three dots
appended.

In this syntax the identifier right to the dots introduces kind of a list,._[]
actually representing

* either sequences of type names

* or values of a specified type.

This can be used with [template classes](#variadic_template_class_example)
or [template functions](#variadic_template_function_example).


.F[:
Before C++11, to implement templates with a variable number of arguments
required repeated, similar code (though some libraries like [Boost.Preprocessor]
provided means to generate such using the C/C++ preprocessor):
```
   // defining a tuple class …
template<typename T1>
class tuple { T1 first; … };
template<typename T1, typename T2>
class tuple { T1 first; tuple<T2> rest; … };
template<typename T1, typename T2, typename T3>
class tuple { T1 first; tuple<T2, T3> rest; … };
template<typename T1, typename T2, typename T3, typename T4>
class tuple { T1 first; tuple<T2, T3, T4> rest; … };
… // etc. up to some upper limit
```
]

[Boost.Preprocessor]: http://www.boost.org/doc/libs/1_41_0/libs/preprocessor/doc/topics/motivation.html

---
template: plain
name: variadic_template_class_example
header: #### Example: Variadic Template Class

.pull-left[
```
// Definition:
template<typename... Ts>
class MyClass {
    …
};
…
// Valid Uses:
… MyClass<int, double> …
… MyClass<const char *> …
… MyClass<std::string, bool> …
… MyClass<int, int, int, int> …
```
]
.pull-right[
```
// Definition:
template<int... Ints>
class MyIntegers { … };
template<std::string... Words>
class MyStrings { … };
…
// Valid Uses:
… MyInts<2, 3, 5, 7, 11, 13> …
… MyStrings<> …
… MyStrings<
      std::string("hello"),
      std::string("world")> …
```
]

In a template class, if this mechanism is combined with other (fixed) template
arguments, the variable part must come last:
```
template<typename T1, unsigned int N, typename T2, bool... Bs>
class Whatever { … };
…
… Whatever<std::string, 7u, int, true, false, true, true, false> …
… Whatever<const volatile unsigned long&, (~0u >> 12), void> …
```

---
template: plain
name: variadic_template_function_example
header: #### Example: Variadic Template Function

The general syntax is similar to variadic template classes, but the type list
usually also occurs as part of the argument list:
```
template<typename... Ts>
std::string concat(char, Ts...); // prototype only, so far
```

In signature of `concat` state that the function is to be called with a first
(mandatory) argument of type `char` and any more arguments of arbitrary type,
hence – in principle – all of the following calls were correct:
```
… concat(' ', "hello", 7, "world" '!') …
… concat('+', std::string("whatever"), 2/1.0, true, false) …
```

---
template: plain
name: variadic_template_function_example
header: #### Implementing Variadic Templates

Implementing variable templates usually has two options:

* Internally forwarding to another variadic template.._[]
* Applying recursion at compile time.

.N[
For the latter the following has to be understood:

* Recursion is the (only) way to write "loops" at compile time, and
* there must be a "condition" to stop an otherwise endless recursion.
]

Furthermore:

.N[
Conditions at compile time are typically expressed

* as specialisation for some border case, or
* by selecting from an overload-set with [SFINAE].
]


[SFINAE]: http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error

.F[:
Of course, this only shifts "the burden of implementation" to the callee …
]

---
template: plain
name: unpack_parameter_packs
header: ### Unpacking Parameter Packs

The second use of the ellipsis is to unpack a parameter pack, by writing
it after some "pattern" containing at least one name of a variadic template
representing a parameter pack.

* If the name represents a type list, it may be used wherever type lists are
  acceptable, e.g. to instantiate some (other) variadic template.

* If the name represents a value list, it may be used to expand to parameter
  lists of a variadic function (template or classic) or as initialiser for
  data structures or be used as an `std::initializer_list`.

* If the name is the formal argument name representing an unpacked formal
  parameter list, the pattern will be expanded once for each parameter.

* Finally, several packs may be unpacked simultaneously.

.N[
Some practical examples (following) should help to clarify the above.
]

---
template: plain
header: #### Example: Compile Time Recursive Data Structure

[`std::tuple`]: http://de.cppreference.com/w/cpp/utility/tuple

The following class shows an approach how something like [`std::tuple`]
might be implemented with a variadic template:._[]
.pull-left[
```
template<typename T,
         typename... Ts>
struct MyTuple {
    T first;
    MyTuple<Ts...> rest;
    MyTuple(T f, Ts... r)
        : first(f), rest(r)
    {}
};
```
]
.pull-right[
The general case (left) …

… and its specialisation for the empty border case, required to stop endless
recursion (below):
```
template<>
struct MyTuple<> {
};
```
]

With this, `MyTuple` objects could be created as follows:
```
MyTuple<int, double, const char *> x(1, 0.5, "one by three");
MyTuple<std::string, const char *> y("one", "two");
MyTuple<> z;
```

.F[:
Note that this example is stripped down to its bare bones deliberately omits
the finer points that were important for useful and performant tuple class.
]

---
template: plain
header: #### Example: Compile Time Recursive Functions

The function `concat` was already introduced as example for a variadic template
function.._[]

```
// FIRST(!) the basic form that stops recursion:
std::string concat(char) {
    return {};
}

// THEN the recursive form (to unfold at compile time):
template<typename T, typename... Ts>
std::string concat(char sep, T, arg, Ts... args) {
   return arg.append(&sep, 1) + concat(sep, args...);
};
```
.W[
The definition of the basic version (stopping recursion) and the recursive
version must not be reversed – or the program will not compile any more.
]

.F[:
This example too is stripped down to its bare bones and deliberately omits
the finer points that would make sense for useful and performant implementation.
]

---
template: plain
header: #### Example: Stopping Recursion with SFINAE

Stopping recursion by using SFINAE is demonstrated in the following
implementation of a `get<N>` member function of class `MyTuple`:._[]
```
template<typename T, typename... Ts>
class MyTuple {
    …
    … // as shown on a previous page
    …
    template<std::size_t N>
    typename std::enable_if<N == 0, T>::type
    get() { return first; }

    template<std::size_t N>
    using Rtype = decltype(rest.template get<N-1>());

    template<std::size_t N>
    typename std::enable_if<N != 0, Rtype<N>>::type
    get() { return rest.template get<N-1>(); }
};
```

.F[:
Note that implementing `get<N>` as a member is like [Boost.Tuple] provides
member access, while [`std::tuple`] uses a non-member overload.
]

[Boost.Tuple]: http://www.boost.org/doc/libs/release/libs/tuple/doc/tuple_users_guide.html
[`std::tuple`]: http://en.cppreference.com/w/cpp/utility/tuple/get

---
template: plain
header: #### Simultaneous Unpacking of Parameter Packs

Two (or more) parameter packs may also be unpacked simultaneous, as shown in the
following example. It demonstrates how `std::make_unique` (missing from C++11._[])
may be implemented:
```
template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args)
{
    return std::unique_ptr<T>{new T(std::forward<Args>(args)...)};
           //                                   /^^^^  ^^^^\
           // simultaneously unpack argument types and names
}
```

The interesting part with respect to simultaneous unpacking is marked in the
comment.

.N[
The example also demonstrates how [perfect forwarding](#perfect_forwarding)
can be applied to whole argument lists with ease in a single statement
]

.F[:
Though a factory function for `std::unique_ptr` similar to `std::make_shared` for
`std::shared_ptr` makes sense, it was not defined in C++11, but only added in C++14.
]

---
template: plain
header: #### C++14 `std::integer_sequence` Template

As code implementing variadic templates needs to "unfold" at compile time,
C++14 provides the following compile time integer sequences:

* A template `std::integer_sequence` holding a sequence of arbitrary values of
  a given integral type.

* A template `std::index_sequence` as special form of the above where the
  integral type is `std::size_t`.

* A helper template `std::make_index_sequence` to generate a given number of
  consecutive values, starting from zero.

* A helper template `std::index_sequence_for` to generates an index sequence
  with the length of a given parameter pack.

.I[
For more information on the above including examples see:
http://en.cppreference.com/w/cpp/utility/integer_sequence
]

---
template: plain
name: advanced_preprocessor
header: ## Fortgeschrittene Nutzung des Präprozessors

--------------------------------------------------------------------

* [Der C++-Präprozessor beherrscht kein C++](#cpp_stringizing_args)

* [Verwendung von Makro-Argumenten als String-Literal (Stringizing)](#cpp_stringizing_args)

* [Verketten von Makro-Argumenten zu neuen Tokens (Token Pasting)](#cpp_token_pasting)

* [Systematische, tabellengesteuerte Quelltext-Erzeugung](#cpp_code_generation)

* [Allgemeine Stil-Hinweise und weitere Tipps](#cpp_coding_style)

--------------------------------------------------------------------

---
template: plain
header: ### Der Präprozessor kennt kein C(++)

Der Syntax des Präprozessors ist extrem einfach und erkennt nur:

* Kommentare sowie Zeichen- und Zeichenketten-Literale._[]

* Zeilenverkettung durch Abschluss einer Zeile mit Gegenschrägstrich

* Präprozessor-Direktiven in Zeilen beginnend mit einem Hash-Zeichen
  (White-Space direkt vor und hinter `#` optional möglich).

* Bezeichner, denen optional ein paar runder Klammern folgt, und innerhalb
  dieser Kommata (als Argumenttrenner) sowie weitere, paarige runde Klammern
  (welche die Wirkung enthaltener Kommata als Argumenttrenner aufheben).

.W[
Makro-Bezeichner liegen außerhalb der C++-Namespaces und ihr Ersatztext wird ohne
Beachtung des syntaktischen Kontexts als einfache Text-Substitution eingesetzt.
]

.F[:
Dies bedingt sich gegenseitig, denn sonst könnten z.B. Zeichen-Literale und
Kommentare keine Gänsefüßchen (`"`) und Zeichenketten-Literale keine
Kommentarbegrenzer (`/*`, `*/` und `//`) oder einfache Apostrophe (`'`)
enthalten.
]

---
template: plain
name: cpp_stringizing_args
header: ### Stringizing

Unter *Stringizing* wird die Möglichkeit verstanden, das Argument einer
Makro-Expansion als String-Literal zu verwenden:

* Es wird dann quasi automatisch in doppelte Gänsefüßchen eingeschlossen.
* Wenn nötig, werden für einzelne Zeichen Escape-Sequenzen ersetzt.

Als Beispiel ein Makro, der einen Ausdruck textlich und mit dem berechneten
Wert auf Standardausgabe schreibt:
```
#define PrintX(x) \
        std::cout << #x << ": " << (x) << '\n';
```

Die Anwendung kann (beispielsweise) wie folgt aussehen:
```
int main() {
    auto value = 42;
    PrintX(value++)
    PrintX(++value)
    PrintX(value)
    PrintX(value *= 2)
}
```

---
template: plain
name: cpp_token_pasting
header: ### Token Pasting

Hierunter versteht man das "Aneinanderkleben" von Makro-Argumenten und fest
vorgegebenen Bestandteilen, um daraus neue Bezeichner zu erzeugen:
```
#define DEFINE_ERROR_THROWER(clazz, name)\
    virtual void clazz::throw_ ## name() {throw clazz::name();}
…
DEFINE_ERROR_THROWER(MyParser, PrematureEndOfFile)
DEFINE_ERROR_THROWER(MyParser, InvalidExpression)
```

---
template: plain
name: cpp_code_generation
header: ### Systematische Quelltexterzeugung

#### "Tabelle" als Vorbereitung

Hierfür könnte z.B. eine Liste von Bezeichnern und Texten vorliegen, für die –
evtl. an ganz unterschiedlichen Stellen eines Programms – unterschiedlicher
Quelltext systematisch erzeugt werden soll:

```
#define FOR_ALL_ERRORS(m)\
    m(PrematureEndOfFile, "file ends prematurely")\
    m(IncompleteLine    , "line ends prematurely")\
    m(InvalidExpression , "bad expression syntax")\
    … // usw.
```

Die Grundlage dieser Technik besteht darin, den Namen eines zu expandierenden
Makros einem anderen Makro als Parameter zu übergeben. Dieser Makro könnte nun
mit den beiden auf der nächsten Seite gezeigten Makros aufgerufen werden:
.pull-left[
```
// somewhere ...
FOR_ALL_ERRORS(DEF_ERROR_CLASS)
```
]

.pull-right[
```
// ... somewhere else
FOR_ALL_ERRORS(DEF_THROW_HELPER)
```
]

---
template: plain
name: cpp_code_generation
header: #### Eigentliche Quelltexterzeugung

Die einzige Regel ist, dass die an `FOR_ALL_ERRORS` zu übergebenden Makros
genau zwei Argumente entgegennehmen müssen:
```
#define DEF_ERROR_CLASS(name, desc)\
    class name : public std::runtime_error {\
        public: name() : std::runtime_error(desc) {}\
    };
```
Diese müssen natürlich nicht zwingend im Ersatztext verwendet werden:
```
#define DEF_THROW_HELPER(name, desc)\
    virtual void throw_ ## name() { throw name(); }
```

Eine intensive, praktische Verwendung dieser Techniken zeigt das Beispiel:
[Examples/Utilities/TypePrinter/tp-final.cpp](../Examples/Utilities/TypePrinter/tp-final.cpp)

---
template: plain
name: cpp_coding_style
header: ### Einige weitere Präprozessor-Tipps

Generell sollten

* Makros zur systematischen Quelltext-Erzeugung einfach gehalten werden, und

* der Präprozessor nur dann für die systematische Code-Erzeugung genutzt werden,
  wenn es im Sinne der folgenden Ziele geschieht:

  * Signifikante Vereinfachungen
  * Höhere Fehlersicherheit
  * Verbesserte Wartbarkeit._[]

.N[
Es kann durchaus sinnvoll sein, im Ersatztext von *Helfer-Makros* wiederum
*Helfer-Funktionen* und/oder *Helfer-Templates* zu verwenden, insbesondere wenn
deren Argumentlisten systematische Ähnlichkeiten und Wiederholungen aufweisen.
]

.F[:
Z.B. weil absehbar ist, dass weitere, ähnlich gelagerte Fälle nach und nach zu
ergänzen sind und/oder künftig für alle bisherigen Fälle gemeinsame Anpassungen
erforderlich werden könnten.
]

---
template: plain
header: #### Fortsetzungszeilen fördern die Lesbarkeit

Dies wurde in den gezeigten Beispielen schon häufig praktiziert.

Ggf. kann zusätzlich auch erwogen werden,._[]

* den Gegenschrägstrich für die Fortsetzungszeilen immer in ein und dieselbe
  Spalte zu setzen,

* und das Ende der Makro-Definition durch einen Kommentar expliziter sichtbar
  zu machen.
```
#define DEF_ERROR_CLASS(name, desc)                 \
class name : public std::runtime_error {            \
      public: name() : std::runtime_error(desc) {}    \
};                                    // END-OF-MACRO
```

.F[:
Probieren Sie aber besser vorab aus, ob eine solche, auf gute Lesbarkeit
zielende Formatierung nicht schon beim nächsten Lauf eines "C++-Beautifiers"
wieder zerstört wird … und auch nicht durch die gutgemeinte "Einrückungshilfe"
des syntaxbewussten Editors Ihres Kollegen, der damit Ihre Quelltexte ab und
zu bearbeitet.
]


---
template: plain
header: #### Namenskonventionen für Makros

Da Makronamen nicht mit C++ Namespaces verbunden sind, sollte jedes Projekt
verbindliche Regeln aufstellen, welche Namen für Makros verwendet werden
dürfen.._[]

Diese könnten z.B. sein:

* Erstes Zeichen Großbuchstabe,
* gefolgt von zwei oder mehr weiteren Zeichen,
  * die Großbuchstaben, Ziffern oder Tiefstrich sein dürfen,
* Ende mit `_H` aber nur bei Makros, die Include-Guards steuern.

.N[
Die "Mindestens-drei-Zeichen"-Regel beugt Komplikationen vor, die andernfalls
durch die verbreitete Praxis entstehen könnten, für Typ-Parameter von Templates
`T` (oder `T1`, `T2`, `T3`, …) und für Wert-Parameter `N` (oder `MIN`, `MAX` …)
zu verwenden.
]

.F[:
Oftmals weniger bekannt ist auch, dass nicht nur der C89-Standard alle
Makronamen, welche mit einem Tiefstrich beginnen, für Zwecke der Implementierung
reserviert, sondern andere, evtl. in einem Projekt relevante Standards mitunter
deutlich weitergehende Regeln enthalten. So reserviert z.B. POSIX alle Makros
für interne Zwecke, deren Namen die mit `LC`, `E`, `SIG` oder `SIG_` beginnen,
sofern ein Großbuchstabe oder eine Ziffer folgt.
]

---
template: plain
header: #### Makros nur lokal definieren

Abschließend noch zwei weitere vorbeugende Maßnahmen gegen Überraschungen,
welche nicht beabsichtigten Ersetzungen des Präprozessors vermeiden helfen:

* Nur über kurze Quelltext-Abschnitte hinweg nötige Makros zur systematischen
  Erzeugung von Quelltext sollten ggf. direkt nach ihrer letzten Verwendung
  mit `#undef` wieder gelöscht werden.

* Ferner kann durch einen vorgeschalteten Test mit `#ifdef` das unbeabsichtigte
  Überschreiben eines (anderen) Makros verhindert werden, der eine weiter
  ausgedehnte Sichtbarkeit hat und diese auch gezielt haben soll.

Beides zeigt das Beispiel auf der nächsten Seite, welches die oft notwendige
Umwandlung von per `enum` definierten Bezeichnern in entsprechende (druckbare)
Zeichenketten demonstriert.._[]

.F[:
Dieses Beispiel verwendet noch zwei weitere, mit C++11 eingeführte Neuerungen,
nämlich die neue Syntax zur *Typ-Definition mit `using`* und *`enum` Klassen*.
Bei letzteren sind die einzelnen Bezeichner qualifiziert zu verwenden. Somit
zeigt sich zugleich eine Stärke der Quelltext-Erzeugung durch Makros: um wieder
auf die klassischen Aufzählungstypen (zurück) zu wechseln, müsste lediglich der
Makro `MAP_COLOUR_TO_STRING` angepasst werden, nicht aber dessen Verwendungen.
]

---
template: plain
header: ##### Beispiel für lokalen Makro

```
enum class Colour : unsigned char { Red, Blue, Green };
…
#ifdef MAP_COLOUR_TO_STRING
#error "macro 'MAP_COLOUR_TO_STRING' already defined"
#endif
std::string colour2string(Colour c) {
    switch (c) {
       #define MAP_COLOUR_TO_STRING(c)\
        case Colour::c: return "Colour::" #c;
           // ----------------------------
              MAP_COLOUR_TO_STRING(Red)
              MAP_COLOUR_TO_STRING(Blue)
              MAP_COLOUR_TO_STRING(Green)
           // add more colours to map here
           // ----------------------------
       #undef MAP_COLOUR_TO_STRING
        default: {
            using ULL = unsigned long long;
            return "Colour::#"
                 + std::to_string(static_cast<ULL>(c))
                 + " (not mapped to a name)"
        }
    }
}
```

---
layout: false
template: blank
name: part8

# [C++ FOR](#agenda) (Part 8) More on Exceptions and Resource-Management

-------------------------------------------------------------------------------

1. [Exception Guidelines			](#exception_guidelines)
1. [RAII zur Verwaltung von Ressourcen 		](#resource_management)
1. [Überblick zu Smart-Pointern 		](#smart_pointers)

-------------------------------------------------------------------------------

---
template: linkinfo
graphic: ExceptionDetails
name: exception_guidelines
header: ## Some Guidelines for Using Exceptions

-------------------------------------------------------------------------------

* [Disconnected Class Hierarchy		](#disconnected_class_hierarchy)

-------------------------------------------------------------------------------

* [Wrong order of `catch`-Blocks	](#wrong_catch_order)

-------------------------------------------------------------------------------

* [Problematic Re-Throwing		](#problematic_rethrow)

-------------------------------------------------------------------------------

* [No Exceptions from Destructors	](#dtor_exception_nogo)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: ExceptionDetails
section: (No) Disconnected Class Hierarchy
name: disconnected_class_hierarchy
header: ### Disconnected Class Hierarchy

For exceptions classes from a disconnected class hierarchy there is **no**
possibility for catching these exceptions in generic code:
```
int main() {
    using namespace std;
    try {
        …
        … // ordinary application
        …
        return EXIT_SUCCESS; // macro in <cstdlib>
    }
    catch (exception &e) {
        cerr << "terminated by standard exception: "
             << e.what() << endl;
    }
    catch (...) {
        cerr << "terminated by unknown exception" << endl;
    }
    return EXIT_FAILURE; // macro in <cstdlib>
}
```

---
template: withinfo
graphic: ExceptionDetails
section: (Bad) Order of Handlers
name: wrong_catch_order
header: ### (Falsche) Behandlungsblock-Abfolge

With a wrong order of `catch`-blocks

* an earlier, **more general** block

* **hides a subsequent** (more specific) block.

---
template: withinfo
graphic: ExceptionDetails
section: Sub-optimal Re-throwing
name: problematic_rethrow
header: ### Problematic Re-Throwing

Rethrowing an exception is sub-optimal if the original thrown object needs to be
copied.

Furthermore, in case of a derived exception object, this will cause slicing.

.N.center[
**In most any case slicing is not what makes sense.**
]

Hence copying should be avoided:

* Exceptions in a `catch`-block should be specified as reference.

* If a `catch`-block recovers from an exception only partial, it should throw
  the received object with `throw;`.

---
template: withinfo
graphic: ExceptionDetails
section: Optimal Re-Throwing
name: correct_rethrow
header: #### Optimal Re-Throwing

If the scheme shown below is applied, the originally received exeption object
will be re-thrown without making any copy (and hence also no slicing):
```
try {
    …
    … // code that may cause an exception
    …
}
catch (SomeException &ex) {
    …
    // only partial recovery
    throw;
}
```
.N[
A `throw`-Statement without argument following may not only be used in a
`catch`-block but also in a function that is directly or indirectly called
from such a block.._[]
]

.F[:
That way common code of several `catch`-blocks may be placed in a helper
function even if this function has a non-trivial flow of control and the
exception caught is not only re-thrown at the end.
]

---
template: plain
header: #### Compiler Optimisations

[RVO]: http://en.wikipedia.org/wiki/Return_value_optimization
[NRVO]: http://stupefydeveloper.blogspot.de/2008/10/c-rvo-and-nrvo.html

When entering a `catch`-block

```
catch (SomeException ex) …
```
and when leaving a `catch`-block
```
    throw ex;
```

would technically require to copy the exception object.

* Within the limits of the semantics specified by the C++ standard there
  are possible optimisations.

* This implies slicing and not executing private copy constructors …

* … but a copy constructor **need not** be actually executed.

.N[
Especially when am exception is thrown RVO is used as a typical optimisation.._[]
]

.F[:
Also [NRVO] might be considered but in practical cases this will be rare, as
typically exception objects are constructed in the `throw`-statement with a
constructor call.
]

---
template: withinfo
graphic: ExceptionDetails
section: (No) Throwing from Destructors
name: dtor_exception_nogo
header: ### No Exceptions from Desctructors

.W[
Exceptions thrown from destructors **will cause program termination** if the
destructor is run during stack-unwinding as part of an ongoing exception
handling.
]

Therefore, if a destructor needs to use operations that might throw, its body
should be wrapped in a `try`-block, catching all exceptions:._[]
```
class MyClass {
    …
    ~MyClass() {
        try {
            … // whatever needs be done
        }
        catch (...) {
            if (!std::uncaught_exception()) throw;
        }
    }
};
```
.F[:
The example shows how the caught exception might be re-thrown if the destructor
is **not** run as part of some exception handling.
]

---
template: plain
name: no_more_throwspec
header: ## c++98 `throw`-spezifications

Most guidelines from C++ experts recommend **not to use** `throw`-specifications
as introduced with C++98.

.N.center[
C++11 turned `throw`-specifications into a *deprecated language feature*.._[]
]

.F[:
This means they might be completely removed from the language, though experience
tells that compilers will still support deprecated features, maybe requiring special
`#pragmas` or command line options for backward compatibility.
]

---
template: plain
name: noexcept
header: ## C++11 `noexcept`-specification

The effect is as follows:

* If some function declared `noexcept` will directly or indirectly throw an
  exception, the **program will be terminated** – may be after some user defined
  handler code.

* Hence in **other** functions that **call** `noexcept` functions the compiler
  can omit any book-keeping code otherwise necessary for stack-unwinding.._[]

.F[:
In the callers context exceptions from "`noexcept`" functions may indeed stay
unconsidered … but **not** as there will be no exceptions but because the callee
will never return to the caller!
]

.N[
Currently there is little experience with respect to `noexcept` and how they
relate to code generation and overall program quality, so there are not (yet)
many guidelines when and when not to use `noexceptp`.
]

---
template: plain
name: noexcept
header: ### Conditional Freedom from Exceptions

Besides what was explained on the previous page `noexcept` is also a
compile-time function which especially in templates is useful to
**conditionally** freedom from exceptions.

* That way some function may express that exceptions will only occur if some
  (unknown) called function throws.

* This allows at compile-time to decide if some piece of code bears the risk
  to throw.

* Using techniques from meta-programming this allows library functions to chose
  a different (probably non-throwing, then) implementation to make itself safely
  made `nothrow`.

---
template: plain
name: noexcept
header: ### Examples for `noexcept`

Some easy calculation – exceptions are completely excluded:
```
float fahrenheit_to_centigrade(float temperature) noexcept {
    return 9.0*temperature/5.0 + 32.0;
}
```

Some vital functionality – no chance to revover, better crash completely:
```
extern void may_fail_catastrophically(int = 42) noexcept;
```

An exception from `bar` is only thrown it `T::foo` throws:._[]
```
template<class T>
void bar(const T &arg) noexcept(noexcept(arg.foo())) {
    … // an exception can neither occur here ...
    arg.foo();
    … // ... nor can an exception occur here
}
```
.F[:
The C++11-syntax is that ugly and requires nested `noexcept`-s.
]

---
template: linkinfo
graphic: ResourceManagement
name: resource_management
header: ## Ressourcen ohne und mit RAII

-------------------------------------------------------------------------------

* [Klassische APIs				](#classic_resource_api)

-------------------------------------------------------------------------------

* [Mit RAII verwaltete Ressourcen …		](#raii_style)
* [… für Ausführung einer Anweisungsfolge …	](#raii_codeblock)
* [… oder Lebensdauer eines Objekts belegen	](#raii_lifetime)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: ResourceManagement
section: Classic Resource Management APIs
name: classic_resource_api
header: ### Klassische APIs

Klassisches Ressource-Management beruht auf zwei getrennten Operationen:

* Belegen der Ressource (Acquire, Allocate, Open, …)

* Freigeben der Ressource (Release, Free, Close, …)

Bei beiden Operationen besteht das Problem, dass sie vergessen werden könnten,
bei der zweiten zusätzlich das Problem, dass sie zu früh stattfinden
könnte.._[]

.F[:
Zum falschen Zeitpunkt ausgeführte Operationen sind oft einer zu komplexen
Programmlogik anzulasten. Die vorwiegend genutzten und daher relativ gut
getesteten Ausführungspfade sind dann zwar ohne Probleme, Schwierigkeiten
treten aber bei selteneren Konstellationen auf, deren Vorgeschichte – zwecks
Nachvollziehung des Fehlers – zudem oft schwer reproduzierbar ist.
]

---
template: plain
header: #### Um welche Ressourcen geht es?

Grundsätzlich werden unter dem Begriff hier alle

* **"knappen" Betriebsmittel**

verstanden, über die ein Programm nicht beliebig während seiner gesamten
Ausführungszeit verfügen kann oder sollte:

Die folgende Liste ist nur beispielhaft zu sehen und keineswegs erschöpfend:

* Hauptspeicher

* Mutexe

* Dateien

* Prozesse

* Datenbank-Verbindungen

* …

---
template: plain
header: #### Wie werden Ressourcen repräsentiert?

In C/C++ gibt es zwei besonders häufig verwendete Abstraktionen, die eine
Ressource repräsentieren:

* **Zeiger** – eine Speicheradresse,

  * an der wesentliche Informationen zur Ressource stehen,
  * oftmals repräsentiert durch eine Struktur,
  * deren Inhalt im Detail aber nicht von Interesse ist.

* **Handles** – in der Regel eine Ganzzahl,

  * die einer Service-Schnittstelle zu übergeben ist,
  * der gegenüber sie die Ressource repräsentiert.._[]

.F[:
Mitunter – aber nicht grundsätzlich – sind Handles Indizes, mit welchen Einträge
einer hinter der Service-Schnittstelle angesiedelten Tabelle ausgewählt werden.
]

---
template: withinfo
graphic: ResourceManagement
section: Wrapped Resource
name: raii_style
header: ### Mit RAII verwaltete Ressourcen

[RAII]: http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization

Bei [RAII] handelt es sich um die Abkürzung der von Bjarne Stroustrup
empfohlenen Technik, klassische Ressourcen zu verpacken:

.N.center[
**R**essource **A**cquisition **I**s **I**nitialisation
]

In der Regel ist dafür eine – meist sehr einfache – Hilfsklasse erforderlich,
welche

* die Ressource-Anforderung im Konstruktor und

* die Ressource-Freigabe im Destruktor

vornimmt.

---
template: withinfo
graphic: ResourceManagement
section: Acquire Resource for Code Segment
name: raii_codeblock
header: ### RAII-Ressource für Anweisungsfolge belegen

Da in C++ überall neue (geschachtelte) Blöcke beginnen können, lässt sich die
Anweisungssequenz, während der die Ressource belegt ist, nach Belieben
festlegen.

* Eine Variable vom Typ des Ressource-Wrappers wird an der Stelle eines
  Code-Blocks (als Stack-Objekt) angelegt, ab dem die Ressource benötigt wird.

* Der Destruktor des Ressource-Wrappers wird automatisch ausgeführt, wenn der
  betreffende Code-Block verlassen wird.

.N[
Durch die automatische Ausführung des Destruktors wird die Ressource in jedem
Fall zuverlässig freigegeben.
]

Insbesondere spielt es keine Rolle, wie und warum der Kontrollfluss den
betreffenden Code-Block verlässt, also egal ob

* nach Ausführung der letzen Anweisung …
* … durch vorzeitiges `return`, `break`, `continue` …
* …  oder `throw` – auch wenn indirekt in einer aufgerufenen Funktion.

---
template: withinfo
graphic: ResourceManagement
section: Acquire Resource for Object Lifetime
name: raii_lifetime
header: ### RAII-Ressource für Objekt-Lebensspanne belegen

Objekte die (per Komposition) als Teil anderer Objekte existieren, werden

* während der Erzeugung des umfassenden Objekts automatisch mit angelegt und

* während dessen Zerstörung automatisch mit zerstört.

Damit kann ein Ressource-Wrapper die Belegungsdauer einer Ressource zuverlässig an
die Lebensspanne eines bestimmten (anderen) Objekts binden.

---
template: plain
header: #### Explizite Anforderung mehrerer Ressourcen ohne RAII

Fordert eine Klasse in ihrem Konstruktor mehr als eine Ressource explizit an –
**ohne Verwendung von RAII** -, besteht nur bei einer besonders sorgfältigen
Vorgehensweise Sicherheit vor Ressource-Leaks.

##### Beispiel-Code für Klasse – kein RAII

```
class Choice {
    …
    Window *w;   // optional, if needed allocated on heap with new
    MenuItem *m; // acually an array, allocated on heap with new[]
public:
    Choice( … );
    ~Choice();
    …
};
```
Offensichtlich benötigt die Klasse `Choice` zwei Sorten von Ressourcen:

* ein `Window` (optional, also Multiplizität 0..1);
* eine mehr oder weniger große Zahl von `MenuItem`-s (Multiplizität 1..*).

---
template: plain
header: ##### Beispiel-Code `Choice`-Konstruktor – kein RAII

Zunächst werden beide Zeiger sicher initialisiert, dann werden die Ressourcen
angefordert:
```
Choice::Choice( … )
    : w(nullptr), m(nullptr) {
    try {
        w = new Window( … );
        m = new MenuItem[…];
    }
    catch( … ) {
        delete w;   // delete is nullptr-safe, so no problem if
        delete[] m; // either of first or second new above threw
        throw;
    }
};
```

.W[
Bevor der Konstruktor (fehlerfrei) beendet wurde, ist der Destruktor noch nicht
aktiv – evtl. auftretende Probleme müssen daher in einem lokalen `catch`-Block
behandelt werden.
]

---
template: plain
header: ##### Beispiel-Code `Choice`-Destruktor – kein RAII

Nach erfolgreichem Durchlaufen des Konstruktors wird der Destruktor aktiviert.

Dieser muss dann so aussehen:
```
Choice::~Choice() {
    delete w;    // matching kind of new easy to verify
    delete[] m;  // by quick comparison with c'tor code
}
```

.W[
Genau diese beiden Anweisungen waren schon einmal nötig – im `catch`-Block
des Konstruktors. Es liegt eine unschöne Duplizierung von Code vor (Verletzung
des DRY-Principles).
]

---
template: plain
header: #### Anforderung mehrerer Ressourcen mit RAII

Hierbei wandert die Operation zur Freigabe in den Wrapper der betreffenden
Ressource:
```
class WindowRes {
    Window *res;
public:
    WindowRes( … ) : res(new Window( … )) {}
    ~WindowRes()  { … ; delete res; … }
    operator Window*() { return res; }
};
```

```
class MenuItemRes {
    MenuItem *res;
public:
    MenuItemRes( … ) : res(new MenuItem[…]) {}
    ~MenuItemRes() { … ; delete[] res; … }
    MenuItem &operator[](int i) { return res[i]; }
};
```

---
template: plain
header: ##### Beispiel-Code Vereinfachung `Choice`-Klasse – mit RAI

```
class Choice {
    …
    WindowRes wr;
    MenuItemResr mr;
public:
    Choice( … ) : WindowRes( … ), MenuItemRes( … ) {
        … // in case something special is necessary,
          // but NO try-catch required to handle
          // problems with ressource allocation
    }
    ~Choice() {
        … // in case something special is necessary
        // but NO d'tor required to return ressources
    }
    …
};
```

* Der Destruktor ist nicht mehr für die Ressourcen zuständig – diese werden
  eigenständig von ihrem jeweiligen Wrapper verwaltet.

* Er kann ganz entfallen, wenn ansonsten keine Aufräumungsarbeiten notwendig sind.

---
template: linkinfo
graphic: SmartPointers
name: smart_pointers
header: ## Smart-Pointer

-------------------------------------------------------------------------------

* [Smart-Pointer von C++11._[] im Vergleich	](#unique_vs_shared)

-------------------------------------------------------------------------------

* [Prinzip der Referenzzählung			](#refcount_principle)

-------------------------------------------------------------------------------

* [Problem der zyklischen Referenzierung	](#refcount_problem)
* [Lediglich "beobachtende" Zeiger als Lösung	](#weak_ptr_solution)
* ["Verlorene" Ressourcen			](#weak_ptr_dangling)

-------------------------------------------------------------------------------

* [Typische Smart-Pointer Implementierungen	](#implementing_smart_ptrs)

.F[:
Berücksichtigt sind hier nur die Smart-Pointer von C++11, da mit diesem Standard
zugleich der mit C++98 eingeführte `std::auto_ptr` abgekündigt wurde.
]

---
template: withinfo
graphic: SmartPointers
section: Comparing Smart Pointers
name: unique_vs_shared
header: ### Smart-Pointer von C++11 im Vergleich

[Smart-Pointer]: http://en.cppreference.com/w/cpp/memory
[Boost.Smart_ptr]: http://www.boost.org/doc/libs/release/libs/smart_ptr/smart_ptr.htm

Die von C++11 bereitgestellten [Smart-Pointer] repräsentieren (im Wesentlichen
dem Vorbild von [Boost.Smart_ptr] folgend) die wichtigsten Beziehungen, die ein
Zeiger zu einem anderen – i.d.R. aber nicht zwingend auf dem Heap angelegten –
Objekt ausdrücken kann:

* Exklusive Eigentümerschaft: `std::unique_ptr`

* Geteilte Eigentümerschaft: `std::shared_ptr`

* Beobachter ohne Eigentümerschaft: `std::weak_ptr`

.N[
Den mit C++98 eingeführten `std::auto_ptr` gibt es weiterhin, langfristig und
für neue Programme empfiehlt C++11 an dessen Stelle aber die Verwendung von
`std::unique_ptr`.._[]
]

.F[:
Substituting an `std::auto_ptr` with an `std::unique_ptr` should cause no major
pains. If problems occur they often rather indicate sleeping bugs caused by the
special semantics of an `std::auto_ptr`, that now will only become more obvious.
]

---
template: plain
header: #### Exklusive Eigentümerschaft: `std::unique_ptr`

Die Verwendung dieser Art von Smart-Pointer hilft, die exklusive
Eigentümerschaft für das referenzierte Objekt sicherzustellen:

.N[

* Es gibt einen *Move-Konstruktor*

* aber **keinen** *Copy-Konstruktor*.

-------------------------------------

* Es gibt ein *Move-Assignment*

* aber **kein** *Copy-Assignment*.
]

---
template: plain
header: #### Geteilte Eigentümerschaft: `std::shared_ptr`

Die Verwendung dieser Art von Smart-Pointer hilft, bei geteilter
Eigentümerschaft die Beseitigung referenzierter Objekte sicherzustellen.

Intern verendet die übliche Implementierung zwei Zeiger:._[]

  * Einer zeigt auf das referenzierte Objekt,
  * der andere auf ein Hilfsobjekt mit einem Referenzzähler.

Von der `std::shared_ptr`-Klasse wird in letzterem durch

* Default-Konstruktor,
* Copy- und Move-Konstruktor,
* Copy- und Move-Assignment
* sowie Destruktor

die Anzahl der Referenzierer eingetragen bzw. aktualisiert.

.N[
Fällt der Referenzzähler auf 0, wird der Destruktor des referenzierten
Objekts ausgeführt und dessen Speicherplatz freigegeben.
]

.F[:
Eine alternative Implementierung benötigt nur einen Zeiger bei schlechterer
Laufzeit-Performance.
]

---
template: withinfo
graphic: SmartPointers
section: Problem of Cyclic References
name: refcount_problem
header: ### Problem der zyklischen Referenzierung

Mitunter kann es notwendig werden, dass

* ein Objekt, auf das per `std::shared_ptr` verwiesen wird,

* selbst wiederum einen `std::shared_ptr` enthält, der direkt oder indirekt._[]
  auf Objekte der eigenen Art zeigt.

.W[
Dies vorausgesetzt, kann es zyklische Ketten von Referenzen geben, die einen
isolierten, unerreichbar gewordenen Verbund von Objekten im Speicher darstellen,
dessen Teile nur noch untereinander über `std::shared_ptr` verbunden sind.
]

.F[:
Die Kernproblematik besteht also nicht nur, wenn ein `std::shared_ptr` **exakt**
auf die Art von Objekten zeigt, die ihn enthalten. Auch bei der Konstellation
*"A zeigt auf B und B auf A"* oder *"A zeigt auf B, B zeigt auf C und C zeigt
auf A"* kann das beschriebene Problem auftreten.
]

---
template: withinfo
graphic: SmartPointers
section: Breaking Cycles Using Weak Pointers
name: weak_ptr_solution
header: #### Nutzer ohne Eigentümerschaft: `std::weak_ptr`

Mittels `std::weak_ptr` lassen sich zyklische Referenzen vermeiden.

Bei einem Design unter Einbeziehung von `std::weak_ptr` ist hinsichtlich
der Referenzierer eines Objekts zu prüfen, ob es sich

* um (echte) Ressource-Eigentümer handelt

* oder lediglich um Ressource-Beobachter.._[]

.W[
Letztere müssen damit rechnen, dass sie die beobachtete Ressource "verlieren".
]

Das geschieht genau dann, wenn es für die beobachtete Ressource keine
wirklichen Eigentümer mehr gibt sondern nur noch Beobachter.

.F[:
In der typischen Implementierung des `std::shared_ptr` enthält ein zweiter
Zähler im Hilfsobjekt die Summe der Anzahl von Eigentümern und Beobachtern.
Fällt diese auf 0, kann auch der Speicherplatz für das Hilfsobjekt freigegeben
werden.
]

---
template: withinfo
graphic: SmartPointers
section: Dangling Weak Pointer
name: weak_ptr_dangling
header: #### "Verlorene" Ressourcen

Da die `std::weak_ptr` die beobachtete Ressource verlieren können, unterstützen
sie keinen direkten Zugriff darauf mit `*` oder `->`.

.N[
Zunächst ist aus dem `std::weak_ptr` ein `std::shared_ptr` zu erstellen.._[]
]

Analog zum `dynamic_cast` werden zwei Vorgehensweisen unterstützt:

* Erste Vorgehensweise:

  * Initialisieren eines `std::shared_ptr` und nachfolgender Test;
  * ergibt dieser, dass der Zeiger auf kein Objekt gültiges Objekt zeigt,
    existiert das beobachtete Objekt nicht mehr.

* Zweite Vorgehensweise:

  * Rückgabe eines ohne Prüfung benutzbaren `std::shared_ptr`;
  * wenn das ursprünglich beobachtete Objekt nicht mehr existiert, wird
    stattdessen eine Exception geworfen.

.F[:
Genau dieser `std::shared_ptr` ist es dann, der das referenzierte Objekt ggf.
am Leben hält, auch wenn die anderen Eigentümer nun verschwinden sollten.
]

---
template: withinfo
graphic: SmartPointers
section: Implementation Choices
name: implementing_smart_ptrs
header: ### Typische Smart-Pointer Implementierungen

#### `std::shared_ptr` – meist verwendete Variante

Hierbei enthält ein `std::shared_ptr` (mindestens._[]) **zwei Zeiger**, von
denen einer auf das referenzierte Objekt und der andere auf ein Helfer-Objekt
zeigt.

.F[:
Wenn ein `std::shared_ptr` über einen Basisklassen-Zeiger auf eine virtuelle
Basis-Klasse eines Objekts zeigt, das von dieser Klasse abgeleitet ist, kann
zum effizienten Zugriff auf das referenzierte Objekt noch ein weiterer Zeiger
erforderlich werden.
]

Das Helfer-Objekt wiederum enthält **zwei Zähler**, von denen einer die
Eigentümer, der andere (typisch) beides, Eigentümer *plus* Beobachter.

Damit entscheidet der

* erste Zähler darüber, wann das **referenzierte Objekt** und

* der zweite Zähler darüber, wann das **Hilfsobjekt**

freigegeben wird.

---
template: withinfo
graphic: SmartPointers
section: Implementation Choices
name: alternative_shared_ptr
header: #### `std::shared_ptr` – alternative Implementierung

In einer alternativen Implementierung enthält ein `std::shared_ptr` nur
**einen** Zeiger auf ein Helfer-Objekt, das neben den Referenzzählern nun
auch einen Zeiger auf das referenzierte Objekt enthält.

#### `std::weak_ptr` – typische Implementierung

Die Implementierung entspricht im Wesentlichen dem der `std::shared_ptr`, also

* zwei Zweiger – auf referenziertes Objekt und Helfer-Objekt, **oder**
* ein Zeiger – auf Helfer-Objekt und von dort weiter zum referenzierten Objekt.

#### `std::unique_ptr` – typische Implementierung

Solange die Implementierung keinen *Stateful Custom Deleter* unterstützt reicht
**ein** klassischer Zeiger – sonst sind u.U. **zwei** Zeiger erforderlich.._[]

.F[:
But then advanced meta-programming techniques can help to save that second
pointer for any `std::unique_ptr` that **makes no use** of a custom deleter or
when the one used **is not stateful**.
]
---
layout: false
template: blank
name: part9

# [C++ FOR](#agenda) (Part 9) "Good C++ Software" - The Big Picture

-------------------------------------------------------------------------------

1. [Pragmatische Leitgedanken zur Software-Entwicklung	](#guiding_principles)
1. [C++ als "Multi-Paradigmen"-Sprache			](#multi_paradigm_cpp)
1. [Design-Patterns – kritisch hinterfragt		](#design_patterns)
1. [Zusammenfassung und Epilog				](#epilogue)

-------------------------------------------------------------------------------

---
template: linkinfo
graphic: GuidingPrinciples
name: guiding_principles
header: ## Pragmatische Leitgedanken zur Software-Entwicklung

-------------------------------------------------------------------------------

* ["Open-Close"-Principle		](#oc_principle)

-------------------------------------------------------------------------------

* [Don't Repeat Yourself	](#dry_principle)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: GuidingPrinciples
section: OC Principle
name: oc_principle
header: ### "Open Close"-Prinziple

Gemäß diesem Prinzip sollte jede Software-Architektur einen gesunden Ausgleich
zwischen zwei gegeneinander stehende Zielen gewährleisten:

* Software sollte *offen* für Veränderungen sein, beispielsweise

  * Anpassung an künftig geänderten Bedarf,
  * absehbare, anstehende Erweiterungen und
  * Verwendung in ähnlich gelagerten Fällen.

* Software sollte aber auch *robust* sein in dem Sinne, dass

  * Änderungen nicht versehentlich oder in ansonsten unbeabsichtigter
    Weise erfolgen;
  * zumindest sollten unbeabsichtigte Änderungen leicht zu identifizieren sein;
  * ebenso solche Änderungen, die zielgerichtet im Rahmen der Offenheit erfolgen
    aber aus irgend einem Grund unvollständig geblieben sind.

---
template: plain
header: #### Mechanismen zur Strukturierung

##### Klassen

Klassen fassen "Daten" und "Verarbeitung" zusammen und sind somit ein
Mechanismus zur Kapselung, der den Blick auf die abstrakten Operationen lenkt,
weg von Datenstrukturen und Algorithmen.

##### Unterprogramme

Unterprogramme teilen Verarbeitungsschritte auf, vom komplexen Gesamtablauf bis
hinunter zu kleinen, einfach zu überschauenden und gut testbaren Einheiten.

##### Bibliotheken

Bibliotheken sind Sammlungen wiederverwendbarer Komponenten, die für sich
betrachtet kein "Eigenleben" führen sondern erst "von außen" zum Leben erweckt
werden.

---
template: plain
header: #### Mechanismen zur Strukturierung (2)

##### Frameworks

Frameworks folgen dem *"Hollywood-Principle"*: Don't call us, we call you.

Sie stellen eine oft eine relativ komplexe Gesamtfunktionalität zur Verfügung
und enthalten *Erweiterungspunkte*, an denen individuelle Anpassungen erfolgen
können.

##### Geplante Erweiterbarkeit

**JA** – aber auch: *"Keep It Small and Simple!"*

Beginnen Sie also stets mit der **einfachsten Variante**

* einer Klasse,
* eines Algorithmus,
* einer Applikation,
* eines Programmsystems,
* …

welche Ihr Problem (gerade so) löst, und erweitern Sie diese ggf. inkrementell
gemäß neu erkanntem Bedarf.

---
template: withinfo
graphic: GuidingPrinciples
section: DRY Principle
name: dry_principle
header: ### Don't Repeat Yourself

[Turing-Tests]: http://de.wikipedia.org/wiki/Turing-Test

Eine wichtige Erkenntnis zur erfolgreichen Arbeitsteilung zwischen *"Mensch und
Computer"* ist:

**Menschen**

* besitzen oft ein hohes Maß an Kreativität,
* sind aber in aller Regel schlecht darin, Dinge präzise zu wiederholen,
  * sei es in immer wieder ein- und derselben Weise,
  * oder auch mit kleinen, systematischen Variationen.

**Computer**

* besitzen kaum echte Kreativität,._[]
* sind aber extrem gut darin, Dinge präzise zu wiederholen:
  * Insbesondere ermüden sie nicht bei ständig wiederholten und
  * dabei allenfalls leicht variierenden Tätigkeiten.

.F[:
Es ist dabei nebensächlich, dass per Computer gelegentlich "überraschende
Ergebnisse" erzielt werden können – etwa in der Art, dass ein Computer ein
Musikstück komponieren könnte, welches es vielleicht sogar in die Hitparade
schafft. Interessanter ist die Frage nach einem Programm, mit welchem ein
Computer im Dialog mit einem menschlichen Partner von diesem nicht schon
sehr bald als Maschine enttarnt wird, wie es im Fall der [Turing-Tests]
letzten Endes doch immer wieder geschieht.
]

---
template: plain
header: #### Mechanismen zur Wiederverwendung

##### Klassen

Relativ allgemein und universell gehaltene Klassen bilden in der Regel die
kleinsten wiederverwendbaren Bausteine im Rahmen der objektorientierten
Vorgehensweise.

##### Unterprogramme

In einem eher klassischen, prozeduralen Entwurf dominieren Unterprogramme,
mitunter ergänzt durch zugehörige Datenstrukturen.

##### Datenstrukturen

Mit Hilfe der C++ Templates lassen sich sehr gut wiederverwendbare Bausteine für
Datenstrukturen realisieren.._[]

.F[:
OK … technisch gesehen sind die STL-Container natürlich Klassen, allerdings
geht es dabei vor allem um Typ-Generizität in Bezug auf häufig erforderliche
Datenstrukturen.
]

---
template: plain
name: multi_paradigm_cpp
header: ## C++ as Multi-Paradigm Language

Commonly C++ is viewed as **Object Oriented Programming** Language.

This is correct, but only part of the truth, because C++ also._[]

* is a classical **Procedural Programming** Language,
* in which nearly all of **C is contained as Sub-Set**,
* thereby allowing to get **optionally close to the Hardware** …
* … with many compilers allowing to actually **mix in Assembler Code**,
* on the other hand supports **Generic Programming**
* and **Meta-Programming** via **Templates**,
* C++11 even adopted elements of **Functional Programming**,
* and sometimes its **Preprocessor** comes in handy as last resort.

.N[
**This is both, good and bad at the same time:**
While it allows to chose the paradigm most appropriate to solve a given problem,
(not only) novices may easily make a bad choice and end up much worse as if
there had been not so many options.
]

.F[:
For a nice reading – musing and amusing at the same time – lookup
[Execution in the Kingdom of Nouns] by Steve Yegge.
]

  [Execution in the Kingdom of Nouns]: http://steve-yegge.blogspot.de/2006/03/execution-in-kingdom-of-nouns.html

---
template: plain
header: ### Choosing the Right Paradigm

There is no easy answer but what you can do is:

* Gather Experience!

* Allow yourself to fail – but be sure to learn the lesson.

* Apply corrections as soon as things start to run in the wrong direction.

.N.center[
In mission critical projects consider to hire a C++ expert for coaching.
]

And: Do not blame the C++ language for "insufficient support" of a certain style
you know and like from a different programming language, which you personally
happen to favour.._[]

.F[:
If you are a team leader, place all your team's discussions about the "right"
programming language and C++ "deficiencies" early within your time frame. Maybe
there is actually a better choice as C++, if for the whole project, take it!
Otherwise C++ may not be appropriate or best for parts of the project. Consider
to give those members who are precious for any reason but strongly opposed to
C++ their own corner, where they can work with what they like most, be it C#,
Java or Scala, Haskell, Lisp …
But at a point **declare all discussions closed** and have your team members
commit themselves to C++ … from which they still can and should chose the
appropriate mix of paradigms, of course.
]

---
template: plain
header: ### How to Recognize that Things Start to Go Wrong?

See the first section of this chapter for the favourable deeper
[guiding principles](#guiding_principles) of any software development.

If you observe increasing failure to reach these goals, you might have chosen

* **the wrong** (combination of) **C++ paradigm**(s) or

* C++ is an inadequate programming language._[]

for the problem at hand.

.F[:
In C++ the former is far more probable, though – of course – the latter is not
impossible, especially if the general team knowledge or commitment is not C++
centric.
]

---
template: plain
name: design_patterns
header: ## Design Patterns – Critically Reviewed

To begin with:

.N.center[
Design patterns are a good thing, really!
]

Having said that, be sure to understand the following:

* Each design pattern has a purpose – understand which it is!

* Each design pattern has a context – make sure the context of the problem you
  want to solve matches.

.N.center[
Do not slavishly apply patterns just because "patterns are good".
]

---
template: plain
header: ### The GoF Book

  [GoF-Book]: http://c2.com/cgi/wiki?DesignPatternsBook
  [Erich Gamma]: http://c2.com/cgi/wiki?ErichGamma
  [Richard Helm]: http://c2.com/cgi/wiki?RichardHelm
  [Ralph Johnson]: http://c2.com/cgi/wiki?RalphJohnson
  [John Vlissides]: http://c2.com/cgi/wiki?JohnVlissides

Design patterns became famous in the second half of the 1990s through the
[GoF-Book].._[]

While this book surely filled a gap that had already been open far too long at
that time, it should not be overestimated:

* At the time the GoF book was published many C++ compilers already supported
  templates. But templates were not in that widespread use as later, after they
  became part of the C++98 standard.

* Therefore most any abstraction in the GoF book is via base classes and virtual
  member functions (aka. late binding, dynamic polymorphism, etc.) – with
  consequences detailed on the next pages.

* The authors even remind to that fact in their book's introductory chapter
  (pg. 21/22 in the 1994 edition), but some of the more slavish GoF followers
  seem to have skipped reading that part.

.F[:
*GoF* is the abbreviation for *"Gang of Four"* and honours the fact that, while
**four authors** contributed, those who referred to the book often were too lazy
to remember (or enumerate) all authors. Here they are: [Erich Gamma],
[Richard Helm], [Ralph Johnson], and [John Vlissides].
]

---
template: plain
header: #### Design Patterns and the GoF Book – A Personal Opinion

It seems, design patterns generally and the GoF book in particular can be
understood in two different ways:

1. **Train the Brain** to recognize recurring structures in software projects
   and know what to do about them, i.e.
   * to which degree the pattern makes sense in a given context,
   * when it might be especially appropriate,
   * when not, where are its limits, pitfalls,
   * what are the alternatives,
   * how some pattern relates to other patterns, …

2. **Implement the pattern in a specific way**:._[]
   * No doubt, the implementation style shown and discussed is best practice in
     *SmallTalk*.
   * It may also be appropriate for *Java* (therefore *Scala* too), *C#*, …
     maybe *Python* … *Objective-C++* …
   * … but it needs to be taken with the proverbial "grain of salt" for C++,
     mostly because of [multi-paradigm nature](#multi_paradigm_cpp) of that
     language.

.F[:
Or what I call *GoF book style* on the pages following – and what is the
particular target of my criticism.
]

---
template: plain
header: #### Shortcomings of the GoF Book Implementations

The implementation style for the patterns discussed in the GoF-Book tends to
shift type-safety from compile-time to run-time.._[]

.N[
If you happen to be a GoF book fan and think the word "shortcoming" sounds
depreciating, feel free to replace it by something more neutral.
]

* **There is a – sometimes small, sometimes big – gain:**

  * It may help to substantially reduce the modules to recompile in a large
    software system after a tiny or even moderate change.

* **There is a – sometimes big, sometimes small – loss:**

  * Problems reaching from slightly flawed designs to subtle or even quite
    obvious implementation errors may only show when the software runs, not
    yet when it is compiled.

.F[:
In all fairness and not to lift the burden to give better error messages for
problems when compiling C++ templates, chose from the following two scenarios:
**1.** You sit for hours and are close to desperation because of an error
message the compiler throws at you for a template and you will probably have
to call your boss now, telling her the major release planned for tomorrow will
be delayed.
**2.** You come in in the morning and everybody is already impatiently waiting
for you because production came to a grinding halt two hours ago … and all you
have to start with is a core dump of some software you wrote.
]

---
template: plain
header: ### Design Patterns and OOP-Languages

Because of the GoF book prevalence in the design patterns world, some of its
proponents measure the "quality" of a programming language by the degree to
which it supports dynamic polymorphism and introspection – both no absolute
strengths of C++.

* The GoF book – though it seems to relate to C++ as all of its examples are in
  C++ and only some few are in SmallTalk too – still has a strong connection to
  the world of SmallTalk.

* The market share of SmallTalk was already declining in the mid 1990s, mostly
  caused by the rise of Java and later C#.

In the years following, in their spirit – not syntax – Java and C# advanced to
get much closer to SmallTalk as C++ ever tried.._[]

.N[
Considering design patterns only in GoF book style, while dropping C++-Templates
mostly or completely, makes C++ surely look inferior.
]

.F[:
There is a famous quote of Bjarne Stroustrup, who – when asked about SmallTalk
and whether C++ should be extended in this direction too – had answered:
*SmallTalk is the best SmallTalk that exists.*
]

---
template: plain
header: ### DP-Examples

In the following a small subset of classical design patterns is discussed with
respect to how they relate to the multi-paradigm nature of C++.

.N[
A complete and detailed discussion is far beyond this presentation –
there are other courses with more in-depth coverage of the topic.
]

The DP examples following have **not** been selected because they are

* the ones "most typically" or
* "most frequently" used,

nor do they represent

* particularly "good" or
* particularly "bad" examples

for design patterns in C++.

---
template: plain
header: #### DP-Example: Iterator

Using Iterators to run through sequences is long-standing practice.

There are two main advantages:

* Type-Safety and
* Abstraction.

.N[
While it is often worthwhile to consider implementing iterators as nested
helper class for new kinds of containers, there is very little reason in C++
doing this in GoF book style.
]

When implementing new container types, determine the appropriate iterator
category (i.e. input or output, uni- or bidirectional, …) and adhere to the
category's specific requirements.._[]

.I[
Then – and **only then** – the new container type is immediately ready for
using it with all appropriate STL algorithms.
]

.F[:
[Boost.Iterator] may help to avoid some of the more schematic work.
]

  [Boost.Iterator]: http://www.boost.org/doc/libs/release/libs/iterator/doc/index.html

---
template: plain
header: #### DP-Example: Observer

  [Boost.Function]: http://www.boost.org/doc/libs/release/doc/html/function.html
  [Boost.Signals]: http://www.boost.org/doc/libs/release/doc/html/signals.html
  [Boost.Signals2]: http://www.boost.org/doc/libs/release/doc/html/signals2.html

At its core the observer pattern is about decoupling a number of otherwise
independent components or sub-systems so that each one doesn't have to know too
many details of the other one.

For dynamic control over coupling._[] an implementation may simply use C++11
`std::function` (or [Boost.Function] in C++98) as STL container element and a
tiny loop (approx. two lines of code) for message dispatch.

A ready-to-use library approach taking this road is available with

* [Boost.Signals] and
* [Boost.Signals2],

though it supports some extras – like flexible result collectors – hampering
performance in a direct comparison to more light-weight approaches without
such features.

* See https://testbit.eu/cpp11-signal-system-performance

.F[:
Sensibly decoupling components with static connections to each other is more or
less a developer's "every day job" (if she understands the requirements of good
software engineering); if that were subsumed under the observer pattern, any
non-trivial software would be full of observers …
]

---
template: plain
header: #### DP-Example: Composite

  [Boost.Variant]: http://www.boost.org/doc/libs/release/doc/html/variant.html
  [Boost.Property_Tree]: http://www.boost.org/doc/libs/release/doc/html/property_tree.html

The composite in GoF book style ties together its various leaf types with a
common base class – including a collection that enables recursive nesting.

.N[
This puts restrictions on the types that can be used – or at least requires
wrappers for unrelated classes, so they can have a common parent.
]

[Boost.Variant] offers an elegant alternative:

* It can easily tie together any unrelated basic types and classes,
* (therefore commonly used library classes like `std::string` too),
* and even callable code via `std::function`.

For recursive nesting any STL container may be added, e.g. an `std::map`

* holding the variant as its value part,
* keyed with an `std::string` for access.._[]

(A ready-to-use library solution to consider, especially for composites
holding persistent state or configuration data, is [Boost.Property_Tree].)

.F[:
In other words: more or less mimicking the core of Python's object model. For
some example code (rather meant as proof of concept but to be used as is) see
[Examples/DynamicVariant/dv-poc.cpp](../Examples/DynamicVariant/dv-poc.cpp)
]

---
template: plain
header: #### DP-Example: Template-Method

From the general perspective the design pattern called *Template-Method* is
an ideal example for the [Open-Close Principle](#oc_principle).

.W[
Be careful not to confuse the name given to this pattern with C++-Templates –
the similarity is purely accidental.._[]
]

.F[:
It may be even assumed that Erich Gamma and his three co-authors may have chosen
a different name if C++-Templates had already been in widespread use at the time
they worked on their manuscript.
]

What especially may contribute to confusion is that one of the two typical
implementations actually makes use of C++-Templates.

---
template: linkinfo
graphic: Example-OpenClosePrinciple
header: #### DP Template-Methode Implementation Alternatives

-------------------------------------------------------------------------------

* [Based on Dynamic Polymorphism	](#oc_with_polymorphism)

-------------------------------------------------------------------------------

* [Based on C++-Templates		](#oc_with_cpp_templates)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: Example-OpenClosePrinciple
section: Virtual Member Functions
name: oc_with_polymorphism
header: ##### DP Template Method Pattern Based on virtual Member Functions

[GoF Template Method Pattern]: http://en.wikipedia.org/wiki/Template_method_pattern

In the classical implementation._[] of the [GoF Template Method Pattern]

* virtual member functions of a base class are

  * pre-planned *Extension Points*,

* at which specific derived classes

  * attach a different functionality, as required.

With respect to the [Open-Close-Principle](#oc_principle) the base class is in
the role of the closed part and the various derived classes contribute the open
part.

.W[
A certain drawback of this technique is that any unused extension point will
remain in the executable code as (indirect) call to an empty subroutine.
]

.F[:
See [Examples/OpenClose/virtual_functions.cpp](../Examples/OpenClose/virtual_functions.cpp)
]

---
template: withinfo
graphic: Example-OpenClosePrinciple
section: C++ Template Mechanism
name: oc_with_cpp_templates
header: ##### DP Template Method Pattern Based on C++-Templates

When implemented with C++-Templates._[]

* the derived class is

  * a generic class with pre-planned *Extension Points*, expected as member
    functions in a base class

* specified only later through a type parameter,

  * therefore attaching different functionality through instantiation with
    different base classes.

With respect to the [Open-Close-Principle](#oc_principle) the derived class is
in the role of the closed part and the various base classes contribute the open
part.

.I[
As all calls are resolved at compile time, unused extension points will result
in no code at all, if unused extensions are (formally) implemented as empty
`inline` member functions.
]

.F[:
See
[Examples/OpenClose/template_baseclass.cpp](../Examples/OpenClose/template_baseclass.cpp)
]

---
template: plain
header: #### DP-Example: State

  [Quantum Framework]: http://www.state-machine.com/psicc/PSiCC_excerpts.pdf
  [Boost.Fsm]: http://www.boost.org/doc/libs/current/libs/statechart/doc/index.html
  [Boost.Msm]: http://www.boost.org/doc/libs/release/libs/msm/doc/HTML/index.html

There are many ways to implement state machines, e.g.

* in "pure C" with nested `switch`-statements (outer for states and inner for
  events or vice versa) as the most straight-forward approach,

* as a more readable and better maintainable "pure C" alternative with tables
  of function pointers,

* with the suggested GoF book style being only one of many other alternatives
  and variants.._[]

.N[
In his book about the [Quantum Framework] Miro Samek discusses in great depth
various possible implementations of state machines in C and C++, also pointing
out chances to improve and enhance the GoF book style by using C++-Templates.
]

.F[:
Of special interest for C++ developers may also be [Boost.Fsm] and [Boost.Msm],
which both implement state machines applying C++ meta programming techniques.
The architecture of the latter even allows to chose among several *front-ends*
(i.e. *DSL-s* to specify the states and transitions) and *back-ends* (i.e.
drivers to execute the machine according to incoming events). The default
front-end uses a tabular layout similar to the one achievable with a pure C
approach using tables of function pointers.
]

---
template: plain
header: #### DP-Example: Singleton

The singleton pattern seems easy to understand and apply, but (or maybe because
of that) is also the one most often misused or at least used as a much too heavy
weight approach to just solve the problem at hand.

In C/C++ `static` local variables provide a compact alternative:._[]
```
MySingleton &getMySingletonInstance() {
   static MySingleton instance;
   return instance;
}
```
The above and some variations are available as a small series of examples in
[Examples/Singleton](../Examples/Singleton).

.N[
In his book [Modern C++ Design] Andrei Alexandrescu spends a full chapter on the
singleton. Some obvious and some not so obvious problems with the pattern
are addressed and possible solutions shown.
]

  [Modern C++ Design]: http://erdani.com/index.php/books/modern-c-design/

.F[:
Despite this simple and elegant alternative exists in C++ (and even in C, if
the reference is replaced with a pointer), full-blown GoF book style singletons
are not unusual, even in scenarios where a plain "good ol' global" (variable)
would have sufficed.
]

---
template: plain
header: ### Design Patterns – Closing Remark

To end with:

**Design patterns are a good thing, really …**

* … when used for the intended purpose …

* … within the appropriate context …

* … implemented in "the C++ way" …

**… but probably not so**

* as vastly over-engineered solution to a trivial problem,

* if some ready-to-use library solution is thrown overboard because it doesn't
  follow (seemingly) "best practice" of the GoF book style, or

* if pointing to the latter is used as an argument to radically limit the
  freedom to chose from the set of paradigms C++ supports.

---
template: plain
name: epilogue
header: ## Summary and Epilogue

* Don't repeat yourself.

* Keep software "open" where you expect future modifications …

* … but make it "close" where inadvertent changes could break it.

* Start with the simplest possible solution – don't over-engineer.

* Build on reusable parts, do not invent the wheel over and over again.

* Follow best practices, but be aware of the context in which they apply.

* And don't repeat yourself (oops).

.N.center[
&#9786; Have fun with C++ &#9786;
]

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>
