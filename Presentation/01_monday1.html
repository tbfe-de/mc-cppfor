<!DOCTYPE html>
<html>
  <head>
    <title>(1) C++-For - Monday Part 1</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
    <!-- when changing the stylesheet file please see also remark below -->
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies approximately 2/3 of the page width. So only add
  little information, preferably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open – add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++ FOR]: 00_content.html#agenda

# [C++ FOR] (Monday Morning)

---------------------------------------------------------------------------

1. [Refreshing some C++ Basics			](#cpp_basics)
1. [Built-in and Standard Types			](#standard_types)
1. [Pointers and references			](#ptr_and_ref_types)
1. [Variable and Object Initialisation		](#var_and_object_init)
1. [Constructors and Destructors		](#ctors_and_dtors)
1. [Static Polymorphism				](#static_polymorphism)
1. [Type Compatibility and Conversions		](#type_conversions)

---------------------------------------------------------------------------

Together with the following chapter this constitutes roughly what is planned to
cover on Monday. Depending on the depth of coverage all these topics may even
require more time than one day. This is especially the case if both is desired,
refreshing traditional C++ knowledge **and** learning about what is new in
C++11 and C++14.


---
template: plain
name: cpp_basics
header: ## Refreshing some C++ Basics

--------------------------------------------------------------------------

* [Separate Compilation			](#separate_compilation)
* [Definition/Reference Model		](#definition_reference)
* [Compile Time Write Protection	](#const_protection)

--------------------------------------------------------------------------

Some topics covered here were not part of C++98 but introduced with C++11.

.I[
If you have good knowledge of C++98 it may still make sense to give the
following pages a cursory look and examine features introduced with C++11.
]

---
template: plain
name: separate_compilation
header: ### Separate Compilation

#### Basics of Separate Compilation

[Build-System]: http://en.wikipedia.org/wiki/Build_automation
[Unix `make`]:  http://en.wikipedia.org/wiki/Make_(software)
[Bell Labs]:    http://en.wikipedia.org/wiki/Bell_Labs
[GNU make]:     http://en.wikipedia.org/wiki/GNU_build_system
[CMake]:        http://en.wikipedia.org/wiki/CMake

[Translation Unit]: http://en.cppreference.com/w/cpp/language/translation_phases
[Header-Files]: http://www.cplusplus.com/forum/articles/10627/

Any C++-Program consists of one or more [Compilation Unit]s.

* Typically such are stored in an implementation file with the suffix `.cpp`.

* Information that needs to be available in more than one *Implementation File*
  usually goes in a *Header File* with the suffix `.h` (or sometimes `.hpp`).

.I[
Even if the number of translation units is small, the dependencies between
implementation files and header files is hard to resolve. Therefore using a
[Build System] is state of the art.._[]
]

.F[:
Build systems like the ones use today still often have their roots in the build
system developed 1976 at [Bell Labs] by Stuart Feldman, at least with respect to
their core syntax in which dependencies are specified in a `Makefile` (like is
done in [Gnu make] or [CMake].
]

---
template: plain
header: #### Dependencies between Header Files

Frequently also a header files depends on some included header file, e.g.

* if a header file **makes use** of a data type (class) or function,

* which is **declared** (with or without its definition) in a different header.

.N[
If this is the case the dependent header usually includes the other header.
]
.pull-left[
```
// header file: Base.h
class Base {
    …
};
```
]
.pull-right[
```
// header file: Derived.h
#include "Base.h"
class Derived : public Base {
    …
};
```
]

---
template: plain
header: #### Include Guards

[Include-Guard]: http://gcc.gnu.org/onlinedocs/cppinternals/Guard-Macros.html
[One Definition Rule (ODR)]: http://en.cppreference.com/w/cpp/language/definition

That way a single header might be included several times into the same
translation unit and because **multiple processing**._[] needs to be avoided
[Include Guards] are used.

.pull-left[
```
// header file: Base.h
#ifndef BASE_H
#define BASE_H
class Base {
    …
};
#endif
```
]
.pull-right[
```
// header file: Derived.h
#ifndef DERIVED_H
#define DERIVED_H
#include "Base.h"
class Derived : public Base {
    …
};
#endif
```
]

.F[:
The main reason why Include Guards are necessary is the
[One Definition Rule (ODR)] which limits the repeated introduction
of identifiers to some special cases (like completely identical
`typedefs` or function declarations with identical prototypes).
]

---
template: plain
header: #### Namespaces

As the next example shows, the name of a class alone as include guard (maybe
translated to uppercase) might create a problem:

.pull-left[
```
#ifndef SOMECLASS_H
#define SOMECLASS_H
namespace Mine {
    class SomeClass {
        …
    };
}
#endif
```
]

.pull-right[
```
#ifndef SOMECLASS_H
#define SOMECLASS_H
namespace Other {
    class SomeClass {
        …
    };
}
#endif
```
]

If now both files are includes, the first shadows the content of the second …
though it may cause the developer a hard time to detect that.

.W[
Include Guards names after classes should – somehow – also carry the namespace
name in their own name, e.g. `MINE_SOMECLASS_H` und `OTHER_SOMECLASS_H`.._[]
]

.F[:
It may also be questioned if the include guard is translated to upper case. To
avoid macro collisions some other convention like "only macros used for include
guards may end in `_H` is sufficient.
]

---
template: plain
header: #### Cyclic Dependencies

Another hard problem might be the error message which is created despite of (or
because of?) include guards used in this example:

.pull-left[
```
// file: someclass.h
#ifndef SOMECLASS_H
#define SOMECLASS_H
#include "OtherClass.h"
…
class SomeClass {
    …
    OtherClass *link;
};
#endif
```
]

.pull-right[
```
// file: otherclass.h
#ifndef OTHERCLASS_H
#define OTHERCLASS_H
#include "SomeClass.h"
…
class OtherClass {
    …
    SomeClass *link;
};
#endif
```
]

.F[:
This examples exist as compilable code in:
[Examples/Cyclic/Broken](../Examples/Cyclic/Broken) and
[Examples/Cyclic/Fixed](../Examples/Cyclic/Fixed) (corrected).
]

---
template: plain
name: definition_reference
header: ### Definition Reference Model

For each variable used in a program there must be **exactly one** definition
(with – potentially many – declarations associated with the definition by the
linker).

* When referred from a different translation unit an `extern`-declaration
  must be visible.
* The actual definition **may** include the word `extern`, even if it is
  combined with an initialisation.
* It even **needs to**._[] if there is also a `const` qualifier and no other
  `extern` declaration of that variable visible.

.W[
Using `const` for globals **reduces** visibility to the current translation
unit.
]

---
template: plain
name: const_protection
header: ### Write Protection by the Compiler (`const`)

A `const`-qualified identifier may not change its value throughout its life
time. Initialisation is mandatory if `external` is not also present.

```
const int x = 42;              // initialisation present
extern const unsigned VERSION; // reference only
```

The following will not compile:

```
++x;
```
Or also:
```
if (VERSION = 3014u) {
    // special case for version 3.14
    …
}
```

.F[:
Depending on the type and storage class of the variable and the hardware a
`const`-qualified variable may also be stored physically write-protected.
]

---
template: plain
name: standard_types
header: ## Built-in and Standard Types

--------------------------------------------------------------------------

* [Basic Integral Types			](#integral_types)
* [Integral Type Standard Aliases	](#int_type_std_aliases)
* [Floating Point Types			](#floating_point_types)
* [`void`, `bool`, and `enum`		](#void_bool_enum)
* [Querying Type Properties		](#type_properties)

--------------------------------------------------------------------------

---
template: plain
name: integral_types
header: ### Basic Integral Types

Built-in to C++ – i.e. available as reserved word without including any
header file – are the following integral standard types:

* `char` / `signed char` / `unsigned char` / `wchar_t` / `char16_t` / `char32_t`
* `short` (same as `signed short`) / `unsigned short`
* `int` (same as `signed int`) / `unsigned int`
* `long` (same as `signed long`) / `unsigned long`
* `long long` (same as `signed long long`) / `unsigned long long`

.N[
Each of the above type names constitutes a type on its own.
]

Overloading may be based on these types – i.e. they are distinguishable – even
if one has identical properties (signed-ness, limits, …) as another one.

.I[
For more information on basic integral types (incl. character types) see
subsections *[Character Types]* and *[Properties]* in:
http://en.cppreference.com/w/cpp/language/types
]
[Character Types]: http://en.cppreference.com/w/cpp/language/types#Character_types
[Properties]: http://en.cppreference.com/w/cpp/language/types#Properties

.F[:
E.g. by definition `char` has the same properties as either `signed char` or
`unsigned char` (implementation defined). Also type `int` often has the same
properties as either `short` or `long`.
]

---
template: plain
name: int_type_std_aliases
header: ### Integral Type Standard Aliases

Header file [`<cstdint>`] centralises type definitions (aliases) of frequently
required integral types with a specific number of bits.

[`<cstdint>`]: http://en.cppreference.com/w/cpp/header/cstdint

#### Standard Aliases for Exact Width

These use name patterns like `int8_t`, `uint8_t`, `int16_t`, `uint16_t` …
`uint64_t` and these will only be defined if there is hardware support for
**exactly** that number of bits.

#### Standard Aliases for Minimal Size

These use name patterns like `int_least8_t` … `uint_least64_t` and guarantee the
**smallest** integral type with at least that number of bits.

#### Standard Aliases for Fast Access

These use name patterns like `int_fast8_t` … `uint_fast64_t` and guarantee the
**fastest** integral type with at least that number of bits.

---
template: plain
name: int_type_std_aliases
header: ### Floating Point Types

The three different type names `float`, `double` and `long double` are available
for floating point.

* Often – especially if there is specific hardware support on the target platform
  – these will be mapped to the ISO754 types with 32, 64, and 80 bits.

* But the standard imposes no such requirement.

* In fact, a conforming implementation might even map all three types to the same
  hardware representation with only minimal requirements to range and accuracy.

.I[
For more information on floating point types see subsections
*[Floating Point Types]* and table *[Range of Values]* in:
http://en.cppreference.com/w/cpp/language/types
]

[Floating Point Types]: http://en.cppreference.com/w/cpp/language/types#Floating_point_types
[Range of Values]: http://en.cppreference.com/w/cpp/language/types#Range_of_values

---
template: plain
name: void_bool_enum
header: ### `void`, `bool`, and `enum`

These types serve different purposes which will be outlined in more detail on
the following pages.

* [`void`](#details_on_void)  
  Denotes a type **with no valid values** and is used as result type of
  functions that return no results (i.e. classic subroutines).._[]

* [`bool`](#details_on_bool)  
  Denotes a type with the only two values `true` and `false`.

* [`enum`](#details_on_classic_enum)  
  Denotes a type with a given set of values and was;

* [`enum class`](#details_on_enum_class)  
  Denotes a variant of `enum`-s with some more features, introduced with C++11.

.F[:
Note that `void *` has a different purpose, which is to define pointers with an
unspecified type, i.e. "just addresses". It is often used for a certain form of
"generic libraries", where mostly memory addresses are handed around, while
information about the types really stored at these locations is buried in the
program logic. An improved solution is [Boost.Any], which encapsulates the type
information with the pointer, making these sort of generic programming better
readable (and a bit more secure).
]

[Boost.Any]: http://www.boost.org/doc/libs/release/doc/html/any.html

---
template: plain
name: details_on_void
header: #### Not Existing Values: `void`

The typical use of `void` is as return type of functions returning nothing (via
their call name). Technically it is an [incomplete type], which means

* it cannot be part of (most sorts of) expressions,
* nor as type of function parameters,
* nor to define variables or class member data,
* …

What is acceptable is to call a function returning `void` as part of the
`return` statement of some other function:
```
void f() { … };
void g() { return f(); }
void h() { return g(); }
```

.F[:
One realistic use case for this is in templated code, where `h` forwards to
`g`, which may in turn forward to `f`, and it is expected all these functions
have the same return type. Then this alleviates the need to have specialisation
if the functions are generalised on their return type and this might be `void`:

```
   // a set of type generic functions forwarding from one to the other
template<typename T> T f() { … }
template<typename T> T g() { … ; return f(); }
template<typename T> T f() { … ; return g(); }
```
]

---
template: plain
name: details_on_bool
header: #### Truth Values: `bool`

Because of the traditional type conversions applied to variables and expressions of
type `bool`, it mixes seamlessly with all arithmetic types.

When using an expression in a context expecting a `bool`:

* any pointer other that `nullptr` converts to `true`;
* any arithmetic value other than zero converts to `true`;
* only zero and `nullptr` convert to `false`.

When using an expression of type `bool` in an arithmetic expression:

* the value `false` converts to `0` and
* the value `true` converts to `1` (in the specific type).

Note that type `bool` is usually represented **internally** as type larger than
only one bit, as otherwise memory access would be inefficient.

[`std::vector<bool>`]: http://en.cppreference.com/w/cpp/container/vector_bool
[`std::bitset`]: http://en.cppreference.com/w/cpp/utility/bitset

---
template: plain
header: #### Packed 0/1 Values

For dense "packing" of many 0/1-values, a classic array of `bool` is not
space efficient:
```
bool bits[100000000];  // 100 million 0/1 values
```

In this case an `std::bitset` offers a trade-off that may be worth to
consider:._[]
```
std::bitset<100000000> bits; // less space, more access time
```

.F[:
For packed bit collections of a size which can only be determined at compile
time, `std::vector<bool>` – a specialisation of `std::vector` – may be used.
As this has its own set of potential problems, a detailed discussion will be
postponed until later.
]

---
template: plain
name: details_on_classic_enum
header: #### Classic Enumerations

Classic enums (as C++ inherited from C) have the following shortcomings:

* The names of the values declared by the `enum` type (aka. enum labels)
  are **imported into the enclosing namespace**,_[]

  * thus introducing the risking inadvertent name clashes, which is
  * usually reduced by scoping `enum`-s in the body of some `class`

* The **underlying type cannot be controlled** …
  * … at least not easily and …
  * … not in an implementation-dependant way.

* There **cannot be a forward declaration**,
  * e.g. in case the enum label values are not used but only its type as
    argument to a function
  * eventually resulting in (needless) recompilations when enum labels
    are added or changed in value.

.F[:
Sometimes this specific property may not be a problem but an advantage.
]

---
template: plain
name: details_on_enum_class
header: #### C++11 Scoped Enumerations

With `enum class` C++11 resolved the problems of classic `enum`-s:._[]
```
enum class Color : unsigned short { Red, Green, Blue };
```

* The names of the labels are scoped:  
  `Color::Red`, `Color::Green`, `Color::Blue`.

* The type can be easily controlled:  
  `unsigned short` in this case (if not specified default is `int`).

* Forward declarations are possible:  
  `enum class Color : unsigned short;`

.I[
For more information see subsection *[Scoped enumerations]* in
http://en.cppreference.com/w/cpp/language/enum
]
[Scoped enumerations]: http://en.cppreference.com/w/cpp/language/enum#Scoped_enumerations

.F[:
Compared to enum classes in Java, C++ `enum class` is still poor on features!
]

---
template: plain
name: type_properties
header: ### Querying Type Properties

Header file [`<limits>`] defines specialisations of class
`std::numeric_limits`._[] for all arithmetic types (integral and floating) and
also `bool`, providing tests for many properties of these type.._[]

One typical use is to find the range of values representable in some type:
```
std::numeric_limits<short>::min()         // lowest short value
std::numeric_limits<short>::max()         // highest short value

std::numeric_limits<int>::min()           // same for int
std::numeric_limits<int>::max()           // etc.

std::numeric_limits<unsigned long>::min() // same for
…                                         // unsigned long etc.
```

.I[
For more information see:
http://en.cppreference.com/w/cpp/types/numeric_limits
]

.F[:
Besides `std::numeric_limits` this header also defines the classes
`std::float_round_style` and `std::float_denorm_style` specifying rounding and
de-normalisation modes of floating point types.
]

[`<limits>`]: http://en.cppreference.com/w/cpp/header/limits

---
template: plain
name: ptr_and_ref_types
header: ## Pointers and References

--------------------------------------------------------------------------

* [General and `const`-qualified Pointers	](#const_pointers)
* [Classic References (Lvalue References)	](#classic_references)
* [Comparison of Pointers and Reference		](#pointer_vs_reference)
* [Rvalue References (introduces with C++11)	](#rvalue_reference)

--------------------------------------------------------------------------

---
template: plain
name: const_pointers
header: ### General and `const`-qualified Pointers

```
int *p1;       // pointer and pointed-to memory are modifiable
p1 = …;        // OK
*p1 = …;       // OK (assuming p1 points to valid memory now)
```
For a pointer `const` my refer to **the pointer itself** …
```
int *const p3 = …; // must be initialized (with address of an int)
p3 = …;            // ERROR (would modify pointer itself)
*p3 = …;           // OK (modifies pointed-to memory location)
++*p3;             // OK (increments pointed-to memory location)
++p3;              // ERROR (would increment pointer itself!) 
```
… or the memory location **reachable via the pointer**:._[]
```
const int *p2; // same as: int const *p2;
p2 = …;        // pointer is still modifiable, but ...
*p2 = …;       // ... ERROR at compile-time!
```

.F[:
Of course, both kinds of `const`-qualification may be combined if it makes sense
for a given purpose, e.g. `const int *const p4 = …;` (or – switching positions
of the qualification and the type to which it is applied:
`int const *const p4 = …;`).
]

---
template: plain
name: classic_references
header: ### Classic References (Lvalue References)

The classic example is a function swapping the contents of two variables:

.pull-left[
```
void swap(int *p, int *q) {
    const int t = *p;
    *p = *q;
    *q = t;
}
…
int a, b;
…
if (a > b) swap(&a, &b);
…
```
]

.pull-right[
```
void swap(int &r, int &s) {
    const int t = r;
    r = s;
    s = t;
}
…
int a, b;
…
if (a > b) swap(a, b);
…
```
]

On the left pointers are used and addresses are handed over explicitly, on the
right arguments are defined as references, causing implicit dereferencing inside
`swap` and handing over addresses at the call site..[]

.F[:
So the difference is mostly notational (simplified source code with references),
while generated machine instructions are typically the same, though there is no
strict rule enforcing this. E.g. depending on compile time debug options
different safety checks could be generated for pointers and references.
]

---
template: plain
name: reference_initialisation
header: #### Initialising References

By concept references always denote existing memory locations,._[] therefore
they need to be initialised.

.N[
After its definition and initialisation a reference cannot be modified so that
it subsequently refers to a different memory location.
]

From that point of view references are like constant pointers, which may **not**
be modified themselves, though referenced memory can be read **and** written.

```
int v1, v2;  // some variables ...
int &r = v1; // rerefence is intialized
```

The following is **not** a compile-time error – only `r` now is an alias for
`v2` and writing to `r` actually modifies `v2`.
```
r = v2;  // copies current content of v2 to v1 (referenced by r)
```

.F[:
Not considering some artistic ways of initialisation to deliberately subvert
this property of a reference (like `T &r = *reinterpret_cast<T*>(0);`), an
invalid reference might be created by accident when a dereferenced pointer is
used to initialise a reference without prior checking: `T *p = 0; … T &r = *p`;
]

---
template: plain
name: const_reference
header: #### Constant References

A `const` qualifier for a reference always effects memory access via the
reference.

.N[
References which are `const`-qualified only allow reading memory, even if the
referenced memory (or variable) is writable.
]

In the following example the variable `v` may be modified directly and via `r1`,
but is read-only when accessed via `r2`:._[]

```
T v;
T &r1 = v;       // r1 now refers to content of v
const T &r2 = v; // r2 also refers to content of v
…
r1 = …; // OK (actually changes v)
r2 = …; // ERROR (at compile time)
```

.F[:
It should be obvious that in the light of references a value-tracking compiler
must be careful not to optimise-out *read* memory access with no intervening
*write*: the content of some location might still have been modified through a
different access path.
]

---
template: plain
name: const_correctness
header: #### Achieving the Const-Correctness

The C++ compiler catches constructs that may subvert const-correctness.

.pull-left[

```
const T cv = …;
const T &cr = cv; // OK
T &r = cv;        // ERROR
```
]

.pull-right[

```
const T cv = …;
const T *cp = &cv; // OK
T *p = &cv;        // ERROR
```
]

Aside from the notational there is **no substantial difference** between
pointers and references in the two examples above.._[]

.W[
If the above initialisation would compile, the non-modifiable variable `cv`
might be modified via a non-`const` reference (`r`) or a pointer to non-`const`
memory (`p`).
]

.F[:
GCC usually emits the same machine code for references and pointers, as long as
both are used correctly and semantically equivalent. (To try some examples
easily you may want to go to the following site: http://gcc.godbolt.org)
]

---
template: plain
name: const_ref_args
header: #### Reference Arguments

As reference initialisation occurs when handing arguments to functions, all the
peculiarities and special cases discussed so far will be mostly likely observed
there.

A typical lapse is to forget to add `const` to read-only reference arguments:
```
void foo(double &arg) {
    …
    … // all access to arg is non-modifying
    …
}
```

.pull-left[
Not callable with literal constant or `const`-qualified variable:
```
foo(0.0); // ERROR
double const PI = 3.14;
foo(PI);  // ERROR
```
]

.pull-right[
No temporaries are silently created:._[]
```
int x = 42;
foo(x);    // ERROR
foo(2*PI); // ERROR
```
]

.F[:
The reason is to avoid surprising effects that would occur especially if a
temporary were created for type coercion, and modifications were then applied to
the temporary only but not to the variable actually used as argument (though it
was "obviously" handed over by reference). 
]

---
template: plain
name: pointer_vs_reference
header: ### Comparing Pointers to References

References may be viewed in two ways:

* **Either** an alternative syntax for pointers, which

  * during initialisation expects an lvalue of which the address is taken
    (i.e. "`&`" is automatically and invisibly applied);

  * on each **use** implies the dereferencing operation on each use
    (i.e. "`*`" is automatically and invisibly applied).

* **Or** an alias name for an existing memory location with a matching type.

.N[
Taking inot account the invisibly applied operations to references, then there
are usually the same machine instructions generated for references as are for
pointers – the difference is in the syntax for initialisation and access.._[]
]

.F[:
Hint: When compiling with `g++` or `clang++` you may want to use the command
line option "`-S`" (upper case) and have look at the assembler code stored in a
file with suffix "`.s`" (lower case).
]

---
template: plain
name: rvalue_reference
header: ### Rvalue Referenes

[Rvalue References]: http://en.cppreference.com/w/cpp/language/reference

[Copy Constructor and Assignment]: #copy_ctor_assign
[Move Constructor and Assignment]: #move_ctor_assign

C++11 introduced [Rvalue References]. They may only be initialised by
expressions, i.e. memory locations introduced to hold temporaries with no other
access path.

Following are the most important rules:
```
T &r = …;          // … must be modifiable T in memory
const T &cr = …;   // … must be modifiable T in memory OR
                   //        non-modifiable T in memory OR
                   //        temporary T in memory (expression)
T &&rr = …;        // … must be temporary T in memory (expression)
```

.N[
The main use for rvalue references are to overload functions differently for
arguments denoting **either** existing **or** temporary objects, and again the
main use for this is to implement [Copy Constructor and Assignment] differently
from [Move Constructor and Assignment].
]

.F[:
As a function argument an rvalue reference is in most any case **not**
`const`-qualified, as the temporary reachable over it needs to be modified
(within the limits that the destructor needs still to work correctly). 
In contrary a classical reference typically **will** be `const` qualified if
introduced for improved performance of read-only accesses.
]

---
template: plain
name: var_and_object_init
header: ## Variable and Object Initialisation

--------------------------------------------------------------------------

* [Classic Initialisation Syntax	](#classic_initialisation)
* [C++11 Brace Initialisation		](#cpp11_brace_init)
* [C++11 Direct Member Initialisation	](#cpp11_member_init)
* [C++11 Compile Time Initialisation	](#cpp11_constexpr)

--------------------------------------------------------------------------

---
template: plain
name: classic_initialisation
header: ### Classic Initialisation Syntax

Until C++11 there were three different styles for initialisations:

* [Assignment-like Syntax](#assignment_like_init)
* [Constructor Call Syntax](#ctor_call_init)
* [C (inherited) Syntax for Aggregates](#aggregate_init)

There are also clearly defined rules what happens in case of:

* [Uninitialised Variables](#uninitialised_variables)
* [Uninitialised Objects](#uninitialised_objects)

---
template: plain
name: assignment_like_init
header: #### Assignment-like Initialisation

The assignment-like uses an equals sign to separate the name of the variable (or
object) initialised from the initialising expression.

```
int x = 42;
double pi = 3.14152;
std::string greet = "hello, world";
```

.N[
The difference to assignment is the type name on the left.._[]
]

.F[:
Since C++11 the type name can also be replaced with `auto`, which means that the
variable will have the type of the initialising expression, with reference (`&`),
`const` or `volatile` qualifiers stripped away.
]

---
template: plain
name: ctor_call_init
header: #### Constructor Call Syntax

Here the initialisation looks like calling a constructor, by following the
object with a comma-separated list of argument values, enclosed in parentheses:

```
std::string greet("hello");
std::string line(80, '-');
```

An exception from this rule is initialising with the default constructor.
In this case there are no parentheses following.
```
std::string empty;  // initialised with default (no content)
```

If (empty) parenthesis were used, this would be seen (like in C) as an `extern`
declaration of a function returning an `std::string`:._[]
```
std::string foo(); // NOT a default-initialised std::string !!
```

.F[:
If later that name were used with an `std::string` member function like
`foo.empty()` the compiler will typically complain that it is expecting a
function call operation.
]

---
template: plain
name: aggregate_init
header: #### C (inherited) Syntax for Aggregates

Here after the equals signed follow several comma separated values, enclosed in
braces. This can be used as well for arrays._[]
```
int primes[] = {2, 3, 5, 7, 11};
```

as for structures
```
struct Point { float x, y; };
…
Point origin = {0.0, 0.0};
```

or combinations:
```
Point polygon[] = {
    { 7.23, 12.1 },
    { 1, 3.5  },
    …
};
```

.F[:
If the size is omitted it will be determined from the number of initialising
values.
]

---
template: plain
name: uninitialised_variables
header: #### Uninitialised Variables (of Basic Types)

Variables of basic types must not be initialised. Their initial value depends on
the location of their definition:

Variables at a fixed address assigned at compile time, i.e.

* global variables,
* block-local `static` variables, and
* `static` class members

assume an initial value of

* `false` for booleans,
* `nullptr` for pointers, and
* zero (according to its type).

.W[
Variables on the stack and on the heap have undefined initial values, maybe even
"impossible" values for the given type on the given hardware.._[]
]

.F[:
The content is usually just the "bits and bytes" previously stored at that
memory location. On some hardware not all bit patterns are valid content for
floating point variables or pointers.
]

---
template: plain
name: uninitialised_objects
header: #### Uninitialised Objects

Strictly speaking, "uninitialised objects" do not exist, as any object is (at
least) initialised by the default constructor._[] of its class, but:

* If the default constructor is **automatically supplied** by the compiler, any
  data member of a built-in type receives the same initialisation as if it were
  not explicitly initialised.

* Same if a default constructor is **defined by the class itself** but forgoes
  to initialise some data members.

.N[
The rules described so far apply recursively, i.e. what happens exactly depends
on the type of the member: For basic types the rules from the previous page
apply, for (nested) objects the rules on this page.
]

.F[:
The term default constructor might be a bit misleading in some cases, because
it is easily confused with *"(a) constructor supplied by default"*. The latter
**may or may not** be the case for the default constructor, but the technical
meaning is this: *"the constructor that can be called without arguments"*.
]

---
template: plain
name: cpp11_brace_init
header: ### C++11 Brace Initialisation

Since C++11 braces are accepted in all initialising contexts shown so far (and
some more). The equals sign is made optional.._[]

.pull-left[
```
int x{42};
double pi{3.14152};
std::string greet{"hello"};
std::string line{80, '-'};
std::string empty{};
int primes[]{2, 3, 5, 7, 11};
Point origin{0.0, 0.0};
Point polygon[] {
    { 7.23, 12.1 },
    { 1, 3.5  },
    …
};
```
]
.pull-right[
```
int x = {42};
double pi = {3.14152};
std::string greet = {"hello"};
std::string line = {80, '-'};
std::string empty = {};
int primes[] = {2, 3, 5, 7, 11};
Point origin = {0.0, 0.0};
Point polygon[] = {
    { 7.23, 12.1 },
    { 1, 3.5  },
    …
};
```
]

.F[:
As no "C heritage" has to be taken into account the default constructor has an
explicitly empty argument list, and initialising values that cannot be
represented in the target type cause the compilation to fail, not just a
warning.
]

---
template: plain
name: cpp11_member_init
header: ### C++11 Direct Member Initialisation

Class members can now be initialised directly (with their definition).

* The values specified are considered to be the default if there is
  **no member initialisation** via

  * the member initialisation list of the constructor used to initialise an
    object, or
  * as direct assignment in the construct block.

* Supported initialisation syntax is

  * classic assignment style,
  * brace initialisation, but
  * **not constructor style with round parenthesis!**

.pull-left[
```
class Point {
    float x = 0.0;
    float y = 0.0;
    …
};
```
]
.pull-right[
```
class Point {
    float x{0.0};
    float y{0.0};
    …
};
```
]

---
template: plain
name: cpp11_constexpr
header: ### C++11: Compile-Time Initialisation (`constexpr`)

C++11 added the new keyword `constexpr` which may be applied to

* [data definitions](#constexpr_data) and
* [function definitions](#constexpr_data)

---
template: plain
name: constexpr_data
header: #### Compile-Time Initialised Data

By using `constexpr` with a data definition it is guaranteed that the variable
can be initialised at compile time.

* The compiler checks for the initialiser whether its value can be determined,
  because it is

  * a literal constant,
  * an expressions, or
  * result of `constexpr` functions

* allowing to use such values in any context that requires compile time
  constants, most importantly

  * array dimensions
  * value template arguments
  * or as part of expressions or function call arguments when initialising
    some other `constexpr` data item.

.N[
Compile time initialised data may also be stored in special ways, like in
statically read-only or dynamically write-protected memory.
]

---

template: plain
name: constexpr_functions
header: #### Compile-Time Callable Functions

By using `constexpr` with a function definition such function may (also) be
called at compile time.

* In C++11 this was rather restricted:._[]

  * `constexpr` were limited to a single return statement
  * though recursive calls were allowed, and
  * recursion could be stopped with a conditional expression.

* In C++14 this is much relaxed, but there are still limitations, e.g.:._[]

  * **no** `asm`, `goto`, or `try`-`catch`,
  * variables only of literal types and with initialisation,
  * no `static` or `thread_local` storage duration.

.N[
If a call to a `constexpr` function cannot be evaluated at compile time, a run
time version is made available and accordingly called where the value it returns
is needed.
]

.F[:
For more information see:
http://en.cppreference.com/w/cpp/language/constexpr
]

---
template: plain
name: ctors_and_dtors
header: ## Constructors and Destructors

--------------------------------------------------------------------------

* [General Purpose				](#ctor_dtor_generally)
* [(No) Memory Allocation in Constructors	](#ctor_no_memory_alloc)
* [Memory of Variable Size at Run-Time		](#runtime_sized_memory)
* [Compile Time vs. Run Time Sizing		](#ct_vs_rt_sizing)
* [(No) Memory De-Allocation in Destructors	](#dtor_no_memory_dealloc)
* [Precautions in Memory Allocating Classes	](#prc_memalloc_classes)
* [Exceptions in Constructors and Destructors	](#ctor_dtor_exceptions)
* [Re-Using Constructors			](#ctor_reuse)

--------------------------------------------------------------------------

---
template: plain
name: ctor_dtor_generally
header: ### General Purpose of Constructors and Destructors

Constructors and Destructors are one of the key additions of C++ over C.

Together they guarantee that

* initialisation will take place when an object comes into existence, and

* will be reliably reverted when an object ceases to exist.._[]

This is – of course – only true for objects with a scope-bound lifetime. In case
of local `static` object

* the initialisation will take place only once (when the scope is entered the
  first time, and

* reverted after the main program has ended.

.F[:
This easily extends to general resource allocation and deallocation, as is
purposefully applied in the [RAII-pattern].
]

[RAII-pattern]: http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization

---
template: plain
name: ctor_no_memory_alloc
header: ### (No) Memory Allocation in Constructors

A common misconception is that it is the constructor's responsibility to allocate
memory for objects of its class:

.pull-left[
Classic C++ initialisation:
```
class Point {
    float x;
    float y;
public:
    Point(float x_, float y_)
        : x(x_), y(y_)
    {}
};
```
]
.pull-right[
C++11 brace initialisation:
```
class Point {
    float x;
    float y;
public:
    Point(float x_, float y_)
        : x{x_}, y{y_}
    {}
};
```
]

In this case there is already memory allocated when the constructor is called to
initialise objects.
```
Point origin(0.0, 0.0);	  // classic initialisation
Point other{3.1, 7.12};   // C++11 brace initialisation
Point zzz = {1.7, 0.0};   // as before, with equals sign
```

---
template: plain
name: runtime_sized_memory
header: ### Memory of Variable Size at Run-Time

The reason for the misconception is that **some** classes (like `NamedPoint` below)
will get space allocated for two `float`-s and one pointer, but the space pointed
to by `name` is on the heap:
```
class NamedPoint {
    float x, y;
    char *name;
public:
    NamedPoint(const char * name_, float x_, float y_)
        : x{x_}, y{y_}
        , name{new char[std::strlen(name_)+1]} {
        std::strcpy(name, name_);
    }
};
```

.W[
**Therefore class `NamedPoint` needs a destructor – and probably a copy
constructor and assignment too.**._[]
]

.F[:
Otherwise a resource leak or dangling pointers will almost certainly result as
soon as objects of this class get created or assigned by copying from existing
objects.
]

---
template: plain
name: ct_vs_rt_sizing
header: ### Compile Time vs. Run Time Sizing

The necessity to do memory allocation as part of the constructor – with the
ultimate consequence to implemented more operations – does not arise if the
space requirements are variable but fixed at compile time.._[]

.pull-left[
```
class FString {
    const std::size_t N;
    char *data;
public:
    FString(std::size_t n)
        : N{n}
        , data{new char[N+1]} {
        data[0] = '\0';
    }
    ~FString() {
        delete[] data;
    }
};
…
FString fstr(20);
```
]

.pull-right[
```
template<std::size_t N>
class FString {
    char data[N+1];
public:
    FString() {
        data[0] = '\0';
    }
};
…
FString<20> fstr;
```
* Above: sized at **compile time**.
* Left: sized at **run time**.
]

.F[:
The design of a class for "fixed length" character strings taken as example is
is only partially fleshed out here – in practice some more member functions
would make sense.
]

---
template: plain
name: dtor_no_memory_dealloc
header: ### (No) Memory De-Allocation in Destructors

Classes that do no (further) memory allocation in their constructor code also
need no deallocation in their destructor – which may of course still be
necessary for other reasons.

Continuing with the above examples, only `NamedPoint` has the necessity for a
destructor:
.pull-left[
```
class Point {
    …
    // no destructor required
    // to "de-allocate" memory
    ~Point() {
        // … but maybe for
        // other reasons
    }
    …
};
```
]

.pull-right[
```
class NamedPoint {
    …
    ~NamedPoint() {
        delete[] name;
        // … maybe more to do
    }
    …
};
```
]

But: supplying a destructor which does nothing is neither necessary nor can it
be considered "good style" since it may not be optimised-out and slow down the
program each time an object ends it life.

---
template: plain
name: prc_memalloc_classes
header: ### Precautions in Memory Allocating Classes

Just copying the `data` pointer as the default constructor and assignment
operator would do is surely the wrong thing, so these should at least be
blocked,._[] which is particularly easy since C++11.

```
class NamedPoint {
    …
    NamedPoint(const NamedPoint &) =delete;
    NamedPoint& operator=(const NamedPoint &) =delete;
    …
};
```

.F[:
Still better were to implememt the operations so that the `name` member gets
properly cloned:

```
   … // inside the class above
    NamedPoint(const NamedPoint &init)
        : x{init.x}, y{init.y}
        , name{std::strcpy(new char[std::strlen(init.name)+1], name)}
    {}
    NamedPoint& operator=(const NamedPoint &rhs) {
        if (this != &rhs) {
            x = rhs.x; y = rhs.y;
            delete[] name;
            name = std::strcpy(new char[std::strlen(rhs.name)+1], name);
        }
        return *this;
    }
```
]

---
template: plain
header: #### Alternative Design with "Self-Contained" Helper Class

A still better design would put allocation and deallocation in a helper class
which is self-contained with respect to memory management._[]
```
class FString {
    const std::size_t N;
    char *data;
public:
    FString(std::size_t n) : N{n}, data{new char[N+1]} {
        data[0] = '\0';
    }
    FString(const FString &init) : data{new char[init.N+1]} {
        std::strcpy(data, init.data);
    }
    ~FString() { delete[] data; }
    FString& operator=(const FString &rhs) {
        std::strncpy(data, rhs.data, N)[N] = '\0';
    }
    operator const char*() const { return data; }
};
```

.F[:
Whether that way class `FString` is fleshed-out here is actually desirable for a
generically usable "fixed length string class" is disputable, but it was chosen
that way to mimic the prior approach (without helper) as much as possible.
]

---
template: plain
header: #### Simplifying Clients with Self-Contained Members

Now class `NamedPoint` can be implemented without worrying about memory
allocation and de-allocation:
```
class NamedPoint {
    float x, y;
    FString name;
public:
    Point(const char *name_, float x_, float y_)
        : x(x_), y(y_), name(std::strlen(name_)  {
        name = name_;
    }
    Point(const Point&) =default;            // if not =delete
    Point& operator=(const Point&) =default; // if not =delete
    …
};
```

The above also demonstrates the new syntax of C++11 to explicitly request the
default copy constructor and assignment._[], which means the operations are
recursively forwarded to all of the members.

.F[:
For backward compatibility, generating default versions of copy constructor and
assignment will still happen in C++11 without the above.
]

---
template: plain
name: ctor_dtor_exceptions
header: ### Exceptions in Constructors and Destructors

Generally constructors and destructors

* may "fail" (in doing what they are expected to do) and

* (in general) **one** option is to inform clients about the
  problem by throwing an exception.

.N[
The topic is covered in more detail later, with exceptions, so the following
pages only try to alert the reader for the problems caused by throwing from
constructors and destructors.
]

---
template: plain
header: #### Throwing from Constructors

When a constructor cannot establish the object state expected by the client
(that created the object and caused the constructor to initialise it), the
preferred way is to throw an exception.

Often this is the easiest way

* for the constructor code (that may just throw) …
* … and the client, that may catch the problem at an adequate location.

The only thing to remember here is that destructors are not enabled before
the constructor ends normally,._[] hence partially created objects may required
to

* wrap the constructor code into a `try`-block and
* handle exceptions in a local `catch`-block,
* finally re-throwing them (if the object is not left in a usable state).

.F[:
This makes another good argument to use "self-contained" members, because then
the compiler does the appropriate clean-up, as for all fully constructed member
objects the destructor will be called when the construction of the containing
object fails with an exception.
]

---
template: plain
header: #### Throwing from Destructors

As – contrary to the constructor – the destructor usually just "cleans-up" and
may not so easily run into resource limitations, there is much lesser reason for
problems during destruction.

But the main problem is:

* Destructors are sometimes run during stack-unwinding after an exception has
  occurred.
* When a destructor then would throw (again), it is difficult to decide which
  exception should take priority.

Hence, when a destructor is run during stack-unwinding when handling an
exception an some destructor it `throw`-s (again) the program is terminated.._[]

.W[
Therefore the general rule is never to let an exception escape from a
destructor.
]

.F[:
A specific terminate handler for that case can be installed, but it may not
(portably) return to its caller and continue.
]

---
template: plain
name: ctor_reuse
header: ### Re-Using Constructors

C++11 has introduced two features to re-use code from existing
constructors:

* [Constructor Delegation](#ctor_delegation) and

* [Constructor Inheritance](#ctor_inheritance)

The former e.g. allows to have some few *"work-horse"* constructors that are
called from a number of *"convenience constructors"*.

The latter extends the possibility to *"import"* members from base classes
with a `using`-directive into a derived class to constructors.._[]

.F[:
It is not quite clear whether this was not allowed in C++98, maybe it was just
an oversight …
]

---
template: plain
name: ctor_delegation
header: #### Constructor Delegation

With this feature – new in C++11 – a constructor of a class can be implemented
in terms of (calls to) some other constructor:

* It works by calling the delegated-to constructor as part of the
  member-initialisation list of the delegating constructor.

* The delegating constructor must not have anything else besides the
  delegated-to constructor in its member initialisation list.

* Constructor delegation may be changed but must not be recursive.._[]

.F[:
According to the C++11 standard a program with recursive constructor delegation
is ill-formed and hence should not compile. But at least some older compilers
seem not to detect this but produce a core dump when run.
]

---
template: plain
header: ##### Constructor Delegation Example

In the example following the `FString` constructor taking a `const char *`
argument reuses the `FString` constructor taking an `std::size_t` argument
for memory allocation:
```
class FString {
    const std::size_t N;
    const char *data;
public:
    FString(std::size_t n) : N{n}, data{new char[N+1]} {
        data[0] = '\0';
    }
    FString(const char *init) : FString(std::strlen(init)) {
	std::strcpy(data, init);
    }
    ~FString() {
        delete[] data;
    }
    …
};
```

---
template: plain
header: ##### Constructor Delegation and Exceptions

There is a small but useful change with respect to the rules when a destructor
is enabled:

* This happens when the innermost (leaf-) constructor has reached its normal
  end.

* Therefore a constructor delegated-to should put the object

  * in a usable state – i.e. where all its invariants are established.

  * or at least provide a means by which the destructor can decide what has to
    be cleaned-up and what is not yet initialised at all.

.W[
It should be noted that it is (somewhat) against the spirit of C++-constructors
to leave objects in a "half-baked" state …._[]
]

.F[:
In general, if an object has constructors which are only used to delegate to and
which do **not** establish all the invariants a user may expect, these
constructors should probably not be `public` but `private` (or `protected` at
most and properly documented with respect to the remaining initialisations.
]

---
template: plain
name: ctor_inheritance
header: #### Constructor Inheritance

If the base class constructors also work for the derived class, in C++11 it may
be made visible in C++11 with a `using` directive:._[]
```
class Point {
protected:
    float x, y;
public:
    Point() : x(0.0), y(0.0) {}
    Point(float x_, float y_) : x(x_), y(y_) {}
    …
};
…
class MovablePoint : public Point {
public:
    using Point;
    void move(float dist_x, float dist_y) {
        x += dist_x;
        y += dist_y;
};
```

.F[:
Typically a derived class adds its own data members and therefore requires
extended initialisation, so it needs its own set of constructors.
]

---
template: plain
name: static_polymorphism
header: ## Static Polymorphism

--------------------------------------------------------------------------

* [Overloading Functions		](#overloading_functions)
* [Overloading Operators		](#overloading_operators)
* [Argument Default Values		](#default_arguments)
* [Overloading and Overriding		](#overloading_vs_overriding)

--------------------------------------------------------------------------

Argument default values were included here as their applicability overlaps
with function overloading, though – viewed from the hardware perspective –
for non-`inline` functions they are implemented quite differently.

---
template: plain
name: overloading_functions
header: ### Overloading Functions

Several functions may exist with the same name as long as they can be
distinguished by number and type of arguments._[]

```
void foo(const char *);         /*1*/
double foo(const int &, char);  /*2*/
double foo(double, double);     /*3*/
```
.N[
Which function will be called (or that the call is ambiguous) will be decided
from the arguments actually used.
]
```
int x; double y;
…
foo("hello, world");   /*calls 1*/
foo(42, 'z');          /*calls 2*/
foo(y, y/2);           /*calls 3*/
foo(x, y);             /*calls ?*/
```

.F[:
If one argument list is from left to right an exact subset of another one, the
overall effect is similar to default values for arguments. But with overloading
there are as many separate entry points as there are functions, while with
default arguments there is just one entry point and missing argument values are
automatically supplied.
]

---
template: plain
header: #### Overloading based on `const` and non-`const` Parameters

A `const` qualification in so far is part of the parameter type as it makes a
difference:
.pull-left[
**Continuing** the example from the previous page:
```
char data[100];
…
foo(data); /*1*/
```
]

.pull-right[
**Extending** this example:
```
void foo(char *); /*4*/
extern const char greet[]; 
…
foo(data);  /*4*/
foo(greet); /*1*/
```
]

If only one function (either the one with or the one without `const`) exists,
the effect is as follows:

* With **only** the function taking a `const char *` it will be used in **both**
  cases.._[]
* **Without** the function for a `const char *` the call with a non-modifiable
  argument (as `foo("hi")` in the example) **will fail to compile**.

.F[:
Clearly it is no problem to hand a modifiable memory location via pointer or
reference over to a function that promises **not** to change it, but **not vice
versa**!
]

---
template: plain
name: overloading_operators
header: ### Overloading Operators

[Boost.Operators]: http://www.boost.org/doc/libs/release/libs/utility/operators.htm

Operators may be overloaded by defining functions with a name that starts with
`operator`:

* The overload must take at least one operand of class type.._[]

* Most operators can be overloaded with either free functions or with member
  functions, i.e. either the left of the right hand operand needs to be of a
  class type.

* Some operators may only be overloaded with member functions; then the left
  hand operand must be of a class type.

* To consistently overload whole operator groups [Boost.Operators] may come in
  handy.

See also:

* http://en.cppreference.com/w/cpp/language/operators
* http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm

.F[:
Therefore the meaning of operators for built-in-types cannot be modified. If you
want to come close to the behaviour of a given built-in types but change or
remove some predefine operations you will typically have to **add** a new class
and implement all the operations it should support.
]

---
template: plain
header: #### Overloading Operators with Free Functions

In principle this needs to happen as follows:
```
MyClass operator+(const MyClass &lhs, const MyClass &rhs) {
    … // do whatever must be done
    return …;
}
```

The return type can be freely chosen - as long as the `return` statement is of
compatible type.

More exactly, the expression after `return` must

* either have the exact return type (`MyClass` in the example)
* or be convertible to that type.._[]

.F[:
See also [here](#brace_init_shorthand) for an interesting short-hand notation
possible with C++11 brace initialisers.
]

---
template: plain
header: #### Operator Overloading with Member Functions

In principle this needs to happen as follows:
```
MyClass &MyClass::operator+=(const MyClass &rhs) {
    … // do whatever must be done
    return *this;
}
```

Again the return type may be freely chosen.

.N[
According to what happens for built-in types, usually the object itself will be
returned
]

Typically that object is returned by reference (otherwise it weren't the object
but only a copy).with the modifications done by the operations

As technically a reference is just an address, this is

* performant (e.g. may use a register) and
* nearly free of any overhead if not used.._[]

.F[:
Also, for an optimizing compiler there is a fair chance to remove any remaining overhead …
]

---
template: plain
name: copy_ctor_assign
header: #### Overloading Copy Constructor and Assignment

[Rule Of Three]: http://en.cppreference.com/w/cpp/language/rule_of_three

For certain classes the following operations need to be overloaded, as the
compiler-generated default does the wrong thing:
```
class MyClass {
    T *some_ptr;
    …
public:
    …
    // avoid compiler defaults:
    MyClass(const MyClass& rhs);
    MyClass& operator=(const MyClass& rhs);
}
```

.N[
The classic indication are pointers as member data, referring to memory managed
by the instance.
]

.F[:
In C++ books this is often referred to as [Rule of Three] – the third member
function for which the default is not appropriate is the destructor, of course.
]

---
template: plain
name: move_ctor_assign
header: #### Overloading Move-Constructor and Assignment

[Rule Of Five]: http://en.cppreference.com/w/cpp/language/rule_of_three

[Rvalue References]: #rvalue_ref

C++ [Rvalue References] most often used to provide different implementations
for object construction and assignment.._[], depending on whether the right hand
operand denotes

* an object instance that will continue to exist after the operation, or
* temporary memory which will be destroyed afterwards (as is the case for an
  expression or function call).

```
class MyClass {
public:
    …
    // copy versions (rhs lives on in memory)
    MyClass(const MyClass& rhs);
    MyClass& operator=(const MyClass& rhs);
    // move versions (rhs destroyed soon after)
    MyClass(MyClass&& rhs);
    MyClass& operator=(MyClass&& rhs);
}
```

.F[:
Turning the classic C++ *Rule of Three* into the [Rule of Five] in C++11.
]

---
template: plain
name: move_ctor_assign
header: #### Implementing Move Construction and Assignment

After declaring move construction and assignment, they need to be implemented.

If copy construction looks as follows …
```
MyClass::MyClass(const MyClass &rhs)
    : …, some_ptr(new T(*rhs.some_ptr)), …    // cloning resource
{ … }
```

… this could be an adequate move construction:
```
MyClass::MyClass(MyClass &&rhs)
    : …, some_ptr(rhs.some_ptr), …    // taking over resource
{ …; rhs.some_ptr = nullptr; … }      // INVALIDATING it for rhs!
```

.N[
Assignment operations are similar but need to free `some_ptr` first..[]
]

.F[:
The general difference between constructor and assignment is that the former
gets just a piece of memory while the later finds a valid object that needs
to be properly de-constructed first.
]

---
template: plain
header: #### Distinguishing between Copy and Move

If both exists (copy and move), behaviour is as follows:._[]

```
MyClass foo() { return …; }  // … must be an expression of
                             // type MyClass (or something
                             // convertible to MyClass)
// constructor use:
MyClass a;        // (expects c'tor with no arguments)
MyClass b(a);     // copy c'tor (does not modify a)
MyClass c(foo()); // move c'tor (may modify temporary)

// assignment use:
a = c;            // copy assignment (does not modify c)
b = foo();        // move assignment (may modify temporary)
c = a + b;        // move assignment (may modify temporary
                  //                  returned from operator+)
```

.F[:
Of course, adding operands of type `MyClass` in the last line of the example
also assumes `operator+` exists and returns by value, as is the usual behaviour.
In the (unusual) case that operator were defined but returns something that C++
considers to be "more persistent" (like a reference), copy assignment would be
used instead, though a move could be enforced then: `c = std::move( … );`
]

---
template: plain
name: default_arguments
header: ### Argument Default Values

Arguments may take default values "from right to left", i.e.:

* As soon as one argument has a default value,
* all others following on the right must have one too.

.N[
The default value needs to be known where the function is called. Therefore it
is part of the declaration and – for functions shared between `.cpp` files –
needs to go into the header file.
]

As usual for declarations, argument names are optional:._[]

```
// the following function can be called with 1..3 arguments:
double foo(int &count, int minsize = 0, char separator = 'z');
…
// same as:
double foo(int &, int = 0, char = 'z');
```

.F[:
Using names for arguments in prototypes has pro's and con's: it is of course
more self-documenting but there is at least a remote chance for surprising and
**extremely hard to find** name clashes with preprocessor macros. Hint: view
preprocessor output (`g++ -E …`) whenever you get desperate because of an
completely unexplainable syntax error in your source code.
]

---
template: plain
name: overloading_vs_overriding
header: ### Overloading and Overriding

The above two terms are sometimes confused, though – if used precisely – they
have a well defined, different meaning:._[]

* *Overloading* means there are two (or more) functions with identically spelled
  function names but with different parameter lists so that the compiler can
  select one based on the actual call arguments.

* *Overriding* means that some class uses the same name for a member function
  that has already been used in one of its base classes.

As the usual translation for "overriding" to German is "überschreiben", by
sloppy back-translation sometimes the term "overwriting" has been introduced
as a synonym for "overriding".

.F[:
Disregarding the fact that an object in a member function call is syntactically
not part of the argument list (but goes to the left, separated with a dot), from
a purely technical perspective the object involved in the call is just another
argument and hence "under the hood" overloading and overriding are actually
related.
]

---
template: plain
name: overriding_example
header: #### Overriding Example (1)

In the following example there are three overloaded member functions `foo`:
```
class Base {
    …
    void foo(int);
    void foo(double);
    void foo(const char *);
    …
};
```

It are **all(!)** of the above that get overridden by a **single** member
function `foo` in a derived class:
```
class Derived : public Base {
    …
    void foo(double);
    …
};
```

---
template: plain
name: overriding_example
header: #### Overriding Example (2)

How the following calls are resolved sometimes even surprises seasoned C++
developers:
```
Base b;
b.foo(42);       // calls Base::foo(int) -- no surprise
b.foo(3.14);     // calls Base::foo(double) -- no surprise
b.foo("hello");  // calls Base::foo(const char *) -- no surprise
…
Derived d;
d.foo(3.14);     // calls overriding Derived::foo(double)
d.foo(42);       // as before(!) with type conversion of argument
d.foo("hello");  // ERROR (does not compile)
```

.W[
Especially if there are automatically applied type conversions (like above from
`int` to `double`) the problem might go unnoticed for a long time.
]

---
template: plain
name: overriding_and_using
header: #### Overriding and the `using` Directive

If a derived class shall inherit **all** overloads of its base class and then
**some** are selectively overridden, the `using` directive will help:
```
class Derived : public Base {
    …
    using Base::foo;
    void foo(double);
    …
};
…
Derived d;
d.foo(3.14);     // calls overriding Derived::foo(double)
d.foo(42);       // calls Base::foo(int) -- no surprise
d.foo("hello");  // calls Base::foo(const char *) -- no surprise
```

.W[
There might still be surprises in case of argument types that do not exactly
match and hence undergo a conversion.
]

Luckily many oversights falling into that category of problems will manifest
themselves in ambiguities and cause the compilation to fail.

---
template: plain
name: type_conversions
header: ## Type Compatibility and Conversions

--------------------------------------------------------------------------

* [Type Compatibility for Native Types		](#native_type_typeconv)
* [Type Compatibility and Inheritance 		](#public_base_typeconv)
* [Explicit Type Conversion by *Cast*		](#explicit_typeconv)
* [Class-Specific Type Conversions		](#specified_typeconv)
* [Achieving General Type Safety		](#general_typesafety)

--------------------------------------------------------------------------

---
template: plain
name: native_type_typeconv
header: ### Type Compatibility for Native Types

[Integer Types]: http://de.cppreference.com/w/cpp/language/types#Integer_types
[Floating Point Types]: http://de.cppreference.com/w/cpp/language/types#Floating_point_types

The most important rules for type compatibility among native types are:

* All *Arithmetic Types* – subsuming [Integer Types], [Floating Point Types],
  and `bool` – are compatible among each other and participate in automatic
  conversions as necessary, striving to preserve the value.._[]

.W[
Conversions between arithmetic types often require some code (machine
instructions) to be executed and hence are not completely "free".
]

.F[:
Of course, preserving the value has its limits like for conversions to types
with a smaller range of values (usually truncated) and especially when
converting to `bool` the result is `true` for non-zero values while – vice versa
`true` is converted to the value `1` (unambiguously).
]

---
template: plain
header: #### Type Compatibility for Native Types (2)

* The following conversions are **automatically** applied in one direction only:

  * Enumerations (`enum`) **→** Arithmetic Type;
  * Pointers **→** `bool` (all but `nullptr` is `true`);
  * Typed Pointer **→** Generic Pointers (`void *`).

* I.e. there are **no automatic conversions** reversing the above.

The last rule improves [General Type Safety of C++](#general_typesafety)
in a critical case._[]

.I[
Differently from C in C++ there can be no "silent" type conversion going from
a typed pointer to a generic pointer and back.
]

.F[:
The reason for that change is that according to C89 the `malloc` library
function (including its cousins `calloc` and `realloc`) return generic pointers,
the compiler is not aware of their special nature.
]

---
template: plain
name: public_base_typeconv
header: ### Type Compatibility and Inheritance

[Slicing]: http://www.geeksforgeeks.org/object-slicing-in-c/

* Pointers to publicly derived classes are automatically converted to pointers
  to direct or indirect._[] base classes, wherever necessary.

* References to publicly derived classes are automatically converted to
  references to direct or indirect._[] base classes, wherever necessary.

* **Objects** of a publicly derived class may be used to automatically
  initialise the members of their base class, called [Slicing].

.I[
Except for multiple inheritance the first two cases usually do **not** involve
execution of any machine instructions, hence are effectively "free".
]

.F[:
For indirect, non-virtual base classes in case of multiple inheritance with
diamond-shaped relation to a common base (annotated as "«disjoint»" in UML)
an automatic conversion would be ambiguous.
]

---
template: plain
name: public_base_lsp
header: #### Public Base Classes and the LSP

[Principle of Substitutibility]: http://dictionary.reference.com/browse/liskov+substitution+principle

The rules on the previous pages are the practical result of Barbara Liskov's

* "*[Principle of Substitutibility]*"

formulated once for "good object oriented software" and often abbreviated as
LSP since it was first expressed.

.N.center[
The LSP in C++ is only valid for public base classes!

**Only in this case it makes sense to talk about "Inheritance"** (in its common
meaning in OOP).
]

Inheritance._[] is also called *Generalisation-Specialisation* and in UML
denoted as solid line with a hollow triangle at the base class end.

.F[:
To be clear once more: what is discussed here is a class relation that implies
substitutability according to the LSP. As inheritance is at the heart of
object-oriented modelling and programming, it will be covered in more depth
later ([see Wednesday Part 1 Inheritance](05_wednesday1.html#inheritance)).
]

---
template: plain
name: private_base_no_lsp
header: #### Private Base Classes (no LSP)

Public and  private base classes in C++

* use the same memory layout, but

* **for private base classes there is no LSP**.

.N[
In the common meaning in OOP a private base class is not inheritance but
composition.
]

Composition is a special case of aggregation._[] and will be denoted in the UML
with a small black diamond at the aggregate side.

.F[:
The special case is that the lifetime of the *part* is coupled to that of the
aggregate. As composition is very important in object-oriented modelling and
there are various ways to implement it in C++, it will be covered in more depth
later ([see Wednesday Part 1 Aggregation](05_wednesday1.html#aggregation)).
]

---
template: plain
name: explicit_typeconv
header: ### Typ-Konvertierung mittels *Cast*

[Cast-Operation]: http://www.cplusplus.com/doc/tutorial/typecasting/

Mittels sogenannter [Cast-Operation]en lassen sich weitere Typ-Konvertierungen
erzwingen.

.W[
Die Cast-Syntax von C, bei welcher man den Zieltyp in runde Klammern einschließt
und den umzuwandelnden Wert direkt dahinter schreibt, sollte in C++ vermieden
werden.
]

Die neue Syntax beginnt mit einem der Schlüsselworte

* [`static_cast`](#static_cast_typeconv)
* [`dynamic_cast`](#dynamic_cast_typeconv)
* [`const_cast`](#const_cast_typeconv)
* [`reinterpret_cast`](#reinterpret_cast_typeconv)

Es folgen der Zieltyp in spitzen Klammern und der umzuwandelnde
Wert in runden Klammern.._[]

.F[:
As an example consider the use of C-style memory allocation for some `struct s`
in C++.  
```
struct s *p = static_cast<struct s*>(std::malloc(sizeof (struct s))); // required conversion in C++
          … (struct s*) std::malloc(sizeof (struct s)); // C-style cast, possible but deprecated in C++
                     
```
]

---
template: plain
name: static_cast_typeconv
header: #### Typ-Konvertierung mit `static_cast`

Hiermit lassen sich zum einen Typ-Konvertierungen explizit hervorheben, welche
der Compiler auch automatisch vorgenommen hätte.._[]

Darüberhinaus funktioniert der `static_cast` in **beide** Richtungen für
diejenigen Typ-Konvertierungen, welche **automatisch** nur in einer Richtung
eingesetzt werden:

* Arithmetische Wert **→** Aufzählungstypen (`enum`)

  * automatisch nur Aufzählungstypen in arithmetische Werte

* Generische Zeiger (`void *`) **→** typisierte Zeigern

  * automatisch nur typisierte in generische Zeiger

* Basisklassen in abgeleitete Klassen (Down-Cast)

  * automatisch nur abgeleitete Klassen **→** Basisklassen (Up-Cast)

.F[:
The most typical reason for this is that many compilers will issue a warning
when an arithmetic conversions might not be value preserving, e.g. when an
64-bit integral value is assigned to a 32 bit integral variable. If this is
done with a cast, most compilers will suppress the warning.
]

---
template: plain
name: dynamic_cast_typeconv
header: #### Typ-Konvertierung mit `dynamic_cast`

[`std::bad_cast`]:     http://en.cppreference.com/w/cpp/types/bad_cast
[Laufzeit-Typprüfung]: 04_wednesday2.html#dynamic_cast

Hiermit lassen sich ausschließlich Typ-Konvertierungen innerhalb von
Klassenhierarchien vornehmen.

.N[
Im Fall von Down-Casts findet zur Laufzeit eine Überprüfung mit Fehleranzeige
statt, wenn der Cast nicht durchführbar ist.._[]
]

Die Fehleranzeige besteht

* bei **Casts auf Zeigerbasis** in der Rückgabe eines Nullzeigers;

* bei **Casts auf Referenzbasis** in einer [`std::bad_cast`]-Exception.

Weiteres wird später im Rahmen der [Laufzeit-Typprüfung] (RTTI) behandelt.

.F[:
Der Grund für die eventuelle Undurchführbarkeit muss zusammen mit der
Typ-Kompatibilität zwischen Basisklassen und abgeleiteten Klassen gesehen
werden: Gemäß [LSP](#public_base_lsp) kann ein Zeiger oder eine Referenz, der
bzw. die als Zeiger oder Referenz für eine Basisklasse definiert ist, auch ein
Objekt einer davon abgeleiteten Klasse referenzieren. Ob dies der Fall ist,
lässt sich mit `dynamic_cast` überprüfen und mittels des auf diese Weise ggf.
erhaltenen Zeigers (bzw. der so erhaltenen Referenz) besteht schließlich
Zugriff auf die von der abgeleiteten Klasse hinzugefügten Member-Daten und
-Funktionen.
]

---
template: plain
name: const_cast
header: #### Typ-Konvertierung mit `const_cast`

Die hiermit möglichen Typ-Konvertierungen beschränken sich auf das

* Hinzufügen oder
* Wegnehmen

von `const` und `volatile`.

Alle anderen Unterschiede zwischen dem Zieltyp und dem Typ des umzuwandelnden
Ausdrucks führen zu einem Compile-Fehler.

.W[
Ein `const_cast` hat gemäß dem C++-Standard undefiniertes Verhalten, wenn er
dazu führt, dass auf eine mit Schreibschutz definierte Speicher-Adresse
schreibend zugegriffen wird.
]


Das typische Fehlerbild reicht von der inkonsistenten Wertverwendung (teilweise
alter Wert, teilweise neuer Wert) bis zum Programmabsturz …._[]

.F[:
Abhängig von der Testtiefe, dem verwendeten Compiler, Optimierungs-Optionen usw.
mag es allerdings auch so erscheinen, als würde alles wie gewünscht funktionieren.
]

---
template: plain
name: reinterpret_cast
header: #### Typ-Konvertierung mit `reinterpret_cast`

  [Boost.Variant]: http://www.boost.org/doc/libs/1_57_0/doc/html/variant.html

Dieses Konstrukt wird vor allem dazu eingesetzt, Zeiger auf (bekannte)
Hardware-Adressen zu setzen, wie das u.a. im Bereich der Embedded Programmierung
und bei Gerätetreibern notwendig sein kann.._[]

.F[:
Dass es per `reinterpret_cast` möglich ist, quasi jedes Bitmuster im Speicher
gemäß jedem beliebigen Typ zu interpretieren, führt mitunter zu der Kritik, C++
sei keine "sichere" Programmiersprache. Diese Kritik müsste dann aber für alle
Sprachen gelten, die ein zur C/C++ `union` vergleichbares Konstrukt besitzen …
(zumindest solange kein automatisches "type-tagging" wie bei [Boost.Variant]
erfolgt).
]

Darüber hinaus kann man mit einem `reinterpret_cast`

* **wie auch per `static_cast`** generische Zeiger (`void *`) in typisierte
  Zeiger umwandeln, und

* **anders als per `static_cast`** typisierte Zeiger **direkt** in anders
  typisierte Zeiger umwandeln.

.N[
Es ist dagegen auch mit `reinterpret_cast` nicht möglich, die `const`- und
`volatile`-Qualifizierung zu ändern – dies erlaubt nur der `const_cast`.
]

Um beide Konvertierungen zu kombinieren, müssen die jeweiligen Cast-Konstrukte
ggf. nacheinander (oder geschachtelt) verwendet werden.

---
template: plain
name: reinterpret_cast_examples1
header: #### Typ-Konvertierung mit `reinterpret_cast` (Beispiel 1)

Das folgende Beispiel nimmt an, dass an der Speicheradresse `0xEAD0` die als
`struct uart` beschriebenen Kontrollregister abgebildet sind:
```
struct uart *const sio = reinterpret_cast<struct uart*>(0xEAD0);
```
Der Zugriff kann nun in der Syntax `sio->…` erfolgen.

Gibt es mehrere solche Register-Strukturen im Speicher (als Memory-Mapped-I/O)
abgebildet, kann natürlich auch ein Array initialisiert
```
struct uart *const sio[] = {
    reinterpret_cast<struct uart*>(0xEAD0),
    reinterpret_cast<struct uart*>(0xEAD8),
    …
};
```
und über dieses mit `sio[0]->…`, `sio[1]->…` usw. zugegriffen werden.

.F[:
Wird statt dem Pfeil die Punkt-Notation bevorzugt, geht das auch, und zwar mit:
```
struct uart &sio = *reinterpret_cast<struct uart*>(0xEAD0);
```
]

---
template: plain
name: reinterpret_cast_examples2
header: #### Typ-Konvertierung mit `reinterpret_cast` (Beispiel 2)

  [C++ Calling Conventions]: 06_wednesday2.html#calling_conventions

Das folgende Beispiel nimmt an, dass an der Adresse `0xCAFE` im Code-Segment

* ein Unterprogramm (gemäß [C++ Calling Conventions]) steht,
* welches ein Argument vom Typ `bool` erwartet und
* keinen Rückgabewert liefert.

```
void (*xcall)(int) = reinterpret_cast<void (*)(int)>(0xCAFE);

```
Der tatsächliche Aufruf kann nun so erfolgen:
```
xcall(true);
…
xcall(false);
```
erfolgen.._[]

.F[:
Of course, if there is a value returned supplied (according to the C++ calling
conventions) and specified in the declaration, it could be accessed in the usual
way.
]

---
template: plain
name: specified_typeconv
header: ### Klassenspezifische Typ-Konvertierungen

Eine Klasse kann auch festlegen, wie ihre Objekte bei Bedarf automatisch **aus**
eingebauten Typen und anderen Klassen erzeugt bzw. **in** solche konvertiert
werden können. Dazu folgende Analogie:

* Jede Klasse und jeder eingebaute Typ hat eine spezifische Art von *Ein- und
  Ausgangs-Steckverbindern*, die nur "zu sich selbst" passt.

  * In Initialisierungen und Zuweisungen sind daher zunächst nur Objekte von
    genau dieser Klasse bzw. diesem Typ verwendbar.._[]

* **Konstruktoren mit exakt einem Argument** – sofern nicht als `explicit`
  markiert – sind weitere *Eingangs*-Steckverbinder.

  * Sie passen zum *Ausgangs*-Steckverbinder des Argument-Typs.

* **Typ-Cast-Operatoren** sind weitere *Ausgangs*-Steckverbinder.

  * Sie passen zum *Eingangs*-Steckverbinder des Ziel-Typs.

.F[:
If you like that picture you may include base class conversions by assuming
plugs and sockets with the same basic shape for class hierarchies, using code
pins to make the output connector of a derived class fit into the input connector
of its base class(es), but not vice versa. (For standard conversions of basic
types assume a set of adapter plugs that are applied as necessary.)
]

---
template: plain
name: constructor_conversion
header: #### Typ-Konvertierungen durch Konstruktoren

Konstruktoren sind dann automatische Typ-Konvertierungen, wenn sie

* genau ein Argument besitzen und
* **nicht** mit dem Schlüsselwort `explicit` markiert sind.

```
class MyClass {
    …
public:
    MyClass(int);  // each single argument c'tor is an
                   // automatic conversion ... except
    explicit MyClass(double);  // it is marked explicit
    …
};
```

---
template: plain
header: #### Anwendung von Konstruktoren zur Typ-Konvertierung

Typ-Konvertierungen durch Konstruktoren kommen wie folgt zur Anwendung:

```
void foo(MyClass);
…
foo(33);            // OK (automatic conversion by c'tor)
foo(3.3)            // ERROR, c'tor is explict
foo(MyClass{3.3});  // OK (c'tor is used explicitly)
…
MyClass x{-1};      // this would also work with explicit c'tor but ...
x = 33;             // ... here an automatic conversion is necessary ...
x = 3.3;            // ... so this will fail if there is none
```
.I[
Die Notwendigkeit einer Typ-Konvertierung bei der Zuweisung hängt auch davon
ab, welche (zusätzlichen) Zuweisungs-Operatoren eine Klasse ggf. definiert._[]
]

.F[:
An assignment operator taking **exactly** the type of the expression of its
right hand operand as argument will always be preferred (and of course applied
as there is no need for a conversion). In case the assignment operator takes a
`const MyClass&` argument a temporary will be created if a non-`explicit` c'tor
or a type-cast operator is available as automatic conversion.
]

---
template: plain
name: brace_init_shorthand
header: #### Brace Initialisers as Short-Hand Notation

In some contexts brace initialisation syntax may also be used as short-hand
notation for constructor calls, without naming the class:
```
class MyClass {
   …
   MyClass();
   MyClass(int);
   MyClass(const char*, double);
   …
};
…
void foo(MyClass);
foo({});               // foo(C{});
foo({42});             // foo(C{42});
…
MyClass bar() {
   …
   return {"hi", 3.14};   // return C{"hi", 3.14}
}
```

The only necessary precondition is that the constructors to be applied are not
`explicit`, their argument count does not matter.

---
template: plain
header: #### Temporäre Objekte im Rahmen der Typ-Konvertierung

Bei Referenzübergabe ist zusätzlich zu beachten, dass bei der
Konvertierung ein temporäres Objekt notwendig wird:
```
void baz(MyClass &); // non-const reference argument
…
baz(42);                       // ERROR (no automatic temporary
                               //        for non-const reference)
baz(MyClass(42));              // ERROR (c'tor call does not bind
                               //        to non-const reference)
{ MyClass tmp(42); baz(tmp); } // OK
```

Automatisch wird dies nur für `const`-qualifizierte Referenzen erzeugt:
```
void bar(const MyClass &); // const reference argument
…
bar(42);                       // OK (automatic temporary)
```

---
template: plain
name: typecast_operator
header: #### Typ-Konvertierung durch Type-Cast Operatoren

Type-Cast Operatoren benutzen eine spezielle Syntax, bei der **nach** dem
Schlüsselwort `operator` der Zieltyp folgt:._[]
```
class MyClass {
    …
public:
    // this is called type-cast operator:
    operator Other() const { …; return …; } 
                                    // ^-- Other (or at least
                                    //     convertible to Other)

    // the usual explicit alternative:
    int to_int() const { …; return …; }
                                // ^-- int (or at least
                                //     convertible to int)
};
```

.F[:
Dieser stellt zugleich den Ergebnistyp dar, den die `return`-Anweisung liefern
muss.
]

---
template: plain
header: #### Automatische Anwendung von Type-Cast Operatoren

Die Typ-Konvertierungen von der vorhergehenden Seite kommen wie folgt zur Anwendung:
```
void foo(Other);
void bar(int);
…
MyClass m;
foo(m);           // OK, implicit use of type-cast operator
bar(m);           // ERROR (of course), but ...
bar(m.to_int());  // ... usual style for explicit conversion
```

---
template: plain
header: #### Special case: `explicit operator bool()`

Type conversions to `bool` marked `explicit` are a special case:

* They will **not** applied for conversion of general expressions, like argument
  coercion, initialisation, assignment,

* **but will be for boolean operations and in condition testing.**

The examples on the following page build on this:
```
class MyClass {
    …
public:
    explicit operator bool() {
       return …; // some bool
    }
    …
};
…
MyClass obj;
extern void foo(bool);
```

---
template: plain
header: #### Example: `explicit operator bool()`

The following code fragments extend the example from the previous page:

* `#1` shows an unusual but permitted form to call the type conversion to
  `bool`.
* `#2a` is an error as it is ambiguous, which is solved by some extra
  parentheses in `#2b`.
* `#3` is a permitted but unnecessary explicit type conversion.

.pull-left[
```
// this does NOT compile ...
foo(obj);

bool bv(obj);
bool bv(bool(obj));      //#2a
bv = obj;

if (obj == true) … 
if (obj == false) …
if (obj == bv) …
// ... compare with code on
// the right for corrections

```
]
.pull-right[
```
// this solves the problems:
foo(bool(obj));
foo(obj.operator bool()); //#1

bool bv((bool(obj)));     //#2b
bv = bool(obj);
if (bool(obj)) …          //#3
if (obj) …
if (!obj) …
if (bool(obj) == bv) …
// boolean operators work too:
if (obj && !bv) …
```
]

---
template: plain
name: general_typesafety
header: ### Type Safety in C++

A practical consequence of the risks by explicit type conversions – i.e. the
four C++ style cast operations and the legacy C-style cast – is this:

.W[
All explicit type conversions (with casts) should be reduced to the
unavoidable minimum.
]

Furthermore, [class specific type conversions][#specified_typeconv) are
sometimes applied where not intended:._[]

.I[
Class specific type conversions should only be defined where a silent change
between these types is very frequent and considered "natural".
]

.F[:
Or to put it slightly different: Experience showed there are scenarios of
practical importance where a compile error would have been preferred over
the way the compiler made the code "correct" by applying a (non-explicit)
constructor or type-cast operator.
]

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>
