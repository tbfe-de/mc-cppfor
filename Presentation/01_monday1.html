<!DOCTYPE html>
<html>
  <head>
    <title>(1) C++-For - Monday Part 1</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
    <!-- when changing the stylesheet file please see also remark below -->
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies aproximately 2/3 of the page width. So only add
  little information, preferrably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open – add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++ FOR]: 00_content.html#agenda

# [C++ FOR] (Monday Morning)

---------------------------------------------------------------------------

1. [Auffrischung einiger wichtiger Grundlagen	](#cpp_basics)
1. [Zeiger und Referenzen			](#reference_types)
1. [Statischer Polymorphismus			](#static_polymorphism)
1. [Typ-Kompatibilität und -Konvertierung	](#type_conversions)
1. [Praktikum					](#exercise_mon1)

---------------------------------------------------------------------------

Kürzere Pausen werden jeweils nach Bedarf eingelegt.

Falls die Übungsaufgabe nicht wegen eines verkürzten Vormittagsteils
entfällt, erfolgt die Besprechung der Musterlösung(en) im direkten Anschluss
an die Mittagspause.

---
template: plain
name: cpp_basics
header: ## Auffrischung einiger wichtiger Grundlagen

--------------------------------------------------------------------------

* [Getrennte Kompilierung		](#separate_compilation)
* [Definition/Reference-Modell		](#definition_reference)
* [Schreibschutz durch den Compiler	](#const_protection)

--------------------------------------------------------------------------

---
template: plain
name: separate_compilation
header: ### Getrennte Kompilierung

#### Grundlagen der getrennten Kompilierung

[Build-System]: http://en.wikipedia.org/wiki/Build_automation
[Unix `make`]:  http://en.wikipedia.org/wiki/Make_(software)
[Bell Labs]:    http://en.wikipedia.org/wiki/Bell_Labs
[GNU make]:     http://en.wikipedia.org/wiki/GNU_build_system
[CMake]:        http://en.wikipedia.org/wiki/CMake

[Übersetzungseinheiten]: http://en.cppreference.com/w/cpp/language/translation_phases
[Header-Files]: http://www.cplusplus.com/forum/articles/10627/

Ein C++-Programm wird üblicherweise in eine mehr oder weniger große Zahl von
[Übersetzungseinheiten] aufgeteilt.

* Diese stehen in Implementierungsdateien, deren Dateinamens-Suffix meist `.cpp`
  ist.

* Sind ein und dieselben Informationen in mehr als einer Übersetzungseinheit
  notwendig, gehören diese in [Header-Files], deren Dateinamens-Suffix meist
  `.h` ist (seltener: `.hpp`).

.I[
Bereits bei einer kleinen Zahl von Übersetzungseinheiten sind die Abhängigkeiten
zwischen diesen inklusive ihrer Header-Files oft nur noch schwer zu überblicken,
so dass sich die Verwendung eines [Build-System]s empfiehlt.._[]
]

.F[:
Unter den heute verwendeten Build-Systemen hat das 1976 an den [Bell Labs] von
Stuart Feldman entwickelte [Unix `make`] weitaus mehr als eine nur historische
Bedeutung, in der Kernsyntax sind auch moderne Derivate wie [GNU make] und
[CMake] immer noch identisch zu ihrem Vorbild.
]

---
template: plain
header: #### Abhängigkeiten zwischen Header-Files

Nicht selten kommt es auch zu Abhängigkeiten von Header-Files untereinander,
z.B. wenn

* in einem Header-File ein Datentyp oder eine Klasse **verwendet** wird,

* die in einem anderen Header-File **definiert** ist.

.N[
In solchen Fällen ist es meist üblich, im abhängigen Header-File den als
Voraussetzung erforderlichen zweiten Header-File direkt zu inkludieren.
]
.pull-left[
```
// header file: Base.h
class Base {
    …
};
```
]
.pull-right[
```
// header file: Derived.h
#include "Base.h"
class Derived : public Base {
    …
};
```
]

---
template: plain
header: #### Include-Guards

[Include-Guard]: http://gcc.gnu.org/onlinedocs/cppinternals/Guard-Macros.html
[One Definition Rule (ODR)]: http://en.cppreference.com/w/cpp/language/definition

Da ein und derselbe Header-File oft auf verschiedenen Wegen inkludiert wird,
muss die **mehrfache Verarbeitung**._[] ausgeschlossen werden. Dies geschieht
mit sogenannten [Include-Guard]s:

.pull-left[
```
// header file: Base.h
#ifndef BASE_H
#define BASE_H
class Base {
    …
};
#endif
```
]
.pull-right[
```
// header file: Derived.h
#ifndef DERIVED_H
#define DERIVED_H
#include "Base.h"
class Derived : public Base {
    …
};
#endif
```
]

.F[:
Der Grund hierfür liegt vor allem in der [One Definition Rule (ODR)], welche
die wiederholte Einführung von Bezeichnern stark einschränkt.
]

---
template: plain
header: #### Namespaces

Wie das folgende Beispiel deutlich macht, ist der Klassenname für sich allein
als Include-Guard u.U. problematisch:

.pull-left[
```
#ifndef SOMECLASS_H
#define SOMECLASS_H
namespace Mine {
    class SomeClass {
        …
    };
}
#endif
```
]

.pull-right[
```
#ifndef SOMECLASS_H
#define SOMECLASS_H
namespace Other {
    class SomeClass {
        …
    };
}
#endif
```
]

Wenn jetzt beide Files inkludiert werden, macht der erste den Inhalt des zweiten
quasi "unsichtbar" … was aber vermutlich erst nach einer überaus langwierigen
Fehlersuche offenbar wird.

.W[
Somit sollte der Include-Guard auch den Namen des `namespace` enthalten, also
z.B. `MINE_SOMECLASS_H` und `OTHER_SOMECLASS_H`.._[]
]

.F[:
Auch stellt sich die Frage, ob man im Include-Guard tatsächlich alle Buchstaben
groß schreiben sollte …
]



---
template: plain
header: #### Zyklische Abhängigkeiten

Einiges Kopfzerbrechen dürfte die Fehlermeldung bereiten, welche trotz (oder wegen?) des
Include Guard aus der folgenden Situation resultiert:._[]

.pull-left[
```
// file: someclass.h
#ifndef SOMECLASS_H
#define SOMECLASS_H
#include "OtherClass.h"
…
class SomeClass {
    …
    OtherClass *link;
};
#endif
```
]

.pull-right[
```
// file: otherclass.h
#ifndef OTHERCLASS_H
#define OTHERCLASS_H
#include "SomeClass.h"
…
class OtherClass {
    …
    SomeClass *link;
};
#endif
```
]

.F[:
In kompilierbarer Form finden Sie die Dateien zu diesem Beispiel unter
[Examples/Cyclic/Broken](../Examples/Cyclic/Broken) und
[Examples/Cyclic/Fixed](../Examples/Cyclic/Fixed) (fehlerbereinigt).
]

---
template: plain
name: definition_reference
header: ### Definition/Reference-Modell

Zu jeder in einem Progamm verwendeten Variablen muss es **genau eine**
Definition geben (mit möglicherweise vielen Bezugnahmen).

* Bei der Bezugnahme aus einer anderen Übersetzungseinheit muss diese eine
  `extern`-Deklaration vornehmen.
* Die tatsächliche Definition **darf** das Wort `extern` enthalten, auch
  wenn sie mit einer Initialisierung verbunden ist.
* Sie **muss** dies eventuell._[] sogar, wenn eine `const`-Qualifizierung
  verwendet wird und keine `extern`-Deklaration vorausgeht.

.W[
Die Verwendung von `const` auf globaler Ebene **ohne** `extern` impliziert
den Sichbarkeitsschutz gegenüber dem Linker.
]

.F[:
"Eventuell" bedeutet hier, dass die Definition in einer Implementierungsdatei
(`*.cpp`) vorgenommen wurde, aber **für andere Übersetzungseinheiten sichtbar**
sein soll. Zum Hintergrund: Einstmals wurde von Bjarne Stroustrup damit das Ziel
verfolgt, in Header-Files(!) eine möglichst unproblematische Umstellung von
`#define`-s auf `const` zu unterstützen. Das Risiko von Name Clashes in der
Link-Phase wurde mit der Regel ausgeschlossen, dass "`const` quasi `static`
impliziert … mit dem Nachteil, dass globale Konstanten evtl. mehrfach im
Speicher gehalten werden. (Bei einfachen Datentypen können optimierende
Compiler dies wiederum vermeiden, indem sie für solche Konstanten – solange
deren Addresse nicht verwendet wird – überhaupt keinen Speicherplatz anlegen.)
]

---
template: plain
name: const_protection
header: ### Schreibschutz durch den Compiler (`const`)

Mittels `const`-Qualifizierung wird die Zuweisung eines (neuen) Werts an eine
Variable verboten. Es ist nur noch die Initialisierung bei der Definition
möglich bzw. ohne `extern` auch erforderlich.

```
const int x = 42;              // Initialisierung notwendig
extern const unsigned VERSION; // nur Bezugnahme
```

Folgendes führt nun zu einem Compile-Fehler:._[]
```
++x;
```
Oder auch:
```
if (VERSION = 3014u) {
    // special case for version 3.14
    …
}
```

.F[:
Abhängig von der Art der Variablen und den Möglichkeiten der Hardware ist für
`const`-qualifizierte Variablen eventuell auch ein physikalischer Schreibschutz
möglich.
]

---
template: plain
name: reference_types
header: ## Zeiger und Referenzen

--------------------------------------------------------------------------

* [Zeiger allgemein und `const`-qualifiziert	](#const_pointers)
* [Klassische Referenzen (Lvalue-Referenzen)	](#classic_references)
* [Zeiger versus Referenzen			](#pointer_vs_reference)
* [Rvalue-Referenzen (neu in C++11)		](#rvalue_reference)

--------------------------------------------------------------------------

---
template: plain
name: const_pointers
header: ### Zeiger allgemein und `const`-qualifiziert

```
int *p1;       // pointer and pointed-to memory are modifiable
p1 = …;        // OK
*p1 = …;       // OK (assuming p1 points to valid memory now)
```
Bei Zeigern kann sich `const` **auf den Zeiger selbst** beziehen …
```
int *const p3 = …; // must be initialized (with address of an int)
p3 = …;            // ERROR (would modify pointer itself)
*p3 = …;           // OK (modifies pointed-to memory location)
++*p3;             // OK (increments pointed-to memory location)
++p3;              // ERROR (would increment pointer itself!) 
```
… oder auf das, was **über den Zeiger erreichbar** ist:._[]
```
const int *p2; // same as: int const *p2;
p2 = …;        // pointer is still modifiable, but ...
*p2 = …;       // ... ERROR at compile-time!
```

.F[:
Of course, both kinds of `const`-qualification may be combined if it makes sense
for a given purpose, e.g. `const int *const p4 = …;` (or – switching positions
of the qualification and the type to which it is applied:
`int const *const p4 = …;`).
]

---
template: plain
name: classic_references
header: ### Klassische Referenzen (Lvalue-Referenzen)

Das klassische Beispiel ist eine Funktion, welche die Inhalte zweier Variablen
vertauscht:

.pull-left[
```
void swap(int *p, int *q) {
    const int t = *p;
    *p = *q;
    *q = t;
}
…
int a, b;
…
if (a > b) swap(&a, &b);
…
```
]

.pull-right[
```
void swap(int &r, int &s) {
    const int t = r;
    r = s;
    s = t;
}
…
int a, b;
…
if (a > b) swap(a, b);
…
```
]

In der linken Version werden Zeigerargumente verwendet und explizit Adressen
übergeben, in der rechten sind die Argumente Referenzen. Der Unterschied besteht
aber nur in der sparsameren Notation im Quelltext (mit Referenzen) – es kann
identischer Maschinencode erzeugt werden.._[]

.F[:
Though there is no rule to enforce this. E.g. depending on compile time debug
options different security checks could be generated for pointers and
references.
]

---
template: plain
name: reference_initialisation
header: #### Initialisierung von Referenzen

Da Referenzen konzeptionell stets vorhandenen Speicherplatz bezeichnen,._[]
müssen sie zwingend initialisiert werden.

.N[
Eine Referenz kann nach Definition und Intialisierung nicht mehr so verändert
werden, dass sie auf eine andere Speicherstelle verweist.
]

Insofern entsprechen Referenzen den konstanten Zeigern, die selbst nicht
veränderbar sind, wohl aber der über sie erreichbare Speicherplatz.

```
int v1, v2;  // some variables ...
int &r = v1; // rerefence is intialized
```
Das folgende führt **nicht** zu einem Fehler bei der Kompilierung, es führt aber
auch nicht dazu, dass `r` nun die Variable `v2` referenziert:
```
r = v2;  // copies current content of v2 to v1 (referenced by r)
```

.F[:
Not considering some artistic ways of initialisation to deliberately subvert
this property of a reference (like `T &r = *reinterpret_cast<T*>(0);`), an
invalid reference might be created by accident when a dereferenced pointer is
used to initialize a reference without prior checking: `T *p = 0; … T &r = *p`;
]

---
template: plain
name: const_reference
header: #### Konstante Referenzen

Die `const`-Qualifizierung bezieht sich bei der Referenz auf den darüber
möglichen Zugriff:

* Im Allgemeinen kann über eine Referenz angesprochener Speicherplatz gelesen
  und verändert werden.

* Über eine `const`-qualifizierte Referenz sind nur Lesezugriffe möglich.

Im folgenden Beispiel kann die Variable `v` zwar direkt und bei Zugriff über
`r1` verändert werden, nicht aber beim Zugriff über `r2`:
```
T v;
T &r1 = v;       // r1 now refers to content of v
const T &r2 = v; // r2 also refers to content of v
…
r1 = …; // OK (actually changes v)
r2 = …; // ERROR (at compile time)
```

Lesender Zugriff ist natürlich sowohl über `r1` wie auch über `r2` möglich.._[]

.F[:
It should be obvious that in the light of references a value-tracking compiler
must be careful not to optimise-out *read* memory access with no intervening
*write*: the content of some location might still have been modified through a
different access path.
]

---
template: plain
name: const_correctness
header: #### Achieving the Const-Correctness

The C++ compiler catches constructs that may subvert const-correctness.

.pull-left[

```
const T cv = …;
const T &cr = cv; // OK
T &r = cv;        // ERROR
```
]

.pull-right[

```
const T cv = …;
const T *cp = &cv; // OK
T *p = &cv;        // ERROR
```
]


Aside from the notational there is **no substantial difference** between
pointers and references in the two examples above.._[]

.W[
If the above initialisation would compile, the non-modifiable variable `cv`
might be modified via a non-`const` reference (`r`) or a pointer to non-`const`
memory (`p`).
]

.F[:
GCC usually emits the same machine code for references and pointers, as long as
both are used correctly and semantically equivalent. (To try some examples
easily you may want to go to the following site: http://gcc.godbolt.org)
]

---
template: plain
name: const_ref_args
header: #### Reference Arguments

As reference initialisation occurs when handing arguments to functions, all the
peculiarities and special cases discussed so far will be mostly likely observed
there.

A typical lapse is to forget to add `const` to read-only reference arguments:
```
void foo(double &arg) {
    …
    … // all access to arg is non-modifying
    …
}
```

.pull-left[
Not callable with literal constant or `const`-qualified variable:
```
foo(0.0); // ERROR
double const PI = 3.14;
foo(PI);  // ERROR
```
]

.pull-right[
No temporaries are silently created:._[]
```
int x = 42;
foo(x);    // ERROR
foo(2*PI); // ERROR
```
]

.F[:
The reason is to avoid surprising effects that would occur especially if a
temporary were created for type coercion, and modifications were then applied to
the temporary only but not to the variable actually used as argument (though it
was "obviously" handed over by reference). 
]

---
template: plain
name: pointer_vs_reference
header: ### Zeiger versus Referenzen

C++ Referenzen können auf zwei Arten betrachtet werden:

* Eine alternative Syntax für Zeiger, welche

  * die Dereferenzierung bei der Verwendung impliziert  
    (also "`*`" automatisch vorangestellt);

  * bzw. den Adress-Operator bei der Initialisierung  
    (also "`&`" automatisch vorangestellt).

* Oder aber einen Alias-Name für bereits (an anderer Stelle) existierenden,
  typisierten Speicherplatz.

.N[
Der für Zeiger und Referenzen erzeugte Maschinen-Code unterscheidet sich in
der Regel nicht – unterschiedlich ist nur die Syntax bei Initialisierung und
beim Zugriff auf das, was referenziert wird.._[]
]

.F[:
Der Nachweis ist bei `g++` durch Erzeugung des Assembler-Codes möglich, wozu die
Option "`-S`" (Großbuchstabe) anzugeben und das Resultat dann in einer Datei mit
Suffix "`.s`" (Kleinbuchstabe) zu finden ist.
]

---
template: plain
name: rvalue_reference
header: ### Rvalue-Referenzen

[Rvalue-Referenzen]: http://en.cppreference.com/w/cpp/language/reference

Mit C+11 neu eingeführt wurde das Konzept der [Rvalue-Referenzen]. Sie lassen
sich nur mit Ausdrücken initialisieren, also *temporären Werten*, auf die dann
kein anderer Zugriff als über die Referenz besteht.

Nachfolgend zusammengefasst die wichtigsten Regeln:._[]
```
T &r = …;          // … must be modifiable T in memory
const T &cr = …;   // … must be modifiable T in memory OR
                   //        non-modifiable T in memory OR
                   //        temporary T in memory (expression)
T &&rr = …;        // … must be temporary T in memory (expression)
```

.N[
Die Hauptanwendung liegt beim Überladen von Funktionen für unterschiedliche
Herkunft von Argumenten, und dort wiederum insbesondere bei
[Kopier-Konstruktor und -Zuweisung](#copy_ctor_assign), denen damit
[Move-Varianten](#move_ctor_assign) zur Seite gestellt werden können.
]

.F[:
In dem für die obige Szenarien typischen Fall von Funktionsargumenten kann bei
einer Rvalue-Referenz – anders als bei einer klassischen `const`-Referenz – das
übergebene Argument modifiziert werden. Die Freiheit, dies zu tun, reicht
allerdings nur so weit, dass der Destruktor nach wie vor korrekt funktionieren
muss!
]

---
template: plain
name: static_polymorphism
header: ## Statischer Polymorphismus

--------------------------------------------------------------------------

* [Defaultwerte für Argumente		](#default_arguments)
* [Überladen von Funktionen		](#overloading_functions)
* [Überladen von Operatoren		](#overloading_operators)

--------------------------------------------------------------------------

Defaultwerte für Argumente wurden in diesen Abschnitt aufgenommen, da ihre
Wirkung mit dem Überladen von Funktionen konkurriert.._[]

.F[:
Aus Hardware-Sicht ist die Implementierung bei echten Funktionen (ohne `inline`)
allerdings unterschiedlich.
]


---
template: plain
name: default_arguments
header: ### Defaultwerte für Argumente

Argumente können "von rechts nach links" mit Default-Werten versehen werden,
das heißt:

* Sobald ein Argument einen Default-Wert hat,
* müssen alle rechts davon stehenden ebenfalls einen haben.

.N[
Der Defaultwert muss beim Funktionsaufruf bekannt sein, ist also Bestandteil des
Funktions-Prototyps und steht ggf. zusammen mit diesem in einem Header-File.
]

Die Namen für die formalen Argumente sind auch in diesem Fall optional:._[]
```
// the following function can be called with 1..3 arguments:
double foo(int &count, int minsize = 0, char separator = 'z');
…
// same as:
double foo(int &, int = 0, char = 'z');
```

.F[:
Using names for arguments in prototypes has pro's and con's: it is of course
more self-documenting but there is at least a remote chance for surprising and
**extremely hard to find** name clashes with preprocessor macros. Hint: view
preprocessor output (`g++ -E …`) whenever you get desparate because of an
completely unexplainable syntax error in your source code.
]

---
template: plain
name: overloading_functions
header: ### Überladen von Funktionen

Mehrere Funktionen gleichen Namens können parallel existieren sofern sie sich in
Anzahl und/oder Typ ihrer Argumente unterscheiden:._[]
```
void foo(const char *);         /*1*/
double foo(const int &, char);  /*2*/
double foo(double, double);     /*3*/
```
.N[
Welche Funktion aufgerufen wird (oder der Aufruf mehrdeutig ist),
entscheidet der Compiler gemäß den tatsächlichen Argumenten.
]
```
int x; double y;
…
foo("hello, world");   /*calls 1*/
foo(42, 'z');          /*calls 2*/
foo(y, y/2);           /*calls 3*/
foo(x, y);             /*calls ?*/
```

.F[:
If one argument list is from left to right an exact subset of another one, the
overall effect is similar to default values for arguments. But with overloading
there are as many separate entry points as there are functions, while with
default arguments there is just one entry point and missing argument values are
automatically supplied.
]

---
template: plain
header: #### Überladen bei Parametern mit ohne `const`

Auch die `const`-Qualifizierung eines Parameters macht einen Unterschied:
.pull-left[
In Fortsetzung des Beispiels von der vorhergehenden Seite:
```
char data[100];
…
foo(data); /*1*/
```
]

.pull-right[
Mit **Erweiterung** dieses Beispiels:
```
void foo(char *); /*4*/
extern const char greet[]; 
…
foo(data);  /*4*/
foo(greet); /*1*/
```
]

Existiert nur eine der beiden Funktionen (die sich voneinander nur in der
`const`-Qualifizierung eines Parameters unterscheiden), so gilt:

* Existiert **allein** die Funktion für den konstanten Fall, wird sie **auch**
  für modifizierbare Argumente verwendet.._[]

* **Ohne** die Funktion für den konstanten Fall führt der Aufruf mit einem
  nicht-modifizierbaren Argument zum **Compile-Fehler** (im Beispiel etwa
  `foo("hi")`, wenn nur Version `/*4'/` aber nicht `/*1*/` existiert).

.F[:
Es ist kein Problem einer Funktion, die verspricht, den Inhalt einer über ein
Zeiger- oder Referenz-Argument erreichbaren Variablen nicht zu verändern,
Zugriff auf (prinzipiell) veränderbaren Speicherplatz zu geben – **wohl aber
umgekehrt!**
]

---
template: plain
name: overloading_operators
header: ### Überladen von Operatoren

[Boost.Operators]: http://www.boost.org/doc/libs/1_55_0/libs/utility/operators.htm

Operatoren._[] können überladen werden mit Funktionen, deren Name mit dem Wort
`operator` beginnt.

* Die meisten Operatoren können wahlweise mit freistehenden Funktionen oder mit
  Member-Funktionen überladen werden.

* An der Überladung muss aber mindestens eine Klasse beteiligt sein.._[]

* Einige Operatoren sind hinsichtlich der Überladung auf Member-Funktionen
  eingeschränkt.

* Zur konsistenten Überladung ganzer Operatorgruppen kann [Boost.Operators]
  hilfreich sein.

Weiterführende Links:

* http://en.cppreference.com/w/cpp/language/operators
* http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm

.F[:
Therefore the meaning of operators for builtin-types cannot be changed. If you
want to come close to the behaviour of a given builtin types but change or
remove some predefine operations, you will typically have to **add** a new class
and implement all the operations it should support.
]

---
template: plain
header: #### Operator-Überladung mit freistehender Funktion

Diese sieht prinzipiell so aus:
```
MyClass operator+(const MyClass &lhs, const MyClass &rhs) {
    … // do whatever must be done
    return …;
}
```

Der Rückgabetyp ist dabei beliebig, die `return`-Anweisung muss natürlich vom
Typ her passend sein.

Genauer gesagt, der Ausdruck hinter `return` muss

* entweder exakt den Rückgabetyp haben (`MyClass` im Beispiel)

* oder in diesen umwandelbar sein.

---
template: plain
header: #### Operator-Überladung mit Member-Funktion

Diese sieht prinzipiell so aus:
```
MyClass &MyClass::operator+=(const MyClass &rhs) {
    … // do whatever must be done
    return *this;
}
```

Auch hier ist der Rückgabetyp grundsätzlich frei wählbar.

.N[
Gemäß den Konventionen bei eingebauten Typen wird in der Regel das durch die
Operation gerade veränderte Objekt selbst zurückgegeben.
]

Die Rückgabe erfolgt typischerweise als Referenz (sonst wäre es auch nicht das
Objekt selbst sondern nur eine identische Kopie).

Da dies technisch gesehen nur Weitergabe einer Adresse bedeutet, ist es

* performant (z.B. Rückgabe in Register) und
* nahezu frei von Overhead bei Nichtbenutzung._[]

.F[:
Also, for an optimizing compiler there is a fair chance to remove any remaining overhead …
]

---
template: plain
name: copy_ctor_assign
header: #### Überladung von Kopier-Konstruktor und -Zuweisung

[Rule Of Three]: http://en.cppreference.com/w/cpp/language/rule_of_three

Für einige Arten von Objekten müssen diese Operationen überladen werden, da
der Default – elementweises Initialisieren bzw. Zuweisung – ungeeignet ist.._[]
```
class MyClass {
    T *some_ptr;
    …
public:
    …
    // avoid compiler defaults:
    MyClass(const MyClass& rhs);
    MyClass& operator=(const MyClass& rhs);
}
```

.N[
Der klassische Indikator sind als Member-Daten enthaltene Zeiger auf
Speicherplatz, welcher individuell für jedes Objekt vorhanden sein muss.._[]
]

.F[:
In C++ books this is often referred to as [Rule of Three] – the third member
function for which the default is not appropriate is the destructor, of course.
]

---
template: plain
name: move_ctor_assign
header: #### Überladung von Move-Konstruktor und -Zuweisung

[Rule Of Five]: http://en.cppreference.com/w/cpp/language/rule_of_three

In C++11 können die [Rvalue-Referenzen](#rvalue_ref) dazu verwendet werden,
abhängig davon, ob der dabei als Operand auftretende Ausdruck

* direkt ein Objekt repräsentiert, das danach unverändert im Speicher weiter
  existiert, oder
* temporären Speicherplatz, der ohnehin im Anschluss verworfen wird (z.B. für
  einen berechneten Ausdruck oder ein Funktionsergebnis),

Initialisierung wie auch Zuweisung unterschiedlich zu implementieren.._[]

```
class MyClass {
public:
    …
    // copy versions (rhs lives on in memory)
    MyClass(const MyClass& rhs);
    MyClass& operator=(const MyClass& rhs);
    // move versions (rhs destroyed soon after)
    MyClass(MyClass&& rhs);
    MyClass& operator=(MyClass&& rhs);
}
```

.F[:
Turning the classic C++ *Rule of Three* into the [Rule of Five] in C++11.
]

---
template: plain
name: move_ctor_assign
header: #### Implementierung von Move-Konstruktor/Zuweisung

Nachdem Move-Versionen deklariert sind, müssen diese natürlich auch
implementiert werden.

Wenn der Kopierkonstruktor wie folgt aussieht …
```
MyClass::MyClass(const MyClass &rhs)
    : …, some_ptr(new T(*rhs.some_ptr)), …    // cloning resource
{ … }
```

… könnte dieser Move-Konstruktor angemessen sein:
```
MyClass::MyClass(MyClass &&rhs)
    : …, some_ptr(rhs.some_ptr), …    // taking over resource
{ …; rhs.some_ptr = nullptr; … }      // INVALIDATING it for rhs!
```

.N[
Die Zuweisungen sind ähnlich, müssen aber zuerst `some_ptr` freigeben.._[]
]

.F[:
The general difference between constructor and assignment is that the former
gets just a piece of memory while the later finds a valid object that needs
to be properly de-constructed first.
]

---
template: plain
header: #### Unterscheidung Copy- und Move-Versionen

Existieren beide Fassungen (Copy und Move), ergibt sich folgendes Verhalten:._[]

```
MyClass foo() { return …; }  // … must be an expression of
                             // type MyClass (or something
                             // convertible to MyClass)
// constructor use:
MyClass a;        // (expects c'tor with no argumens)
MyClass b(a);     // copy c'tor (does not modify a)
MyClass c(foo()); // move c'tor (may modify temporary)

// assignment use:
a = c;            // copy assignment (does not modify c)
b = foo();        // move assignment (may modify temporary)
c = a + b;        // move assignment (may modify temporary
                  //                  returned from operator+)
```

.F[:
Of course, adding operands of type `MyClass` in the last line of the example
also assumes `operator+` exists and returns by value, as is the usual behaviour.
In the (unusual) case that operator were defined but returns something that C++
considers to be "more persistant" (like a reference), copy assignment would be
used instead, though a move could be enforced then: `c = std::move( … );`
]

---
template: plain
name: type_conversions
header: ## Typ-Kompatibilität und -Konvertierungen

--------------------------------------------------------------------------

* [Typ-Kompatibilität bei grundlegenden Typen	](#basictype_typeconv)
* [Typ-Kompatibilität und Vererbung 		](#public_base_typeconv)
* [Explizite Typ-Konvertierung mittels *Cast*	](#explicit_typeconv)
* [Klassenspezifische Typ-Konvertierung		](#specified_typeconv)
* [Typ-Sicherheit generell			](#general_typesafety)

--------------------------------------------------------------------------

---
template: plain
name: basictype_typeconv
header: ### Typ-Kompatibilität bei grundlegenden Typen

Die wichtigsten Regeln für Typ-Kompatibilität und ggf. automatisch angewendete
Typ-Konvertierungen sind hier:

* Alle *arithmetischen Typen* sind miteinander kompatibel bzw. werden bei Bedarf
  entsprechend umgewandelt.._[]

* Ansonsten finden bei Bedarf folgende Umwandlungen statt:

  * Aufzählungstypen (`enum`) **→** arithmetische Typen;
  * Zeiger **→** Wahrheitswerte (alles außer `nullptr` ist `true`);
  * typisierter Zeiger **→** allgemeine Zeiger (`void *`).

.I[
Innerhalb der arithmetischen Typen erfolgt die Umwandlung soweit möglich
**wert-erhaltend** und wird eventuell mit auszuführenden Maschinenbefehlen
verbunden sein.
]

Inwieweit dies auch für die anderen, oben aufgezählten Fälle gilt, hängt von
Hardware-Details ab, insbesondere der Repräsentation von Aufzählungstypen und
Zeigern.

.F[:
Dies schließt auch `char` (mitunter verwendet für kleine Ganzzahlen) und `bool`
(Wahrheitswerte) ein.
]

---
template: plain
header: #### Typ-Kompatibilität bei grundlegenden Typen (2)

* Außerhalb der Umwandlungen zwischen arithmetischen Typen handelt es sich um
  **einseitig gerichtete** Umwandlungen.

* D.h. es gibt **keine automatische Umwandlung** in den folgenden Fällen:

  * von arithmetischen Typen in Aufzählungstypen (`enum`);
  * von Wahrheitswerten in Zeiger;
  * **von allgemeinen Zeigern in typisierte Zeiger**.

Mit dem letzten Punkt wurde die [Typ-Sicherheit von C++](#general_typesafety)
gegenüber C an einer kritischen Stelle verbessert.._[]

.I[
Anders als in C kann in C++ auf dem Umweg über allgemeine Zeiger (`void *`)
keine "stille" Typ-Konvertierung typisierter Zeiger erfolgen.
]

.F[:
Der Grund für das andere Verhalten in C liegt bei der `malloc`-Funktionsfamilie
in der C-Bibliothek, die gemäß dem C89-Standard den Ergebnistyp `void *` hat.
In C wollte man so die die Notwendigkeit von Cast-Operationen für `malloc`
etc. vermeiden. Da in C++ `new` ein Operator ist, entfällt diese Problematik.
]

---
template: plain
name: public_base_typeconv
header: ### Typ-Kompatibilität und Vererbung

[Slicing]: http://www.geeksforgeeks.org/object-slicing-in-c/

* Ein **Zeiger** auf eine öffentlich abgeleitete Klasse ist kompatibel mit einem
  **Zeiger** auf eine ihrer direkten oder indirekten._[] Basisklassen.

* Ein **Referenz** auf eine öffentlich abgeleitete Klasse ist kompatibel mit
  einer **Referenz** auf eine ihrer direkten oder indirekten._[] Basisklassen.

* Basierend auf **Objekten** einer öffentlich abgeleiteten Klasse werden ggf.
  automatisch – per [Slicing] – **Objekte** direkter oder indirekter._[]
  Basisklassen initialisiert.

.I[
Außer bei Mehrfachvererbung sind die ersten beiden Fällen in der Regel **nicht**
mit auszuführenden Maschinenbefehlen verbunden.
]

.F[:
Für indirekte nicht-virtuelle Basisklassen im Fall von Mehrfachvererbung mit
rautenförmigen Klassenbeziehungen (in der UML als "«disjoint»" annotiert) gilt
dies nicht, da in diesem Fall die automatische Konvertierung mehrdeutig wäre.
]

---
template: plain
name: public_base_lsp
header: #### Öffentliche Basisklassen und LSP

[Principle of Substitutibility]: http://dictionary.reference.com/browse/liskov+substitution+principle

Die auf der vorhergehenden Seite zusammengestellten Regeln sind Ausdruck dessen,
was Barbara Liskov seinerzeit als

* "*[Principle of Substitutibility]*"

für die Objekt-Orientierte Programmierung als forderte und was seitdem oft als
LSP abgekürzt wird.

.N.center[
Das LSP gilt in C++ nur im Fall öffentlicher Basisklassen.

**Nur nur hier liegt Vererbung im Sinne der OOP vor.**
]

Vererbung._[] wird auch *Generalisierung-Spezialisierung* genannt und in der
UML-Darstellung durch eine Verbindungslinie mit nicht ausgefülltem Dreieck am
auf die Basisklasse weisenden Ende spezifiziert.

.F[:
To be clear once more: what is discussed here is a class relation that implies
substitutibility according to the LSP. As inheritance is at the heart of
object-oriented modelling and programming, it will be covered in more depth
later ([see Wednesday Part 1 Inheritance](05_wednesday1.html#inheritance)).
]

---
template: plain
name: private_base_no_lsp
header: #### Private Basisklassen (kein LSP)

Öffentliche und private Basisklassen in C++

* verwenden zwar ein und dasselbe Speicher-Layout,

* **bei privaten Basisklassen gilt das LSP jedoch nicht**.

.N[
Im Sine der OOP handelt es sich bei letzteren somit nicht um Vererbung sondern
um Komposition.
]

Komposition ist ein Sonderfall der Aggregation._[] und wird in der
UML-Darstellung durch eine Verbindungslinie mit ausgefüllter Raute am auf die
Klasse des Aggregats weisenden Ende spezifiziert.

.F[:
The special case is that the lifetime of the *part* is coupled to that of the
aggregate. As composition is very important in object-oriented modelling and
there are various ways to implement it in C++, it will be covered in more depth
later ([see Wednesday Part 1 Aggregation](05_wednesday1.html#aggregation)).
]

---
template: plain
name: explicit_typeconv
header: ### Typ-Konvertierung mittels *Cast*

[Cast-Operation]: http://www.cplusplus.com/doc/tutorial/typecasting/

Mittels sogenannter [Cast-Operation]en lassen sich weitere Typ-Konvertierungen
erzwingen.

.W[
Die Cast-Syntax von C, bei welcher man den Zieltyp in runde Klammern einschließt
und den umzuwandelnden Wert direkt dahinter schreibt, sollte in C++ vermieden
werden.
]

Die neue Syntax beginnt mit einem der Schlüsselworte

* [`static_cast`](#static_cast_typeconv)
* [`dynamic_cast`](#dynamic_cast_typeconv)
* [`const_cast`](#const_cast_typeconv)
* [`reinterpret_cast`](#reinterpret_cast_typeconv)

Es folgen der Zieltyp in spitzen Klammern und der umzuwandelnde
Wert in runden Klammern.._[]

.F[:
As an example consider the use of C-style memory allocation for some `struct s`
in C++.  
```
struct s *p = static_cast<struct s*>(std::malloc(sizeof (struct s))); // required conversion in C++
          … (struct s*) std::malloc(sizeof (struct s)); // C-style cast, possible but deprecated in C++
                     
```
]

---
template: plain
name: static_cast_typeconv
header: #### Typ-Konvertierung mit `static_cast`

Hiermit lassen sich zum einen Typ-Konvertierungen explizit hervorheben, welche
der Compiler auch automatisch vorgenommen hätte.._[]

Darüberhinaus funktioniert der `static_cast` in **beide** Richtungen für
diejenigen Typ-Konvertierungen, welche **automatisch** nur in einer Richtung
eingesetzt werden:

* Arithmetische Wert **→** Aufzählungstypen (`enum`)

  * automatisch nur Aufzählungstypen in arithmetische Werte

* Generische Zeiger (`void *`) **→** typisierte Zeigern

  * automatisch nur typisierte in generische Zeiger

* Basisklassen in abgeleitete Klassen (Downcast)

  * automatisch nur abgeleitete Klassen **→** Basisklassen (Upcast)

.F[:
The most typical reason for this is that many compilers will issue a warning
when an arithmetic conversions might not be value preserving, e.g. when an
64-bit integral value is assigned to a 32 bit integral variable. If this is
done with a cast, most compilers will suppress the warning.
]

---
template: plain
name: dynamic_cast_typeconv
header: #### Typ-Konvertierung mit `dynamic_cast`

[`std::bad_cast`]:     http://en.cppreference.com/w/cpp/types/bad_cast
[Laufzeit-Typprüfung]: 04_wednesday2.html#dynamic_cast

Hiermit lassen sich ausschließlich Typ-Konvertierungen innerhalb von
Klassenhierarchien vornehmen.

.N[
Im Fall von Downcasts findet zur Laufzeit eine Überprüfung mit Fehleranzeige
statt, wenn der Cast nicht durchführbar ist.._[]
]

Die Fehleranzeige besteht

* bei **Casts auf Zeigerbasis** in der Rückgabe eines Nullzeigers;

* bei **Casts auf Referenzbasis** in einer [`std::bad_cast`]-Exception.

Weiteres wird später im Rahmen der [Laufzeit-Typprüfung] (RTTI) behandelt.

.F[:
Der Grund für die eventuelle Undurchführbarkeit muss zusammen mit der
Typ-Kompatibilität zwischen Basisklassen und abgeleiteten Klassen gesehen
werden: Gemäß [LSP](#public_base_lsp) kann ein Zeiger oder eine Referenz, der
bzw. die als Zeiger oder Referenz für eine Basisklasse definiert ist, auch ein
Objekt einer davon abgeleiteten Klasse referenzieren. Ob dies der Fall ist,
lässt sich mit `dynamic_cast` überprüfen und mittels des auf diese Weise ggf.
erhaltenen Zeigers (bzw. der so erhaltenen Referenz) besteht schließlich
Zugriff auf die von der abgeleiteten Klasse hinzugefügten Member-Daten und
-Funktionen.
]

---
template: plain
name: const_cast
header: #### Typ-Konvertierung mit `const_cast`

Die hiermit möglichen Typ-Konvertierungen beschränken sich auf das

* Hinzufügen oder
* Wegnehmen

von `const` und `volatile`.

Alle anderen Unterschiede zwischen dem Zieltyp und dem Typ des umzuwandelnden
Ausdrucks führen zu einem Compile-Fehler.

.W[
Ein `const_cast` hat gemäß dem C++-Standard undefiniertes Verhalten, wenn er
dazu führt, dass auf eine mit Schreibschutz definierte Speicher-Adresse
schreibend zugegriffen wird.
]


Das typische Fehlerbild reicht von der inkonsistenten Wertverwendung (teilweise
alter Wert, teilweise neuer Wert) bis zum Programmabsturz …._[]

.F[:
Abhängig von der Testtiefe, dem verwendeten Compiler, Optimierungs-Optionen usw.
mag es allerdings auch so erscheinen, als würde alles wie gewünscht funktionieren.
]

---
template: plain
name: reinterpret_cast
header: #### Typ-Konvertierung mit `reinterpret_cast`

  [Boost.Variant]: http://www.boost.org/doc/libs/1_57_0/doc/html/variant.html

Dieses Konstrukt wird vor allem dazu eingesetzt, Zeiger auf (bekannte)
Hardware-Adressen zu setzen, wie das u.a. im Bereich der Embedded Progammierung
und bei Gerätetreibern notwendig sein kann.._[]

.F[:
Dass es per `reinterpret_cast` möglich ist, quasi jedes Bitmuster im Speicher
gemäß jedem beliebigen Typ zu interpretieren, führt mitunter zu der Kritik, C++
sei keine "sichere" Programmiersprache. Diese Kritik müsste dann aber für alle
Sprachen gelten, die ein zur C/C++ `union` vergleichbares Konstrukt besitzen …
(zumindest solange kein automatisches "type-tagging" wie bei [Boost.Variant]
erfolgt).
]

Darüber hinaus kann man mit einem `reinterpret_cast`

* **wie auch per `static_cast`** generische Zeiger (`void *`) in typisierte Zeiger
  umwandeln, und

* **anders als per `static_cast`** typisierte Zeiger **direkt** in anders
  typisierte Zeiger umwandeln.

.N[
Es ist dagegen auch mit `reinterpret_cast` nicht möglich, die `const`- und
`volatile`-Qualifizierung zu ändern – dies erlaubt nur der `const_cast`.
]

Um beide Konvertierungen zu kombinieren, müssen die jeweiligen Cast-Konstrukte
ggf. nacheinander (oder geschachtelt) verwendet werden.

---
template: plain
name: reinterpret_cast_examples1
header: #### Typ-Konvertierung mit `reinterpret_cast` (Beispiel 1)

Das folgende Beispiel nimmt an, dass an der Speicheradresse `0xEAD0` die als
`struct uart` beschriebenen Kontrollregister abgebildet sind:
```
struct uart *const sio = reinterpret_cast<struct uart*>(0xEAD0);
```
Der Zugriff kann nun in der Syntax `sio->…` erfolgen.

Gibt es mehrere solche Register-Strukturen im Speicher (als Memory-Mapped-I/O)
abgebildet, kann natürlich auch ein Array initialisiert
```
struct uart *const sio[] = {
    reinterpret_cast<struct uart*>(0xEAD0),
    reinterpret_cast<struct uart*>(0xEAD8),
    …
};
```
und über dieses mit `sio[0]->…`, `sio[1]->…` usw. zugegriffen werden.

.F[:
Wird statt dem Pfeil die Punkt-Notation bevorzugt, geht das auch, und zwar mit:
```
struct uart &sio = *reinterpret_cast<struct uart*>(0xEAD0);
```
]

---
template: plain
name: reinterpret_cast_examples2
header: #### Typ-Konvertierung mit `reinterpret_cast` (Beispiel 2)

  [C++ Calling Conventions]: 06_wednesday2.html#calling_conventions

Das folgende Beispiel nimmt an, dass an der Adresse `0xCAFE` im Code-Segment

* ein Unterprogramm (gemäß [C++ Calling Conventions]) steht,
* welches ein Argument vom Typ `bool` erwartet und
* keinen Rückgabewert liefert.

```
void (*xcall)(int) = reinterpret_cast<void (*)(int)>(0xCAFE);

```
Der tatsächliche Aufruf kann nun so erfolgen:
```
xcall(true);
…
xcall(false);
```
erfolgen.._[]

.F[:
Of course, if there is a value returned supplied (according to the C++ calling
conventions) and specified in the declaration, it could be accessed in the usual
way.
]

---
template: plain
name: specified_typeconv
header: ### Klassenspezifische Typ-Konvertierungen

Eine Klasse kann auch festlegen, wie ihre Objekte bei Bedarf automatisch **aus**
eingebauten Typen und anderen Klassen erzeugt bzw. **in** solche konvertiert
werden können. Dazu folgende Analogie:

* Jede Klasse und jeder eingebaute Typ hat eine spezifische Art von *Ein- und
  Ausgangs-Steckverbindern*, die nur "zu sich selbst" passt.

  * In Initialisierungen und Zuweisungen sind daher zunächst nur Objekte von
    genau dieser Klasse bzw. diesem Typ verwendbar.._[]

* **Konstruktoren mit exakt einem Argument** – sofern nicht als `explicit`
  markiert – sind weitere *Eingangs*-Steckverbinder.

  * Sie passen zum *Ausgangs*-Steckverbinder des Argument-Typs.

* **Typ-Cast-Operatoren** sind weitere *Ausgangs*-Steckverbinder.

  * Sie passen zum *Eingangs*-Steckverbinder des Ziel-Typs.

.F[:
If you like that picture you may include base class conversions by assuming
plugs and sockets with the same basic shape for class hierarchies, using code
pins to make the output connector of a derived class fit into the input connector
of its base class(es), but not vice versa. (For standard conversions of basic
types assume a set of adapter plugs that are applied as necessary.)
]

---
template: plain
name: constructor_conversion
header: #### Typ-Konvertierungen durch Konstruktoren

Konstruktoren sind dann automatische Typ-Konvertierungen, wenn sie

* genau ein Argument besitzen und

* **nicht** mit dem Schlüsselwort `explicit` markiert sind.

```
class MyClass {
    …
public:
    MyClass(int);  // each single argument c'tor is an
                   // automatic conversion ... except
    explicit MyClass(double);  // it is marked explicit
    …
};
```

---
template: plain
header: #### Anwendung von Konstruktoren zur Typ-Konvertierung

Typ-Konvertierungen durch Konstruktoren kommen wie folgt zur Anwendung:

```
void foo(MyClass);
…
foo(33);            // OK (automatic conversion by c'tor)
foo(3.3)            // ERROR, c'tor is explict
foo(MyClass(3.3));  // OK (c'tor is used explicitly)
…
MyClass x(-1);      // this also work with explicit c'tor but ...
x = 33;             // ... here an automatic conversion is necessary ...
x = 3.3;            // ... so this will fail if there is none
```
.I[
Die Notwendigkeit einer Typ-Konvertierung bei der Zuweisung hängt auch davon
ab, welche zusätzlichen Zuweisung-Operatoren eine Klasse ggf. definiert._[]
]

.F[:
An assignment operator taking **exactly** type of the expression on its right
hand side as argument will be always be preferred (and of course applied without
any need for a conversion). In case the assignment operator takes a
`const MyClass&` argument – as the automatically defined assignment does–, a
temporary will be if there is a non-explicit c'tor or a type-cast operator
applicable as automatic conversion.
]

---
template: plain
header: #### Temporäre Objekte im Rahmen der Typ-Konvertierung

Bei Referenzübergabe ist zusätzlich zu beachten, dass bei der
Konvertierung ein temporäres Objekt notwendig wird:
```
void baz(MyClass &); // non-const reference argument
…
baz(42);                       // ERROR (no automatic temporary
                               //        for non-const reference)
baz(MyClass(42));              // ERROR (c'tor call does not bind
                               //        to non-const reference)
{ MyClass tmp(42); baz(tmp); } // OK
```

Automatisch wird dies nur für `const`-qualifizierte Referenzen erzeugt:
```
void bar(const MyClass &); // const reference argument
…
bar(42);                       // OK (automatic temporary)
```

---
template: plain
name: typecast_operator
header: #### Typ-Konvertierung durch Type-Cast Operatoren

Type-Cast Operatoren benutzen eine spezielle Syntax, bei der **nach** dem
Schlüsselwort `operator` der Zieltyp folgt:._[]
```
class MyClass {
    …
public:
    // this is called type-cast operator:
    operator Other() const { …; return …; } 
                                    // ^-- Other (or at least
                                    //     convertible to Other)

    // the usual explicit alternative:
    int to_int() const { …; return …; }
                                // ^-- int (or at least
                                //     convertible to int)
};
```

.F[:
Dieser stellt zugleich den Ergebnistyp dar, den die `return`-Anweisung liefern
muss.
]

---
template: plain
header: #### Automatische Anwendung von Type-Cast Operatoren

Die Typ-Konvertierungen von der vorhergehenden Seite kommen wie folgt zur Anwendung:
```
void foo(Other);
void bar(int);
…
MyClass m;
foo(m);           // OK, implicit use of type-cast operator
bar(m);           // ERROR (of course), but ...
bar(m.to_int());  // ... usual style for explicit conversion
```

---
template: plain
header: #### Sonderfall: `explicit operator bool()`

Eine als `explicit` markierte Typ-Konvertierung in einen Wahrheitswert stellt einen
Sonderfall dar:

* Sie kommt **nicht** zur Anwendung bei Argumentübergabe, Initialisierung und
  Zuweisung,

* **jedoch bei bool'schen Operationen und Bedingungstests.**

Die Beispiele auf der nächsten Seite setzen folgendes voraus:

```
class MyClass {
    …
public:
    explicit operator bool() {
       return …; // some bool
    }
    …
};
…
MyClass obj;
extern void foo(bool);
```

---
template: plain
header: #### Beispiele: `explicit operator bool()`

Die folgenen Code-Fragmente setzen das begonnene Beispiel fort:

* `#1` zeigt eine etwas ungewöhnliche aber erlaubte Form des Aufrufs der
  Typ-Konvertierung in `bool`.
* `#2a` löst einen Fehler aus, der in einer syntaktische Mehrdeutigkeit
  begründet ist, die das Paar zusätzlicher Klammern in `#2b` beseitigt.
* `#3` ist eine zulässige aber überflüssige explizite Typ-Konvertierung.

.pull-left[
```
// this does NOT compile ...
foo(obj);

bool bv(obj);
bool bv(bool(obj));      //#2a
bv = obj;

if (obj == true) … 
if (obj == false) …
if (obj == bv) …
// ... compare with code on
// the right for corrections

```
]
.pull-right[
```
// this solves the problems:
foo(bool(obj));
foo(obj.operator bool()); //#1

bool bv((bool(obj)));     //#2b
bv = bool(obj);
if (bool(obj)) …          //#3
if (obj) …
if (!obj) …
if (bool(obj) == bv) …
// boolean operators work too:
if (obj && !bv) …
```
]

---
template: plain
name: general_typesafety
header: ### Typ-Sicherheit in C++

Die praktische Konsequenz aus den Risiken, welche die Konstrukte zur
expliziten Typ-Konvertierung – also die vier neuen Cast-Formen von C++
sowie die von C übernommene Cast-Syntax – mit sich bringen, ist diese:

.W[
Alle Formen expliziter Typ-Konvertierung (mit Cast) sollten auf das
unvermeidliche Minimum beschränkt bleiben.
]

Ferner werden [klassenspezifische Typ-Konvertierungen](#specified_typeconv)
manchmal in "unerwarteter Weise" angewendet:._[]

.F[:
Or to put it slightly different: Experience showed there are scenarios of
practical importance where a compile error would have been preferred over
the way the compiler made the code "correct" by applying a (non-explicit)
constructor or type-cast operator.
]

.I[
Eine klassenspezifische Typ-Konvertierung sollte nur dort definiert werden, wo
der stillschweigende Wechsel zwischen den beteiligten Typen als "natürlich"
empfunden wird.
]

---
template: plain
name: exercise_mon1
header: ## Praktikum

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>


