<!DOCTYPE html>
<html>
  <head>
    <title>(1) C++-For - Monday Part 1</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
    <!-- when changing the stylesheet file please see also remark below -->
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies aproximately 2/3 of the page width. So only add
  little information, preferrably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open - add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++ FOR]: 00_content.html#agenda

# [C++ FOR] (Monday Morning)

---------------------------------------------------------------------------

1. [Auffrischung einiger wichtiger Grundlagen	](#cpp_basics)
1. [Zeiger und Referenzen			](#reference_types)
1. [Statischer Polymorphismus			](#static_polymorphism)
1. [Typ-Kompatibilität und -Konvertierung	](#type_conversions)
1. [Praktikum					](#exercise_mon1)

---------------------------------------------------------------------------

Kürzere Pausen werden jeweils nach Bedarf eingelegt.

Falls die Übungsaufgabe nicht wegen eines verkürzten Vormittagsteils
entfällt, erfolgt die Besprechung der Musterlösung(en) im direkten Anschluss
an die Mittagspause.

---
template: plain
name: cpp_basics
header: ## Auffrischung einiger wichtiger Grundlagen

--------------------------------------------------------------------------

* [Getrennte Kompilierung		](#separate_compilation)
* [Definition/Reference-Modell		](#definition_reference)
* [Schreibschutz durch den Compiler	](#const_protection)

--------------------------------------------------------------------------

---
template: plain
name: separate_compilation
header: ### Getrennte Kompilierung

#### Grundlagen der getrennten Kompilierung

[Build-System]: http://en.wikipedia.org/wiki/Build_automation
[Unix `make`]:  http://en.wikipedia.org/wiki/Make_(software)
[Bell Labs]:    http://en.wikipedia.org/wiki/Bell_Labs
[GNU make]:     http://en.wikipedia.org/wiki/GNU_build_system
[CMake]:        http://en.wikipedia.org/wiki/CMake

[Übersetzungseinheiten]: http://en.cppreference.com/w/cpp/language/translation_phases
[Header-Files]: http://www.cplusplus.com/forum/articles/10627/

Ein C++-Programm wird üblicherweise in eine mehr oder weniger große Zahl von
[Übersetzungseinheiten] aufgeteilt.

* Diese stehen in Implementierungsdateien, deren Dateinamens-Suffix meist `.cpp`
  ist.

* Sind ein und dieselben Informationen in mehr als einer Übersetzungseinheit
  notwendig, gehören diese in [Header-Files], deren Dateinamens-Suffix meist
  `.h` ist (seltener: `.hpp`).

.I[
Bereits bei einer kleinen Zahl von Übersetzungseinheiten sind die Abhängigkeiten
zwischen diesen inklusive ihrer Header-Files oft nur noch schwer zu überblicken,
so dass sich die Verwendung eines [Build-System]s empfiehlt.._[]
]

.F[:
Unter den heute verwendeten Build-Systemen hat das 1976 an den [Bell-Labs] von
Stuart Feldman entwickelte [Unix `make`] weitaus mehr als eine nur historische
Bedeutung, in der Kernsyntax sind auch moderne Derivate wie [GNU make] und
[CMake] immer noch identisch zu ihrem Vorbild.
]

---
template: plain
header: #### Abhängigkeiten zwischen Header-Files

Nicht selten kommt es auch zu Abhängigkeiten von Header-Files untereinander,
wenn z.B. in einem Header-File ein Datentyp oder eine Klasse verwendet wird,
die in einem anderen Header-File definiert ist.

.N[
In solchen Fällen ist es üblich, im abhängigen Header-File den als Voraussetzung
erforderlichen zweiten Header-File direkt zu inkludieren.
]
.pull-left[
```
// header file: Base.h
class Base {
    …
};
```
]
.pull-right[
```
// header file: Derived.h
#include "Base.h"
class Derived : public Base {
    …
};
```
]

---
template: plain
header: #### Include-Guards

[Include-Guard]: http://gcc.gnu.org/onlinedocs/cppinternals/Guard-Macros.html
[One Definition Rule (ODR)]: http://en.cppreference.com/w/cpp/language/definition

Da ein und derselbe Header-File oft auf verschiedenen Wegen inkludiert wird,
muss die **mehrfache Verarbeitung**._[] ausgeschlossen werden. Dies geschieht
mit sogenannten [Include-Guard]s:

.pull-left[
```
// header file: Base.h
#ifndef BASE_H
#define BASE_H
class Base {
    …
};
#endif
```
]
.pull-right[
```
// header file: Derived.h
#ifndef DERIVED_H
#define DERIVED_H
#include "Base.h"
class Derived : public Base {
    …
};
#endif
```
]

.F[:
Der Grund hierfür liegt vor allem in der [One Definition Rule (ODR)], welche
die wiederholte Einführung von Bezeichnern stark einschränkt.
]

---
template: plain
header: #### Namespaces

Wie das folgende Beispiel deutlich macht, ist der Klassenname für sich allein
als Include-Guard u.U. problematisch:

.pull-left[
```
#ifndef SOMECLASS_H
#define SOMECLASS_H
namespace Mine {
    class SomeClass {
        …
    };
}
#endif
```
]

.pull-right[
```
#ifndef SOMECLASS_H
#define SOMECLASS_H
namespace Other {
    class SomeClass {
        …
    };
}
#endif
```
]

Wenn jetzt beide Files inkludiert werden, macht der erste den Inhalt des zweiten
quasi "unsichtbar" … was aber vermutlich erst nach einer überaus langwierigen
Fehlersuche offenbar wird.

.W[
Somit sollte der Include-Guard auch den Namen des `namespace` enthalten, also
z.B. `MINE_SOMECLASS_H` und `OTHER_SOMECLASS_H`.._[]
]

.F[:
Auch stellt sich die Frage, ob man im Include-Guard tatsächlich alle Buchstaben
groß schreiben sollte …
]



---
template: plain
header: #### Zyklische Abhängigkeiten

Einiges Kopfzerbrechen dürfte die Fehlermeldung bereiten, welche trotz (oder wegen?) des
Include Guard aus der folgenden Situation resultiert:._[]

.pull-left[
```
// file: someclass.h
#ifndef SOMECLASS_H
#define SOMECLASS_H
#include "OtherClass.h"
…
class SomeClass {
    …
    OtherClass *link;
};
#endif
```
]

.pull-right[
```
// file: otherclass.h
#ifndef OTHERCLASS_H
#define OTHERCLASS_H
#include "SomeClass.h"
…
class OtherClass {
    …
    SomeClass *link;
};
#endif
```
]

.F[:
In kompilierbarer Form finden Sie die Dateien zu diesem Beispiel unter
[Examples/Cyclic/Broken](../Examples/Cyclic/Broken) und
[Examples/Cyclic/Fixed](../Examples/Cyclic/Fixed) (fehlerbereinigt).
]

---
template: plain
name: definition_reference
header: ### Definition/Reference-Modell

Zu jeder in einem Progamm verwendeten Variablen muss es **genau eine**
Definition geben (mit möglicherweise vielen Bezugnahmen).

* Bei der Bezugnahme aus einer anderen Übersetzungseinheit muss diese eine
  `extern`-Deklaration vornehmen.

* Die tatsächliche Definition **darf** das Wort `extern` enthalten, auch
  wenn sie mit einer Initialisierung verbunden ist.

* Sie **muss** dies u.U. sogar, wenn zugleich eine `const`-Qualifizierung
  verwendet wird und keine `extern`-Deklaration vorausgeht.

.W[
Die Verwendung von `const` auf globaler Ebene impliziert ansonsten den
Sichbarkeitsschutz gegenüber dem Linker.._[]
]

.F[:
Einstmals wurde von Bjarne Stroustrup damit das Ziel verfolgt, eine möglichst
unproblematische Umstellung von `#define`-s auf `const` zu unterstützen. Das
Risiko von Name Clashes in der Link-Phase wurde damit ausgeschlossen auf Kosten
von evtl. mehrfach für den selben Zweck reservierten Speicher im globalen
Bereich (der bei einfachen Datentypen von optimierenden Compilern vermieden
werden kann, sofern kein Zugriff auf die Adresse der jeweiligen Variablen
erfolgte.
]

---
template: plain
name: const_protection
header: ### Schreibschutz durch den Compiler (`const`)

Mittels `const`-Qualifizierung wird die Zuweisung eines (neuen) Werts an eine
Variable verboten. Es ist nur noch die Initialisierung bei der Definition
möglich.

```
const int x = 42;              // Initialisierung notwendig
extern const unsigned VERSION; // nur Bezugnahme
```

Folgendes führt nun zu einem Compile-Fehler:._[]
```
++x;
…
if (VERSION = 3014u) {
    // special case for version 3.14
    …
}
```

.F[:
Abhängig von der Art der Variablen und den Möglichkeiten der Hardware ist für
`const`-qualifizierte Variablen eventuell auch ein physikalischer Schreibschutz
möglich.
]

---
template: plain
name: reference_types
header: ## Zeiger und Referenzen

--------------------------------------------------------------------------

* [Zeiger allgemein und `const`-qualifiziert	](#const_pointers)
* [Klassische Referenzen (Lvalue-Referenzen)	](#classic_references)
* [Zeiger versus Referenzen			](#pointer_vs_reference)
* [Rvalue-Referenzen (neu in C++11)		](#rvalue_reference)

--------------------------------------------------------------------------

---
template: plain
name: const_pointers
header: ### Zeiger allgemein und `const`-qualifiziert

Bei Zeigern ist zu beachten, dass sich die Konstantheit auf den Zeiger selbst
beziehen kann
```
int *p1;       // pointer and pointed-to memory are modifiable
…
*p1 = …;       // OK (assuming valid initialisation)
const int *p2; // same as: int const *p;
               // only pointer is still modifiable, but ...
*p2 = …;       // ERROR at compile-time
```

oder auf das, was über den Zeiger erreichbar ist:._[]
```
int *const p3 = …; // must be initialized (with address of an int)
p3 = …;            // ERROR (would modify pointer itself)
*p3 = …;           // OK (modifies pointed-to memory location)
++*p3;             // OK (increments pointed-to memory location)
++p3;              // ERROR (would modify pointer itself!) 
```

.F[:
Of course, both kinds of `const`-qualification may be combined if it makes sense
for a given purpose, e.g. `const int *const p4 = …;` (or - switching the
positions the qualification and the type to which it is applied:
`int const *const p4 = …;`).
]

---
template: plain
name: classic_references
header: ### Klassiche Referenzen (Lvalue-Referenzen)

Das klassiche Beispiel ist eine Funktion, welche die Inhalte zweier Variablen
vertauscht:

.pull-left[
```
void swap(int *p, int *q) {
    const int t = *p;
    *p = *q;
    *q = t;
}
…
int a, b;
…
if (a > b) swap(&a, &b);
…
```
]

.pull-right[
```
void swap(int &r, int &s) {
    const int t = r;
    r = s;
    s = t;
}
…
int a, b;
…
if (a > b) swap(a, b);
…
```
]

In der linken Version werden Zeigerargumente verwendet und explizit Adressen
übergeben, in der rechten sind die Argumente Referenzen. Der Unterschied besteht
aber nur in der sparsameren Notation im Quelltext (mit Referenzen) - es kann
identischer Maschinencode erzeugt werden.._[]

.F[:
Though there is no rule to enforce this. E.g. depending on compile time debug
options different security checks could be generated for pointers and
references.
]

---
template: plain
name: reference_initialisation
header: #### Initialisierung von Referenzen

Da Referenzen konzeptionell stets vorhandenen Speicherplatz bezeichnen,._[]
müssen sie zwingend intialsiert werden.

.N[
It is not possible to modify a reference after initialisation so that it
refers to a different memory location.
]

Insofern entsprechen Referenzen den konstanten Zeigern, die selbst nicht
veränderbar sind, wohl aber der über sie erreichbare Speicherplatz.

```
int v1, v2;
int &r = v1; // rerefence is intialized
…
```
Das folgende führt **nicht** zu einem Fehler bei der Kompilierung, führt aber
nicht dazu, dass `r` nun die Variable `v2` referenziert sondern kopiert den
Inhalt von `v2` in `v1`:
```
r = v2;
```

.F[:
Not further considering some artistic ways of initialisation here which
deliberately subvert this:  
`T &r = *reinterpret_cast<T*>(0);`
]

---
template: plain
name: const_reference
header: #### Konstante Referenzen

Die `const`-Qualifizierung bezieht sich bei der Referenz auf den darüber
möglichen Zugriff:

* Im Allgemeinen kann über eine Referenz angesprochener Speicherplatz gelesen
  und verändert werden.

* Über eine `const`-qualifizierte Referenz sind nur Lesezugriffe möglich.

Im folgenden Beispiel kann die Variable `v` zwar direkt und bei Zugriff über
`r1` verändert werden, nicht aber beim Zugriff über `r2`:
```
T v;
T &r1 = v;       // r1 now refers to content of v
const T &r2 = v; // r2 also refers to content of v
…
r1 = …; // OK (actually changes v)
r2 = …; // ERROR (at compile time)
```

Lesender Zugriff ist natürlich sowohl über `r1` wie auch über `r2` möglich.._[]

.F[:
It should be obvious that in the light of references a value-tracking compiler
must be careful not to optimise-out *read* memory access with no intervening
*write*: the content of some location might still have been modified on a
different access path.
]

---
template: plain
name: const_correctness
header: #### Achieving the Const-Correctness

The C++ compiler catches constructs that may subvert const-correctness.

.pull-left[

```
const T cv = …;
const T &cr = cv; // OK
T &r = cv;        // ERROR
```
]

.pull-right[

```
const T cv = …;
const T *cp = &cv; // OK
T *p = &cv;        // ERROR
```
]


Aside from the notational there is **no substantial difference** between
pointers and references in the two examples above.._[]

.W[
If the above initialisation would compile, the non-modifiable variable `cv`
might be modified via a non-`const` reference (`r`) or a pointer to non-`const`
memory (`p`).
]

.F[:
In fact: both fragments will typically compile into the same machine
instructions.
]

---
template: plain
name: const_ref_args
header: #### Reference Arguments

It should be noticed that in the most cases reference initialisation occurs
when handing arguments to functions, hence all the peculiarities and special
cases will be mostly observed there:

Forgotten `const`-qualification, `arg` is actually not modified in `foo`:
```
void foo(double &arg) {
    … // all access to arg is read-only
}
```

.pull-left[
Cannot call `foo` now with literal constant or `const`-qualified variable
```
foo(0.0); // ERROR
double const PI = 3.14;
foo(PI);  // ERROR
```
]

.pull-right[
No temporaries are silently created:._[]
```
const int x 42;
foo(x);
foo(2*PI);
```
]

.F[:
The reason here is …
]

---
template: plain
name: pointer_vs_reference
header: ### Zeiger versus Referenzen

C++ Referenzen können auf zwei Arten betrachtet werden:

* Eine alternative Syntax für Zeiger, welche

  * die Dereferezierung bei der Verwendung impliziert (`*` automatisch
    vorangestellt);

  * bzw. den Adress-Operator bei der Initialisierung (`&` automatisch
    vorangestellt).

* Oder aber einen Alias-Name für bereits (an anderer Stelle) existierenden,
  typisierten Speicherplatz.

.N[
Der für Zeiger und Referenzen erzeugte Maschinen-Code unterscheidet sich in
der Regel nicht – unterschiedlich ist nur die Syntax bei Initialisierung und
beim Zugriff auf das, was referenziert wird.._[]
]

.F[:
Der Nachweis ist beim `g++` leicht durch die Erzeugung des Assembler-Codes
möglich, wozu die Option `-S` (Großbuchstabe) anzugeben ist und das Ergebnis in
einer Datei mit Suffix `.s` (Kleinbuchstabe) landet. Für noch schnellere,
praktische Experimente zu Fragen der Code-Erzeugung sei auf den folgenden Online
Compiler hingewiesen: http://gcc.godbolt.org/
]

---
template: plain
name: rvalue_reference
header: ### Rvalue-Referenzen

[Rvalue-Referenzen]: http://en.cppreference.com/w/cpp/language/reference

Mit C+11 neu eingeführt wurde das Konzept der [Rvalue-Referenzen]. Sie lassen
sich nur mit Audrücken initialisieren, also *temporären Werten*, auf die dann
kein anderer Zugriff als über die Referenz besteht.

Nachfolgend zusammengefasst die wichtigsten Regeln:._[]
```
T &r = …;          // … must be modifiable T in memory
const T &cr = …;   // … must be modifiable T in memory OR
                   //        non-modifiable T in memory OR
                   //        temporary T in memory (expression)
T &&rr = …;        // … must be temporary T in memory (expression)
```

.N[
Die Hauptanwendung liegt beim Überladen von Funktionen für unterschiedliche
Herkunft von Argumenten, und dort wiederum insbesondere bei
[Kopier-Konstruktor und -Zuweisung](#copy_ctor_assign), denen damit
[Move-Varianten](#move_ctor_assign) zur Seite gestellt werden können.
]

.F[:
In dem für obige Szenarien typischen Fall von Funktionsargumenten könnte im Fall
der Rvalue-Referenz – anders als bei klassischen `const`-Referenzen – das
übergebene `T` nun modifiziert werden, allerdings nur so weit, dass der
Destruktor nach wie vor seine Arbeit verreichten kann.
]

---
template: plain
name: static_polymorphism
header: ## Statischer Polymorphismus

--------------------------------------------------------------------------

* [Defaultwerte für Argumente		](#default_arguments)
* [Überladen von Funktionen		](#overloading_functions)
* [Überladen von Operatoren		](#overloading_operators)

--------------------------------------------------------------------------

Defaultwerte für Argumente wurden in diesen Abschnitt aufgenommen, da ihre
Wirkung mit dem Überladen von Funktionen konkurriert.._[]

.F[:
Aus Hardware-Sicht ist die Implementierung bei echten Funktionen (ohne `inline`)
allerdings unterschiedlich.
]


---
template: plain
name: default_arguments
header: ### Defaultwerte für Argumente

Argumente können "von rechts nach links" mit Default-Werten versehen werden,
das heißt:

* Sobald ein Argument einen Default-Wert hat,
* müssen alle rechts davon stehenden ebenfalls einen haben.

.N[
Der Defaultwert muss beim Funktionsaufruf bekannt sein, also im Header-File
stehen als Bestandteil des Funktions-Prototyps.
]

Die Namen für die formalen Argumente sind aber auch hier optional:._[]
```
// the following function can be called with 1..3 arguments:
double foo(int &count, int minsize = 0, char separator = 'z');
…
// same as:
double foo(int &, int = 0, char = 'z');
```

.F[:
Using names for arguments in prototypes has pro's and con's: it is of course
more self-documenting but there is at least a remote chance for surprising and
**extremely hard to find** name clashes with preprocessor macros. Hint: view
preprocessor output (`g++ -E …`) whenever you get desparate because of an
completely unexplainable syntax error in your source code.
]

---
template: plain
name: overloading_functions
header: ### Überladen von Funktionen

Mehrere Funktionen gleichen Namens können parallel existieren sofern sie sich in
Anzahl und/oder Typ ihrer Argumente unterscheiden:._[]
```
void foo(const char *);         /*1*/
double foo(const int &, char);  /*2*/
double foo(double, double);     /*3*/
```
.N[
Welche Funktion aufgerufen wird (oder der Aufruf mehrdeutig ist),
entscheidet der Compiler gemäß den tatsächlichen Argumenten.
]
```
int x; double y;
…
foo("hello, world");   /*calls 1*/
foo(42, 'z');          /*calls 2*/
foo(y, y/2);           /*calls 3*/
foo(x, y);             /*calls ?*/
```

.F[:
If one argument list is from left to right an exact subset of another one, this
is similar to default values for arguments. But with overloading there are as
many separate entry points as there are functions with the same name, while for
default argument values there is just one entry point and missing argument
values are automatically supplied.
]

---
template: plain
header: #### Überladen von Funktionen (2)

Die `const`-Qualifizierung eines Parameters macht ebenfalls einen Unterschied:
```
void foo(char *); /*4*/
char data[100];
…
foo(data); /*4*/
foo("hi"); /*1*/
```

Es ist allerdings nicht zwingend notwendig, dass immer zwei Funktionen
existieren, je eine für den konstanten und den nicht-konstanten Fall:

* Ohne die Funktion für den **nicht**-konstanten Fall wird die Funktion für den
  konstanten Fall für alle Aufrufe verwendet.._[]

* Ohne die Funktion für den **konstanten** Fall wird der Aufruf mit `"hi"` zum
  Compile-Fehler, da String-Literale den Typ `const char *` haben.

.F[:
Generell ist es kein Problem, wenn eine Funktion, welche über ein Zeiger- oder
Referenz-Argument erreichbaren Speicherplatz nicht verändern wird, die Adresse
von prinzipiell schreibbarem Speicher bekommt – **wohl aber umgekehrt!**
]

---
template: plain
name: overloading_operators
header: ### Überladen von Operatoren

[Boost.Operators]: http://www.boost.org/doc/libs/1_55_0/libs/utility/operators.htm

Operatoren können überladen werden mit Funktionen, deren Name mit dem Wort
`operator` beginnt.

* Die meisten Operatoren können wahlweise mit freistehenden Funktionen oder mit
  Member-Funktionen überladen werden.

* Einige Operatoren sind auf Member-Funktionen eingeschränkt.

.N[
Zur konsistenten Überladung ganzer Operatorgruppen kann [Boost.Operators]
hilfreich sein.
]

---
template: plain
header: #### Operator-Überladung mit freistehender Funktion

Diese sieht prinzipiell so aus:
```
MyClass operator+(const MyClass &lhs, const MyClass &rhs) {
    … // do whatever must be done
    return …;
}
```

Der Rückgabetyp ist dabei beliebig, die `return`-Anweisung muss natürlich vom
Typ her passend sein, genauer gesagt: Der Ausdruck hinter `return` muss exakt
den Rückgabetyp haben oder in diesen umwandelbar sein.

---
template: plain
header: #### Operator-Überladung mit Member-Funktion

Diese sieht prinzipiell so aus:
```
MyClass &MyClass::operator+=(const MyClass &rhs) {
    … // do whatever must be done
    return *this;
}
```

Auch hier ist der Rückgabetyp grundsätzlich frei wählbar. Gemäß den Konventionen
bei den Standardtypen wird in der Regel das durch die Operation gerade
veränderte Objekt selbst zurückgegeben.

---
template: plain
name: copy_ctor_assign
header: #### Überladung von Kopier-Konstruktor und -Zuweisung

[Rule Of Three]: http://en.cppreference.com/w/cpp/language/rule_of_three

Für einige Arten von Objekten muss die Zuweisungs-Operation überladen werden, da
der Default – elementweise Zuweisung – ungeeignet ist.._[]
```
class MyClass {
    T *some_ptr;
    …
public:
    …
    // avoid compiler defaults:
    MyClass(const MyClass& rhs);
    MyClass& operator=(const MyClass& rhs);
}
```

.N[
Der klassische Indikator sind als Member-Daten enthaltene Zeiger auf
Speicherplatz, welcher individuell für jedes Objekt vorhanden sein muss.._[]
]

.F[:
In C++ books this is often referred to as [Rule of Three] – the third member
function for which the default is not appropriate is the destructor, of course.
]

---
template: plain
name: move_ctor_assign
header: #### Überladung von Move-Konstruktor und -Zuweisung

[Rule Of Five]: http://en.cppreference.com/w/cpp/language/rule_of_three

In C++11 können die [Rvalue-Referenzen](#rvalue_ref) dazu verwendet werden,
Initialisierung und die Zuweisung unterschiedlich zu implementieren,._[]
abhängig davon ob

* der dazu verwendete Ausdruck direkt ein Objekt repräsentiert, das danach
  unverändert im Speicher weiter existiert, oder

* temporären Speicherplatz (für einen berechneten Ausdruck oder ein
  Funktionsergebnis), der ohnehin bald verworfen wird.

```
class MyClass {
public:
    …
    // copy versions (rhs lives on in memory)
    MyClass(const MyClass& rhs);
    MyClass& operator=(const MyClass& rhs);
    // move versions (rhs destroyed soon after)
    MyClass(MyClass&& rhs);
    MyClass& operator=(MyClass&& rhs);
}
```

.F[:
Turning the classic C++ *Rule of Three* into the [Rule of Five] in C++11.
]

---
template: plain
name: move_ctor_assign
header: #### Implementierung von Move-Konstruktor/Zuweisung

Nachdem Move-Versionen deklariert sind, müssen diese natürlich auch
implementiert werden.

Wenn der Kopierkonstruktor wie folgt aussieht …
```
MyClass::MyClass(const MyClass &rhs)
    : …, some_ptr(new T(*rhs.some_ptr)), …    // cloning resource
{ … }
```

… könnte dieser Move-Konstruktor angemessen sein:
```
MyClass::MyClass(MyClass &&rhs)
    : …, some_ptr(rhs.some_ptr), …    // taking over resource
{ …; rhs.some_ptr = nullptr; … }      // INVALIDATING it for rhs!
```

.N[
Die Zuweisungen sind ähnlich, müssen aber zuerst `some_ptr` freigeben.._[]
]

.F[:
The general difference between constructor and assignment is that the former
gets just a piece of memory while the later finds a valid object that needs
to be properly de-constructed first.
]

---
template: plain
header: #### Unterscheidung Copy- und Move-Versionen

Existieren beide Fassungen (Copy und Move), ergibt sich folgendes Verhalten:

```
MyClass foo() { return …; }  // … must be an expression of
                             // type MyClass (or something
                             // convertible to MyClass)
MyClass a;        // (expects c'tor with no argumens)
MyClass b(a);     // copy c'tor (does not alter a)
MyClass c(foo()); // move c'tor (may alter temporary)
a = c;            // copy assignment (does not alter c)
b = foo();        // move assignment (may alter temporary)
c = a + b;        // move assignment provided operator+ is
                  // defined for MyClass (may alter temporary)
```

---
template: plain
name: type_conversions
header: ## Typ-Kompatibilität und -Konvertierungen

--------------------------------------------------------------------------

* [Typ-Kompatibilität bei grundlegenden Typen	](#basictype_typeconv)
* [Typ-Kompatibilität und Vererbung 		](#public_base_typeconv)
* [Explizite Typ-Konvertierung mittels *Cast*	](#explicit_typeconv)
* [Klassenspezifische Typ-Konvertierung		](#specified_typeconv)
* [Typ-Sicherheit generell			](#general_typesafety)

--------------------------------------------------------------------------

---
template: plain
name: basictype_typeconv
header: ### Typ-Kompatibilität bei grundlegenden Typen

Die wichtigsten Regeln für Typ-Kompatibilität und ggf. automatisch angewendete
Typ-Konvertierungen sind hier:

* Alle *arithmetischen Typen* sind miteinander kompatibel bzw. werden bei Bedarf
  entsprechend umgewandelt.._[]

* Ansonsten finden bei Bedarf folgende Umwandlungen statt:

  * Aufzählungstypen in arithmetische Typen;
  * Zeiger in Wahrheitswerte (alles außer `nullptr` ist `true`);
  * typisierter Zeiger in allgemeine Zeiger (`void *`).

.I[
Innerhalb der arithmetischen Typen erfolgt die Umwandlung nach Möglichkeit
**wert-erhaltend** und wird oft mit auszuführenden Maschinenbefehlen verbunden
sein.
]

Inwieweit dies auch für die anderen Fälle gilt, hängt von Hardware-Details ab,
insbesondere der Repräsentation von Aufzählungstypen und Zeigern.

.F[:
Dies schließt auch `char` (mitunter verwendet für kleine Ganzzahlen) und `bool`
(Wahrheitswerte) ein.
]

---
template: plain
header: #### Typ-Kompatibilität bei grundlegenden Typen (2)

* Außerhalb der Umwandlungen zwischen arithmetischen Typen handelt es sich um
  **einseitig gerichtete** Umwandlungen.

* D.h. es gibt **keine** automatische Umwandlung in den folgenden Fällen:

  * von arithmetischen Typen in Aufzählungstypens;
  * von Wahrheitswerten in Zeiger;
  * von allgemeinen Zeigern in typisierte Zeiger.

.I[
Im letzten Punkt unterscheiden sich C und C++, was zu deutlich **größerer
Typ-Sicherheit in C++** führt.
]

Anders als in C kann in C++ auf dem Umweg über allgemeine Zeiger (`void *`)
keine "stille" Typ-Konvertierung typisierter Zeiger erfolgen.._[]

.F[:
Der Grund für das andere Verhalten liegt bei der `malloc`-Funktionsfamilie in
der C-Bibliothek, die gemäß dem C89-Standard den Ergebnistyp `void *` hat,
und für welche die Notwendigkeit von Cast-Operationen vermieden werden sollte.
]

---
template: plain
name: public_base_typeconv
header: ### Typ-Kompatibilität und Vererbung

[Slicing]: http://www.geeksforgeeks.org/object-slicing-in-c/

* Ein **Zeiger** auf eine öffentlich abgeleitete Klasse ist kompatibel mit einem
  **Zeiger** auf eine ihrer direkten oder indirekten._[] Basisklassen.

* Ein **Referenz** auf eine öffentlich abgeleitete Klasse ist kompatibel mit
  einer **Referenz** auf eine ihrer direkten oder indirekten._[] Basisklassen.

* Basierend auf **Objekten** einer öffentlich abgeleiteten Klasse werden ggf.
  automatisch – per [Slicing] – **Objekte** direkter oder indirekter._[]
  Basisklassen initialisiert.

.I[
Außer bei Mehrfachvererbung sind die ersten beiden Fällen in der Regel **nicht**
mit auszuführenden Maschinenbefehlen verbunden.
]

.F[:
Ausgenommen sind jeweils indirekte nicht-virtuelle Basisklassen im Fall von
Mehrfachvererbung und rautenförmigen Klassenbeziehungen (in der UML als
"«disjoint»" annotiert).
]

---
template: plain
name: public_base_lsp
header: #### Öffentliche Basisklassen und LSP

[Principle of Substitutibility]: http://dictionary.reference.com/browse/liskov+substitution+principle

Die auf der vorhergehenden Seite zusammengestellten Regeln sind Ausdruck dessen,
was Barbara Liskov seinerzeit als

* "*[Principle of Substitutibility]*"

für die Objekt-Orientierte Programmierung als forderte und was seitdem oft als
LSP abgekürzt wird.

.N[
**Das LSP gilt in C++ nur im Fall öffentlicher Basisklassen** und nur hier
liegt Vererbung im Sinne der OOP vor.
]

Diese wird auch *Generalisierung-Spezialisierung* genannt und in der
UML-Darstellung durch Verbindungslinie mit kleinem, nicht ausgefülltem Dreieck
an der Basisklasse spezifiziert.

---
template: plain
name: private_base_no_lsp
header: #### Private Basisklassen (kein LSP)

Öffentliche und private Basisklassen in C++

* verwenden zwar ein und dasselbe Speicher-Layout,

* **bei privaten Basisklassen gilt das LSP jedoch nicht**.

.N[
Im Sine der OOP handelt es sich bei letzteren somit nicht um Vererbung sondern
um Komposition.._[]
]

In der UML-Darstellung wird die Komposition durch eine Verbindungslinie mit
kleiner, ausgefüllter Raute an der Klasse des Aggregats spezifziert.

.F[:
This topic and especially the various forms of composition receive substantially
deeper coverage in a later chapter.
]

---
template: plain
name: explicit_typeconv
header: ### Typ-Konvertierung mittels *Cast*

[Cast-Operation]: http://www.cplusplus.com/doc/tutorial/typecasting/

Mittels sogenannter [Cast-Operation]en lassen sich weitere Typ-Umwandlungen
erzwingen.

.W[
Die Cast-Syntax von C, bei welcher man den Zieltyp in runde Klammern einschließt
und den umzuwandelnden Wert direkt dahinter schreibt, sollte in C++ vermieden
werden.
]

Die neue Syntax beginnt mit einem der Schlüsselworte

* [`static_cast`](#static_cast_typeconv)
* [`dynamic_cast`](#dynamic_cast_typeconv)
* [`const_cast`](#const_cast_typeconv)
* [`reinterpret_cast`](#reinterpret_cast_typeconv)

Es folgen der Zieltyp in spitzen Klammern und der umzuwandelnde
Wert in runden Klammern.._[]

.F[:
As an example consider the use of C-style memory allocation for some `struct s`
in C++.  
```
struct s *p = static_cast<struct s*>(std::malloc(sizeof (struct s))); // required conversion in C++
          … (struct s*) std::malloc(sizeof (struct s)); // C-style cast, possible but deprecated in C++
                     
```
]

---
template: plain
name: static_cast_typeconv
header: #### Typ-Konvertierung mit `static_cast`

Hiermit lassen sich alle Typ-Umwandlungen explizit hervorheben, welche der
Compiler auch automatisch vorgenommen hätte.._[]

Darüberhinaus funktioniert der `static_cast` in **beide** Richtungen für alle
Umwandlungen, welche als **automatische** Umwandlung nur in einer Richtung
eingesetzt werden:

* Arithmetische Wert in Aufzählungstypen (`enum`)

  * automatisch nur Aufzählungstypen in arithmetische Werte

* Generische Zeiger (`void *`) in typisierte Zeigern

  * automatisch nur typisierte in generische Zeiger

* Basisklassen in abgeleitete Klassen (Downcast)

  * automatisch nur abgeleitete Klassen in Basisklassen (Upcast)

.F[:
The most typical reason for this is that many compilers will issue a warning
when an arithmetic conversions might not be value preserving, e.g. when an
64-bit integral value is assigned to a 32 bit integral variable. If this is
done with a cast, most compilers will suppress the warning.
]

---
template: plain
name: dynamic_cast_typeconv
header: #### Typ-Konvertierung mit `dynamic_cast`

[`std::bad_cast`]:     http://en.cppreference.com/w/cpp/types/bad_cast
[Laufzeit-Typprüfung]: 04_wednesday2.html#dynamic_cast

Hiermit lassen sich ausschließlich Typ-Umwandlungen innerhalb von
Klassenhierarchien vornehmen.

.N[
Im Fall von Downcasts findet zur Laufzeit eine Überprüfung mit Fehleranzeige
statt, wenn der Cast nicht durchführbar ist.._[]
]

Die Fehleranzeige besteht

* bei Casts auf Zeigerbasis in der Rückgabe eines Nullzeigers;

* bei Casts auf Referenzbasis in einer [`std::bad_cast`]-Exception.

Weiteres wird später im Rahmen der [Laufzeit-Typprüfung] (RTTI) behandelt.

.F[:
Der Grund für die mögliche Undurchführbarkeit muss zusammen mit der
Typ-Kompatibilität zwischen Basisklassen und abgeleiteten Klassen gesehen
werden: Ein Zeiger, der als Zeiger auf eine Basisklasse definiert ist, könnte
stets auch auf ein Objekt einer davon abgeleiteten Klasse zeigen. Genau dies
wird bei dem Versuch überprüft, mittels `dynamic_cast` den Basisklassenzeiger
in einen Zeiger auf die abgeleitete Klasse umzuwandeln.
]

---
template: plain
name: const_cast
header: #### Typ-Konvertierung mit `const_cast`

Die hiermit möglichen Typ-Umwandlungen beschränken sich auf das

* Hinzufügen oder
* Wegnehmen

von `const` und `volatile`.

Alle anderen Unterschiede zwischen dem Zieltyp und dem Typ des umzuwandelnden
Ausdrucks führen zu einem Compile-Fehler.

.W[
Ein `const_cast` hat gemäß dem C++-ISO/ANSI-Standard undefiniertes Verhalten,
wenn auf eine mit Schreibschutz definierte Adresse schreibend zugegriffen wird.
]

Das typische Fehlerbild reicht von der inkonsistenten Wertverwendung (teilweise
alter Wert, teilweise neuer Wert) bis zum Programmabsturz …._[]

.F[:
Abhängig von der Testtiefe, dem verwendeten Compiler, Optimierungs-Optionen usw.
mag es allerdings auch so erscheinen, als würde alles wie gewünscht funktionieren.
]

---
template: plain
name: reinterpret_cast
header: #### Typ-Konvertierung mit `reinterpret_cast`

Dieses Konstrukt wird vor allem dazu eingesetzt, Zeiger auf (bekannte)
Hardware-Adressen zu setzen, wie das u.a. im Bereich der Embedded Progammierung
und bei Gerätetreibern notwendig sein kann.._[]

.F[:
Die per `reinterpret_cast` gebotene Möglichkeit, quasi jedes Bitmuster im
Speicher gemäß einem beliebigen Typ zu interpretieren, veranlassen C++-Kritiker
mitunter zu der Aussage, die C++ sei unsicher da nicht vollständig typgeprüft.
Diese Kritik muss dann aber ebenso für Sprachen gelten, welche ein zur C/C++
`union` vergleichbares Konstrukt bieten, so etwa das gemeinhin als typsicher
geltende Pascal.
]

Darüber hinaus kann man mit einem `reinterpret_cast`

* **wie auch** per `static_cast` generische Zeiger (`void *`) in typisierte Zeiger
  umwandeln, und

* **anders als** per `static_cast` einen typisierten Zeiger direkt in einen anders
  typisierten Zeiger umwandeln.

.N[
Es ist dagegen auch mit `reinterpret_cast` nicht möglich, die `const`- und
`volatile`-Qualifizierung zu ändern – dies erlaubt ausschließlich der
`const_cast`.
]

---
template: plain
name: reinterpret_cast_examples1
header: #### Typ-Konvertierung mit `reinterpret_cast` (Beispiel 1)

Das folgende Beispiel nimmt an, dass an der Speicheradresse `0xEAD0` die als
`struct uart` beschriebenen Kontrollregister abgebildet sind:
```
struct uart *const sio = reinterpret_cast<struct uart*>(0xEAD0);
```
Der Zugriff kann nun in der Syntax `sio->…` erfolgen.

Gibt es mehrere solche Register-Strukturen im Speicher (als Memory-Mapped-I/O)
abgebildet, kann natürlich auch ein Array initialisiert
```
struct uart *const sio[] = {
    reinterpret_cast<struct uart*>(0xEAD0),
    reinterpret_cast<struct uart*>(0xEAD8),
    …
};
```
und über dieses mit `sio[0]->…`, `sio[1]->…` usw. zugegriffen werden.

.F[:
Wird statt dem Pfeil die Punkt-Notation bevorzugt, geht das auch, und zwar mit:
```
struct uart &sio = *reinterpret_cast<struct uart*>(0xEAD0);
```
]

---
template: plain
name: reinterpret_cast_examples2
header: #### Typ-Konvertierung mit `reinterpret_cast` (Beispiel 2)

Das folgende Beispiel nimmt an, dass an der Adresse `0xCAFE` im Code-Segment
ein gemäß den C++-Calling Conaufrufbares Unterprogramm beginnt, welches ein
Argument vom Typ `bool` erwartet und keinen Rückgabewert liefert:
```
void (*xcall)(int) = reinterpret_cast<void (*)(int)>(0xCAFE);

```
Der tatsächliche Aufruf kann nun mit
```
xcall(true);
```
bzw.
```
xcall(false);
```
erfolgen.

---
template: plain
name: specified_typeconv
header: ### Klassenspezifische Typ-Konvertierungen

Eine Klasse kann auch selbst festlegen, wie man sie aus einem anderen Typ erzeugt
oder wie sie in einen anderen Typ umgewandelt wird, was man sich bildlich so
vorstellen kann:

* Jede Klasse und jeder eingebaute Typ verfügt über eine Art *charakteristische
  Steckverbindung*, die nur "zu sich selbst" passt.._[]

  * In Initialisierungen und Zuweisungen sind daher zunächst nur Objekte von
    genau dieser Klasse bzw. diesem Typ verwendbar.

* **Konstruktoren mit exakt einem Argument** – sofern nicht als `explicit`
  markiert – sind weitere *Eingänge*.

  * Sie passen zum *Ausgangs*-Steckverbinder des Argument-Typs.

* **Typ-Cast-Operatoren** sind weitere *Ausgänge*.

  * Sie passen zum *Eingangs*-Steckverbinder des Ziel-Typs.

.F[:
If you like that picture you may include base class conversions by assuming
plugs and sockets with the same basic shape for class hierarchies, using code
pins to make the output connector of a derived class fit into the input connector
of its base class(es), but not vice versa. (For standard conversions of basic
types assume a set of adapter plugs that are applied as necessary.)
]

---
template: plain
header: #### Typ-Konvertierungen durch Konstruktoren

Konstruktoren sind dann automatische Typ-Konvertierungen, wenn sie

* genau ein Argument besitzen und

* **nicht** mit dem Schlüsselwort `explicit` markiert sind.

```
class MyClass {
    …
public:
    MyClass(int);  // each single argument c'tor is an
                   // automatic conversion ... except
    explicit MyClass(double);  // it is marked explicit
    …
};
```

---
template: plain
header: #### Anwendung von Konstruktoren zur Typ-Konvertierung

Typ-Konvertierungen durch Konstruktoren kommen wie folgt zur Anwendung:

```
void foo(MyClass);
…
foo(33);            // OK (automatic conversion by c'tor)
foo(3.3)            // ERROR, c'tor is explict
foo(MyClass(3.3));  // OK (c'tor is used explicitly)
…
```
---
template: plain
header: #### Temporärer Objekte im Rahmen der Typ-Konvertierung

Bei Referenzübergabe ist zusätzlich zu beachten, dass bei der
Konvertierung ein temporäres Objekt notwendig wird:
```
void baz(MyClass &); // non-const reference argument
…
baz(42);                       // ERROR (no automatic temporary
                               //        for non-const reference)
baz(MyClass(42));              // ERROR (c'tor call does not bind
                               //        to non-const reference)
{ MyClass tmp(42); baz(tmp); } // OK
```

Automatisch wird dies nur für `const`-qualifizierte Referenzen erzeugt:
```
void bar(const MyClass &); // const reference argument
…
bar(42);                       // OK (automatic temporary)
```

---
template: plain
header: #### Typ-Konvertierungen durch Type-Cast Operationen

Type-Cast Operationen benutzen eine spezielle Syntax, bei der **nach** dem
Schlüsselwort `operator` der Zieltyp folgt:._[]
```
class MyClass {
    …
public:
    // this is called type-cast operator:
    operator Other() const { …; return …; } 
                                    // ^-- Other (or at least
                                    //     convertible to Other)

    // the usual explicit alternative:
    int to_int() const { …; return …; }
                                // ^-- int (or at least
                                //     convertible to int)
};
```

.F[:
Dieser stellt zugleich den Ergebnistyp dar, den die `return`-Anweisung liefern
muss.
]

---
template: plain
header: #### Anwendung von Type-Cast Operationen zur Typ-Konvertierung

Die Typ-Konvertierungen von der vorhergehenden Seite kommen wie folgt zur Anwendung:
```
void foo(Other);
void bar(int);
…
MyClass m;
foo(m);           // OK, implicit use of type-cast operator
bar(m);           // ERROR (of course), but ...
bar(m.to_int());  // ... usual style for explicit conversion
```

---
template: plain
header: #### Sonderfall: `explicit operator bool()`

Eine als `explicit` markierte Typ-Konvertierung in einen Wahrheitswert stellt einen
Sonderfall dar:

* Sie kommt **nicht** zur Anwendung bei Argumentübergabe, Initialisierung und
  Zuweisung,

* **jedoch bei bool'schen Operationen und Bedingungstests.**

Die beispiele auf der nächsten Seite setzen folgendes voraus:

```
class MyClass {
    …
public:
    explicit operator bool() {
       return …; // some bool
    }
    …
};
…
MyClass obj;
extern void foo(bool);
```

---
template: plain
header: #### Beispiele: `explicit operator bool()`

Die folgenen Code-Fragmente setzten das begonnene Beispiel fort:

* `#1` zeigt eine etwas ungewöhnliche aber erlaubte Form des Aufrufs der
  Typ-Konvertierung in `bool`.
* `#2a` löst einen Fehler aus, der in einer syntaktische Mehrdeutigkeit
  begründet ist, die das Paar zusätzlicher Klammern in `#2b` beseitigt.
* `#3` ist eine zulässige aber überflüssige explizite Typ-Konvertierung.

.pull-left[
```
// this does NOT compile ...
foo(obj);

bool bv(obj);
bool bv(bool(obj));      //#2a
bv = obj;

if (obj == true) … 
if (obj == false) …
if (obj == bv) …
// ... compare with code on
// the right for corrections

```
]
.pull-right[
```
// this solves the problems:
foo(bool(obj));
foo(obj.operator bool()); //#1

bool bv((bool(obj)));     //#2b
bv = bool(obj);
if (bool(obj)) …          //#3
if (obj) …
if (!obj) …
if (bool(obj) == bv) …
// boolean operators work too:
if (obj && !bv) …
```
]

---
template: plain
name: general_typesafety
header: ### Typ-Sicherheit in C++

Die praktische Konsequenz aus den Risiken, welche die Konstrukte zur
expliziten Typ-Konvertierung – also die vier neuen Cast-Formen von C++
sowie die von C übernommene Cast-Syntax – einbringen, ist diese:

.W[
Alle Formen expliziter Typ-Konvertierung (mit Cast) sollten auf das
unvermeidliche Minimum beschränkt bleiben.
]

Darüberhinaus werden *klassenspezifische Typ-Konvertierungen* manchmal in
"unerwarteter Weise" angewendet:._[]

.F[:
Or to put it slightly different: Experience showed there are scenarios of
practical importance where a compile error would have been preferred over
the way the compiler made the code "correct" by applying a (non-explicit)
constructor or type-cast operator.
]

.I[
Eine klassenspezifische Typ-Konvertierung sollte nur dort verwendet werden,
wo der stillschweigende Wechsel zwischen den beteiligten Typen als "natürlich"
empfunden wird.
]

---
template: plain
name: exercise_mon1
header: ## Praktikum

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>


