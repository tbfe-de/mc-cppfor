<!DOCTYPE html>
<html>
  <head>
    <title>C++ For (9) - Freitag</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
    <!-- when changing the stylesheet, please also change EACH 'styling-by:' -->
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies aproximately 2/3 of the page width. So only add
  little information, preferrably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open - add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++ FOR]: 00_inhalt.html#agenda

# [C++ FOR] (Freitagvormittag)

-------------------------------------------------------------------------------

1. [Ressourcen ohne und mit RAII verwalten	](#resource_management)
1. [Smart-Pointer 				](#smart_pointers)
1. [Übung					](#exercise_fri1)

-------------------------------------------------------------------------------

Kürzere Pausen werden jeweils nach Bedarf eingelegt.

.N[
Die Besprechung der Musterlösung(en) erfolgt nach direkt nach der Übung, da
am letzten Kurstag der Nachmittag entfällt.
]

---
template: linkinfo
graphic: ResourceManagement
name: resource_management
header: ## Ressourcen ohne und mit RAII

-------------------------------------------------------------------------------

* [Klassische APIs				](#classic_resource_api)

-------------------------------------------------------------------------------

* [Mit RAII verwaltete Ressourcen ...		](#raii_style)
* [... für Ausführung einer Anweisungsfolge ...	](#raii_codeblock)
* [... oder Lebensdauer eines Objekts belegen	](#raii_lifetime)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: ResourceManagement
section: Classic Resource Management APIs
name: classic_resource_api
header: ### Klassische APIs

Klassisches Ressource-Management beruht auf zwei getrennten Operationen

* Belegen der Ressource (Acquire, Allocate, Open, …)
* Freigeben der Ressource (Release, Free, Close, …)

Bei beiden Operationen besteht das Problem, dass sie vergessen werden könnten, bei
der zweiten zusätzlich das Problem, dass sie zu früh stattfinden könnte.._[]

.F[:
Zum falschen Zeitpunkt ausgeführte Operationen sind in aller Regel einer (zu) komplexen
Programmlogik anzulasten. Die vorwiegend genutzten und gut getesteten Ausführungspfade
sind dann ohne Probleme, diese treten nur relativ selteneren Konstellationen mit oft
unklarer Vorgeschichte auf.
]

---
template: plain
header: #### Um welche Ressourcen geht es?

Grundsätzlich werden unter dem Begriff hier alle "knappen Betriebsmittel" verstanden,
über die ein Programm nicht während seiner gesamten Ausfhrungszeit verfügen kann.

Die folgende Liste ist nur beispielhaft zu sehen und keineswegs erschöpfend:

* Hauptspeicher 
* Mutexe
* Dateien 
* Prozesse
* Datenbank-Verbindungen
* …

---
template: plain
header: #### Wie werden Ressourcen repräsentiert?

In C/C++ gibt es zwei besonders häufig verwendete Abstraktionen, die eine Ressource
repräsentieren:

* *Zeiger* - eine Speicheradresse, an der wesentliche Informationen zur Ressource stehen
  oftmals repräsentiert durch eine Struktur, deren Inhalt im Detail aber nicht von
  Interesse ist.

* *Handles* - in der Regel eine Ganzzahl, die einer Service-Schnittstelle zu übergeben
  ist und dieser gegenüber die Ressource repräsentiert.._[]

.F[:
Mitunter - aber nicht grundsätzlich - sind Handles Indizes, mit welchen Einträge einer
hinter der Service-Schnittstelle angesiedelten Tabelle ausgewählt werden.
]

---
template: withinfo
graphic: ResourceManagement
section: Wrapped Resource
name: raii_style
header: ### Mit RAII verwaltete Ressourcen

Bei [RAII] handelt es sich um die Ablürzung der von Bjarne Stroustrup empfohlenen Technik,
klassische Ressourcen zu verpacken:

.N.center[
Ressource Acquisition Is Initialisation
]

In der Regel ist dazu eine kleine Hilfsklasse erforderlich, welche

* die Ressource-Anforderung im Konstruktor und
* die Ressource-Freigabe im Destruktor

vornimmt.

  [RAII]: http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization

---
template: withinfo
graphic: ResourceManagement
section: Acquire Resource for Code Segment
name: raii_codeblock
header: ### RAII-Resource für Anweisungsfolge belegen

Da in C++ überall neue (geschachtelte) Blöcke beginnen können, lässt sich die
Anweisungssequenz während der die Ressource belegt ist, nach Belieben festlegen.

* Eine Variable vom Typ des Resource-Wrappers wird an der Stelle eines Code-Blocks
  (als Stack-Objekt) angelegt, ab dem die Ressource benötigt wird.

* Der Destruktor des Resource-Wrappers wird automatisch ausgeführt, wenn der
  betreffende Code-Block verlassen wird.

.N[
Durch die automatische Ausführung des Destruktors wird die Ressource in jedem Fall
zuverlässig freigegeben.
]

Insbesondere spielt es keine Rolle, wie und warum der Kontrollfluss den betreffenden
Code-Block verlässt - also egal ob nach Ausführung der letzen Anweisung im Block,
`return`, `break`, `continue` oder `throw` (letzteres auch in aufgerufener Funktion).
  
---
template: withinfo
graphic: ResourceManagement
section: Acquire Resource for Object Lifetime
name: raii_lifetime
header: ### RAII-Resource für Objekt-Lebensspanne belegen

Objekte die (per Komposition) als Teil anderer Objekte existieren, werden werden

* während der Erzeugung des umfassenden Objekts automatisch mit angelegt und

* während dessen Zerstörung automatisch mit zerstört.

Damit kann ein Resource-Wrapper die Belegungsdauer einer Resource auch zuverlässig mit
der Lebensspanne eines bestimmten (anderen) Objekts verknüpfen.

---
template: plain
header: #### Explizite Anforderung mehrerer Ressourcen ohne RAII

Fordert eine Klasse in ihrem Konstruktor mehr als eine Ressource explizit an -
** ohne Verwendung von RAII** -, besteht nur bei einer besonders sorgfältigen
Vorgehensweise Sicherheit vor Resource-Leaks.

##### Beispiel-Code für Klasse - kein RAII

Angenommen eine Klasse `Choice` benötigt zwei Sorten von Ressourcen:

* ein `Window` (optional, also Multiplizität 0..1)
* eine mehr oder weniger große Zahl von `MenuItem`-s (Multiplizität 1..*)

```
	class Choice {
		…
		Window *w;
		MenuItem *m;
	public:
		Choice( … );
		~Choice();
		…
	};
```

---
template: plain
header: #### Explizite Anforderung mehrerer Ressourcen ohne RAII (2)

##### Beispiel-Code Konstruktor für Klasse - kein RAII

Zunächst werden beide Zeiger sicher initialisiert, dann die Ressourcen angefordert:
```
	Choice::Choice( … )
		: w(nullptr), m(nullptr) {
		try {
			w = new Window( … );
			m = new MenuItem[…];
		} 
		catch( … ) {
			delete w;
			delete[] m;
			throw;
		}
	};
```

---
template: plain
header: #### Explizite Anforderung mehrerer Ressourcen ohne RAII (3)

##### Beispiel-Code Destruktor für Klasse - kein RAII

Nach erfolgreichem Durchlaufen des Konstruktors wird der Destruktor aktiviert.
Dieser muss dann so aussehen:
```
	Choice::~Choice() {
		delete w;
		delete[] m;
	}
```
.W[
Genau diese beiden Anweisungen waren schon einmal nötig - im `catch`-Block
des Konstruktors.
Es liegt eine unschöne Duplizierung von Code vor (= Verletzung des DRY-Principles).
]

---
template: plain
header: #### Anforderung mehrerer Ressourcen mit RAII

Hierbei wandert die Operation zur Freigabe in den Wrapper der betreffenden Ressource:
```
	class WindowRes {
		Window *res;
	public:
		WindowRes( … ) : res(new Window( … )) {}
		~WindowRes()  { … ; delete res; … }
		operator Window*() { return res; }
	};
```

```
	class MenuItemRes {
		MenuItem *res;
	public:
		MenuItemRes( … ) : res(new[…] MenuItem( … )) {}
		~MenuItemRes() { … ; delete[] res; … }
		MenuItem &operator[](int i) { return res[i]; }
	};
```

---
template: plain
header: #### Anforderung mehrerer Ressourcen mit RAII (2)

##### Beispiel-Code Vereinfachung Choice-Klasse - mit RAI

```
	class Choice {
		…
		WindowRes wr;
		MenuItemResr mr;
	public:
		Choice( … ) : WindowRes( … ), MenuItemRes( … ) {}
		// (eigener) Destruktor entfaellt
		…
	};
```

---
template: linkinfo
graphic: SmartPointers
name: smart_pointers
header: ## Smart-Pointer

-------------------------------------------------------------------------------

* [Smart-Pointer von C++11._[] im Vergleich	](#unique_vs_shared)

-------------------------------------------------------------------------------

* [Prinzip der Referenzzählung			](#refcount_principle)

-------------------------------------------------------------------------------

* [Problem zyklischer Referenzierung mit ...		](#refcount_problem)
* [... "nur beobachtenden" Zeiger als Ausweg und ...	](#weak_ptr_solution)
* [... "verlorene" Resourcen				](#weak_ptr_dangling)

-------------------------------------------------------------------------------

* [Varianten der Implementierung		](#implementation_choices)

.F[:
Berücksichtigt sind hier nur die Smart-Pointer von C++11, da mit diesem Standard
zugleich der mit C++98 eingeführte `std::auto_ptr` abgekündigt wurde.
]

---
template: withinfo
graphic: SmartPointers
section: Comparing Smart Pointers
name: unique_vs_shared
header: ### Smart-Pointer von C++11 im Vergleich

Die von C++11 bereitgestellten *Smart-Pointer* repräsentieren die beiden wichtigsten
Beziehungen, die ein Objekt zu auf dem Heap angelegten Speicherbereich haben kann:

* Exklusive Eigentümerschaft
* Geteilte Eigentümerschaft

---
template: plain
header: `std::unique_ptr`

Die Verwendung dieser Art von Smart-Pointer hilft dabei, die exklusive Eigentümerschaft
zu garantieren:

* Sie verfügt über einen *Move-Konstruktor*,
* aber über **keinen** *Copy-Konstruktor*!
* Sie verfügt über ein *Move-Assignment*,
* aber über **kein** Copy-Assignment.

---
template: plain
header: `std::shared_ptr`

Die Verwendung dieser Art von Smart-Pointer hilft dabei, die geteilte Eigentümerschaft
zu garantieren. Ihre Objekte enhalten jeweils *zwei* Zeiger:._[]

  * Einer zeigt auf das refernzierte Objekt,

  * der andere auf einen Referenzzähler.

In Default-Konstruktor, Copy- und Move-Konstruktor, Copy- und Move-Assignment sowie
Destruktor der `std::shared_ptr`-Klasse werden die Referenzzähler gemäß der Anzahl der
Referenzierer eines Objekts verwaltet.

.N[
Fällt der Stand des Referenzzählers von 1 auf 0, wird der Destruktur des referenzierten
Objekts ausgeführt.
]

.F[:
Dies gilt für die typische Implementierung - in einer alternativen Implementierung ist
nur ein Zeiger erforderlich, zum Zugriff muss dann aber eine zusätzliche Dereferenzierung
erfolgen - also der klassiche Austauch von (weniger) Speicherplatz gegen (mehr) Laufzeit.
]

---
template: withinfo
graphic: SmartPointers
section: Problem of Cyclic References
name: refcount_problem
header: ### Problem zyklischer Referenzierung

Mitunter kann es notwendig werden, dass

* dass ein Objekt, auf das per `std::shared_ptr` verwiesen wird,

* selbst wiederum einen `std::shared_ptr` enthält, welcher auf
  Objekte der eigenen Art zeigen kann.._[]

.N[
Dies vorausgesetzt, kann es zyklische Ketten von Referenzen geben, womit irgendwann ein
isolierter, unerreichbar gewordenen Verbund von Objekten im Speicher verbleiben könnte,
welche aller über `std::shared_ptr` miteinander verbunden aber von außen unerreichbar
sind.
]

.F[:
Es müssen nicht zwingend Objekte der eigenen Art sein, auch in der Konstellation
"A zeigt auf B und B auf A" oder "A zeigt auf B, B zeigt auf C und C zeigt auf A"
usw. kann das Problem auftreten.
]

---
template: withinfo
graphic: SmartPointers
section: Breaking Cycles Using Weak Pointers
name: weak_ptr_solution
header: ### Lediglich "beobachtende" Zeiger als Ausweg

Mittels `std::weak_ptr` lassen sich zyklische Referenzen vermeiden.

Dabei ist hinsichtlich aller Referenzierer zu prüfen, ob es sich

* um (echte) Ressource-Eigentümer handelt
* oder lediglich um Resource-Beobachter?

Letzteren kann die Resource "entzogen" werden, wenn es keine (echten)
Ressource-Eigentümer mehr gibt.

---
template: withinfo
graphic: SmartPointers
section: Dangling Weak Pointer
name: weak_ptr_dangling
header: ### "Verlorene" Resourcen

Da die `std::weak_ptr` lediglich Beobachter sind,  unterstützen sie keinen
direkten Zugriff zur referenzierten Ressource (mit `*` oder `->`).

Vielmehr muss durch Aufruf der Member-Funktion `lock` des `std::weak_ptr`
zunächst ein `std::shared_ptr` geholt werden und ähnlich wie beim
`dynamic_cast` werden die zwei häufigsten Verwendungen gezielt unterstützt:

Erste Vorgehensweise

* Rückgabe eines Zeigers und nachfolgend erforderlicher Test,
* wenn diese ergibt, dass der Zeiger ein `nullptr` ist, wurde das
  beobachtete Objekt bereits weggeräumt.

Zweiten Vorgehensweise

* man erhält eine gültige Referenz, die sofort und ohne weitere Prüfungen
  nutzbar ist,
* oder es wird eine Exception geworfen, wenn das beobachtete Objekt bereits
  weggeräumt wurde.

---
template: withinfo
graphic: SmartPointers
section: Implementation Choices
name: implementing_shared_ptr
header: ### Varianten der Implementierung

In der alternativen Implementierung zeigen die Objekte der Klasse `std::shared_ptr`
auf ein Helfer-Objekt, das den Referenzzähler sowie einen Zeiger auf das eigentlich
referenzierte Objekt enthält.

---
template: plain
name: exercise_thu2
header: ## Übung

Ziel der Aufgabe:

Entwicklung eines Ressource-Wrappers im RAII-Stil zum C `FILE`-API.

.N[
Weitere Details werden vom Dozenten anhand des Aufgabenblatts sowie der
vorbereiteten Eclipse-Projekte erläutert.
]

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>
