Vorbemerkung:

    Im Folgenden geht es um zwei verschiedene Realisierungen des Entwurfsmusters,
    das allgemein unter dem Namen "Template-Method-Pattern" bekannt ist.

    Als eine wichtige Klarstellung vorweg sei gesagt aber, dass das Wort "Template"
    im Namen dieses Entwurfsmusters NICHT im Sinne von C++-Templates gemeint ist
    sondern im allgemeineren Sinn als "Schablone" verstanden werden muss.

(1) In der Datei "aufg1.cpp" finden Sie die "klassische" Umsetzung dieses
    Entwurfsmusters mit Hilfe virtueller Member-Functions:

    - Eine BASIS-Klasse enthält den - im Sinne einer "Schablone" - fest
      vorgegebenen Ablauf.
    - An dafür vorgesehenen "Erweiterungspunkten" werden jeweils virtuelle
      Funktionen aufgerufen.
    - Eine ABGELEITETE Klasse enthält lediglich die - aus ihrer Sicht - notwendigen
      Erweiterungen durch passendes Überschreiben dieser virtuellen Funktionen.

    Sehen Sie sich die vorbereiteten Tests an und füllen Sie dann die mit "TO-DO"
    markierten Auslassungen, so dass schließlich alle Tests bestanden werden.

(2) In der Datei "aufg2.cpp" finden Sie die "moderne" Umsetzung dieses
    Entwurfsmusters mit C++-Templates.

    - Die "Schablone" ist als Methode einer Template-Klasse implementiert.
    - Diese hat den über die Template noch offen gehaltenen Typ als Basisklasse.
    - Auch wenn diese Basisklasse noch nicht konkret festgelegt ist, können deren
      Methoden bereits aufgerufen werden. (Voaussetzung ist allerdings, man macht
      deutlich dass es sich um Methoden der Basisklasse und nicht um globale
      Funktionen handelt, z.B. durch using-Anweisungen.)
    - Instanziiert wird die Template mit einer Klasse, welche (lediglich) die
      als Erweiterung der Schablone gedachten Funktionen definiert.

    Dieser Ansatz wird mitunter auch "Inverted Template Method Pattern" genannt,
    da - gegenüber der klassischen Implementierung - die Rollen von Basisklasse
    und abgeleiteter Klasse vertauscht auftreten. Eine andere übliche Bezeichung
    für die Technik, durch in eine Template ausgelagerte Funktionen eine ansonsten
    allgemein gehaltene Klasse an dafür vorgesehenen Punkten zu spezialisieren,
    ist "Policies". Die Zusammenfassung mehrerer, in diesem Sinne zusammengehöriger
    bzw. kooperierender Funktionen wird entsprechend "Policy-Klasse" genannt.

    Sehen Sie sich die vorbereiteten Tests an und füllen Sie dann die mit "TO-DO"
    markierten Auslassungen, so dass schließlich alle Tests bestanden werden.

--  Zusatzaufgabe für besonders Schnelle

    Analysieren Sie in beiden Varianten, wie der "SummingContainerProcessor" den
    für die Ausgabe wichtigen "std::ostream" initialisiert. Konkret geht es um den
    folgenden Unterschied:
    - Warum bleibt in der ersten Version (mit Vererbung und virtuellen Methoden)
      die Basisklasse "ContainerProcessor" von dieser Problematik völlig unberührt?
    - Warum ist das in der zweiten Version (über eine C++-Template parametrisierte
      Policy-Klasse) anders, d.h. warum muss die Basisklasse "ContainerProcessor"
      hier etwas "mithelfen" und wie ließe sich diese Unterstützung durch die
      Basisklasse relativ "universell" gestalten?

    Führen Sie einen vergleichenden Performance-Test der beiden Versionen durch.
    Hinweis: am einfachsten geht dies, indem Sie IODrive-Konfigurationsoption
    	.config_estimate_cputime(true)
    aktivieren. Allerdings misst diese auch den Overhead des Lesens und Schreibens
    der Streams. Für einen "aussagekräftigen" Test müsste sicher gestellt werden,
    dass dieser Overhead keinen maßgeblichen Einfluss auf das Endergebnis hat.
