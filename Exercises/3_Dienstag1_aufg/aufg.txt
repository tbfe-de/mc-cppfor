Aufgabe Dienstagvormittag:

1. In der vorbereiteten Datei aufg1.cpp finden Sie ein Beispiel, in dem insgesamt vier
   Klassen in einer "rautenförmigen Vererbungsbeziehungen" stehen.
   
a) Zeichnen Sie zunächst ein Klassendiagramm und vergessen Sie dabei nicht, die
   Verbindung zur obersten Basisklasse gemäß der UML mit <<overlapping>> oder
   <<disjoint>> zu beschriften (je nach dem, was Sie für angemessen ansehen.

b) Warum erscheint bei unveränderter Kompilierung dieses Beispiels in der vierten
   Zeile der Ausgabe am Anfang ein zufälliger Wert? (Bei der Programmausführung sieht
   dieser evtl. anders aus als im Kursordner, er wird aber recht sicher nicht "4.4"
   sein, wie Sie es vielleicht erwarten.)
c) Was passiert, wenn Sie in diesem - ansonsten unveränderten - Quelltext den Default-
   Konstruktor der Klasse "Value" komplett entfernen?
d) Was ist zu verändern, damit in der Ausgabe am Beginn der vierten Zeile korrekt
   der Wert "4.4" erscheint?
   Hinweis: Die Datei "aufg1_solved.cpp" in diesem Projekt enthält die Lösung.

2. Wie kann eine in Element-Typ und -Anzahl parametrisierte Klasse RingBuffer 
   (zu finden in der Datei aufg2.cpp) als "konfigurierbares Teil" hilfreich
   sein, um wiederum eine Klasse Value zu implementieren, welche die folgenden
   Möglichkeiten bietet:
   
   setValue(double) speichert einen Wert vom Typ double
   getValue() liefert diesen Wert zurück
   getHistoricValue(int n) liefert bis zu 5 "historische" Werte,
   wobei "n" wie folgt interpretiert wird:
   n == 0 --> selbes Ergebnis wie getValue()
   n == 1 --> der VOR dem letzten setValue() gültige Wert
   ... usw. ...
   n == 5 --> der FÜNF setValues() zuvor gültige Wert;
   size() soll die Anzahl der verfügbaren historischen Werte liefern, also 0 wenn
   noch nie ein Wert abgespeichert wurde und maximal 5;
   clear() soll die historischen Werte löschen.
   
   Vergleichen Sie zu diesem Zweck die folgenden Varianten in einer
   UML-Darstellung
   - Value verweist per Zeiger auf ein RingBuffer-Objekt
   - Value enthält ein RingBuffer-Objekt (lebenszeit-gekoppelt)
   - Value hat ein RingBuffer-Objekt als private Basisklasse
   - Value hat ein RingBuffer-Objekt als öffentliche Basisklasse
   
   Unter welchen Umständen hat welche Variante jeweils Vor- und Nachteile gegenüber
   den anderen. (Hinweis: zu dieser Frage gibt es keine eindeutig richtigen und falschen
   Antworten, sie bezweckt lediglich, dass Sie sich selbst nochmal die wesentlichen
   Unterschiede klarmachen.)

   Sehen Sie sich anschließend die verschiedenen Musterlösungen in aufg2a_solved,
   aufg2b_solved, aufg2c_solved und aufg2d_solved an.
   
-- Zusatzaufgabe für besonders Schnelle

   Sehen Sie sich zu den folgenden Aufgaben jeweils die Musterlösungen an und
   beantworten Sie die Fragen. (Hinweis: Die Antworten ergeben sich teilweise
   aus den Kommentaren der genannten Quelltexte ergeben, teilweise aus einer
   Analyse des Source-Codes.

3. Welche Zusatzfunktionalität zu ihrer jeweiligen Basisklasse Value bieten die
   beiden Klassen Average und Extrema in den beiden Lösungs-Varianten aufg3a_solved
   und aufg3b_solved?

   Worin liegt dabei der Unterschied zwischen diesen beiden beiden Varianten?

   Welche zusätzlichen Veränderungen wären nötig, würde man die Basisklasse Value
   in diesen Varianten NICHT public sondern private machen und welche sonstigen
   Folgen hätte dies? (Testen Sie Ihre Vorhersage ggf. auch indem Sie die nötigen
   Änderungen vornehmen.)

   Worin unterscheiden sich die Lösungsvarianten aug3b_solved und aug3c_solved?

4. Welche Problematik entsteht durch die Verwendung der beiden Klassen Average und
   Extrema als Basisklassen der Klasse Statistic in aufg4_solved und warum war es
   sinnvoll, dies ausgehend von der Variante a oder der Variante c aus dem Schritt 3
   Aufgabe zu tun?

   (Anders gefragt: welches Problem tritt auf, wenn man Teil 2 als Vorgabe nimmt?)

5. Welche Vor- und Nachteile hätte es, die Statistic-Funktionalität aus den
   Schritten 3 bzw. 4, also die Speicherung von Werten inkl. Historie, die
   Berechnung des Durchschnitts sowie der Extrema, gemeinsam in einer Klasse zu
   implementieren, welche dann drei Interfaces anbietet, so wie in aufg5_solved
   gezeigt?

6. Welche Vorzüge hat das Klassen-Design aus aufg6_solved, mit dem es die deutlich
   gestiegene Komplexität (und damit die schlechtere Verständlichkeit oder alternativ
   den erhöhten Erklärungsbedarf) evtl. ausgleichen könnte?
   
