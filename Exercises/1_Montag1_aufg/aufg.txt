(1) Sehen Sie sich die Klasse RingBuffer an und beantworten Sie (zunächst
    theoretisch) die folgenden Fragen:
    
    * Welche return-Werte liefern die Member-Funktionen empty()
      und full() für ein neu angelegtes RingBuffer-Objekt?
    * Wie können Elemente eingefügt und entnommen werden?
    * Wieviele Elemente kann ein RingBuffer maximal aufnehmen?
    * Was passiert bei dem Versuch, in einen vollen Ringbuffer ein
      weiteres Elemente einzufügen?
    * Was passiert bei dem Versuch, aus einem leeren RingBuffer ein
      Elemente zu entnehmnen
    * Auf welche Elemente greift die Funktion peek() zu (abhängig
      vom Wert des Aufrufarguments).

    Fügen Sie nun ein Hauptprogramm hinzu, dass diese Erwartungen mit
    Hilfe der C-Funktion assert() überprüft, also ungefähr so:
    
    #include <cassert>
    #include <iostream>
    int main() {
        RingBuffer rb;
        
        // check initial state
        assert(rb.empty());
        assert(!rb.full());
        
        // check put
        rb.put(3.14);
        assert(!rb.empty());
        assert(!rb.full());

        // check get
        double v;
        rb.get(v);
        assert(v == 3.14);
        assert(rb.empty());
        assert(!rb.empty());
        
        // ...
        std::cout << "** ALL TESTS PASSED **" << std::endl;
    }

    Hinweis: Die Ausgabe durch die letzte Zeile des obigen Programms ist
    prinzipiell verzichtbar. MIT dieser Ausgabe wird aber die Tatsache etwas
    unterstrichen, dass aller Erwartungen erfüllt wurden, denn ohne sie würde
    gelten: "No news is good news" - also (nur) solange das Programm KEINE
    Ausgaben erzeugt, ist alles in Ordnung.
    
(2) Fügen Sie eine neue Member-Funktion size() hinzu, mit der sich ermitteln
    lässt, wieviele Elemente der RingBuffer momentan enthält und ergänzen Sie
    die Tests entsprechend.

    Zusatzfrage: Wie ließen sich die assert-s zur Überprüfung des Arguments in
    der Funktion "peek" unter Verwendung der neuen Funktion size() noch etwas
    strenger fassen?

(3) Fügen Sie eine Member-Funktion clear() hinzu, welche alle enthaltenen Elemente
    löscht, also den RingBuffer wieder in den (leeren) Anfangs-Zustand bringt.
    
(4) Verbessern Sie die Klasse RingBuffer in folgenden Punkten:
    * Vermeiden des (unnötigen) Kopierens beim Übergabeparameter von put().
    * Vermeiden der wiederholten Verwendung des Wertes 8 an verschiedenen Stellen
      der Implementierung, indem die Anzahl der Elemente, die der RingBuffer maximal
      aufnehmen kann, als zentrale Konstante definiert wird.

    Hinweis: Sie können die zentrale Konstante wahlweise als initialisiertes
    enum-Element oder als "static const"-Member der Klasse definieren.

--- Ab hier optionale Zusatzaufgabe für besonders schnelle Teilnehmer

    Hinweis: bei den meisten der folgenden Erweiterungsvorschlägen handelt es sich
    nicht unbedingt um "absolut sinnvolle Ergänzungen", welche die RingBuffer-Klasse
    auf jeden Fall haben sollte. Es geht eher darum, einige weitere C++-Features auf
    ein (Code-) Beispiel anzuwenden, welches Sie nun schon einigermaßen kennen. Wenn
    Ihre C++-Kenntnisse für die eine oder andere der vorgeschlagenen Erweiterungen
    nicht ausreichend sind, können Sie sich auch schon die Lösungen ansehen, damit
    Sie ggf. bei der Besprechung der Musterlösungen gezieltere Fragen stellen können.

(5) Schreiben Sie für die Klasse RingBuffer einen Ausgabe-Operator (operator<<),
    welcher alle enthaltenen Werte jeweils gefolgt von einem Semikolon in einen
    ostream schreibt, beginnend mit dem zuerst eingefügten (sofern noch nicht
    überschrieben) und endend mit dem zuletzt eingefügten. Die Elemente sollen
    dabei jedoch NICHT aus dem RingBuffer entfernt werden sondern weiterhin zur
    Entnahme mit der Member-Funktion get() zur Verfügung stehen.

(6) Fügen Sie der Klasse RingBuffer eine Member-Funktion to_string() hinzu, welche
    - ganz ähnlich wie der Ausgabe-Operator aus dem letzten Schritt - alle Elemente
    gefolgt von einem Semikolon zu einem std::string verkettet als Rückgabewert
    liefert.

    Hinweis: Aufgrund der Ähnlichkeit zum Ausgabeoperator sollten Sie evtl. erwägen,
    diesen intern zur Implementierung der to_string() Member-Funktion zu verwenden.

(7) Machen Sie aus der Member-Funktion to_string() eine Typ-Umwandlung, die der
    Compiler immer dann automatisch verwendet, wenn ein RingBuffer-Objekt dort
    angegeben ist, wo ein std::string erwartet wird.

(8) Fügen Sie der Klasse RingBuffer einen Konstruktor hinzu, der als Argument einen
    istream erhält und den RingBuffer mit aus diesem Stream extrahierten Werten
    füllt. Zeigen Sie auch, dass dieser Konstruktor zur automatischen Typumwandlung
    verwendet wird, wenn er nicht als "explicit" markiert ist.
